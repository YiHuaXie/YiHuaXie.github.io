<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OC内存管理-AutoreleasePool</title>
    <url>/2019/01/22/AutoreleasePool%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在MRC中，调用<code>[obj autorelease]</code>来延迟内存的释放；在ARC下，对象调用<code>autorelease</code>方法，就会被自动添加到最近的自动释放池，只有当自动释放池被销毁的时候，才会执行<code>release</code>方法，进行释放。真实结果到底是什么，等看完源码后我们就会知道了。</p>
<h2 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h2><p><code>main.m</code>中有一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换成C++代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;AppDelegate&quot;), sel_registerName(&quot;class&quot;))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@autoreleasepool</code>变成<code>__AtAutoreleasePool __autoreleasepool</code>。<code>__AtAutoreleasePool</code>结构体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它提供了两个方法：<code>objc_autoreleasePoolPush</code>和<code>objc_autoreleasePoolPop</code>。这两个方法的定义在<code>NSObject.mm</code>文件中，分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void *objc_autoreleasePoolPush(void) &#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，<strong>autoreleasepool的自动释放的核心就是AutoreleasePoolPage类</strong>。</p>
<h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><h3 id="AutoreleasePoolPage的结构"><a href="#AutoreleasePoolPage的结构" class="headerlink" title="AutoreleasePoolPage的结构"></a>AutoreleasePoolPage的结构</h3><p>在<code>NSObject.mm</code>文件中定义了<code>AutoreleasePoolPage</code>，这里我们只显示这个类比较重要的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">    // SIZE是AutoreleasePoolPage的大小，4096个字节</span><br><span class="line">    static size_t const SIZE = PAGE_MAX_SIZE;</span><br><span class="line">    // autoreleasepool完整性校验</span><br><span class="line">    magic_t const magic; </span><br><span class="line">    // 单个AutoreleasePoolPage节点是一个链表，next指向栈顶的最新的autorelease对象的下一个位置</span><br><span class="line">    id *next;</span><br><span class="line">    // 当前所在的线程</span><br><span class="line">    pthread_t const thread;</span><br><span class="line">    // 指针，指向前一个AutoreleasePoolPage节点</span><br><span class="line">    AutoreleasePoolPage * const parent;</span><br><span class="line">    // 指针，指向后一个AutoreleasePoolPage节点</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    // 深度</span><br><span class="line">    uint32_t const depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码我们可以知道：</p>
<ul>
<li>AutoreleasePool并没有特定的内存结构，它是通过以<code>AutoreleasePoolPage</code>为节点的双向链表。</li>
<li>每一个<code>AutoreleasePoolPage</code>节点是一个堆栈结构，且大小为4096个字节。</li>
<li>一个<code>AutoreleasePoolPage</code>节点对应着一个线程，属于一一对应关系。</li>
</ul>
<p>AutoreleasePool结构如图所示：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/AutoreleasePoolPage%E9%93%BE%E8%A1%A8.png" alt="AutoreleasePoolPage链表"></p>
<p>接着我们看一下<code>AutoreleasePoolPage</code>的构造函数以及一些操作方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 构造函数</span><br><span class="line">AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">: magic(), next(begin()), thread(pthread_self()),</span><br><span class="line">parent(newParent), child(nil),</span><br><span class="line">depth(parent ? 1+parent-&gt;depth : 0),</span><br><span class="line">hiwat(parent ? parent-&gt;hiwat : 0) &#123;</span><br><span class="line">    if (parent) &#123;</span><br><span class="line">        parent-&gt;check();</span><br><span class="line">        assert(!parent-&gt;child);</span><br><span class="line">        parent-&gt;unprotect();</span><br><span class="line">        parent-&gt;child = this;</span><br><span class="line">        parent-&gt;protect();</span><br><span class="line">    &#125;</span><br><span class="line">    protect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一个AutoreleasePoolPage节点开始存autorelease对象的位置</span><br><span class="line">id *begin() &#123;</span><br><span class="line">    return (id *) ((uint8_t *)this+sizeof(*this));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一个AutoreleasePoolPage节点最大的位置</span><br><span class="line">id *end() &#123;</span><br><span class="line">    return (id *) ((uint8_t *)this+SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AutoreleasePoolPage节点是否为空</span><br><span class="line">bool empty() &#123;</span><br><span class="line">    return next == begin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AutoreleasePoolPage节点是否满</span><br><span class="line">bool full() &#123;</span><br><span class="line">    return next == end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool lessThanHalfFull() &#123;</span><br><span class="line">    return (next - begin() &lt; (end() - begin()) / 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加一个autorelease对象，next指向下一个存对象的地址</span><br><span class="line">id *add(id obj) &#123;</span><br><span class="line">    assert(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    id *ret = next;  // faster than `return next-1` because of aliasing</span><br><span class="line">    *next++ = obj;</span><br><span class="line">    protect();</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放AutoreleasePoolPage节点所有存储的对象</span><br><span class="line">void releaseAll() &#123;</span><br><span class="line">    releaseUntil(begin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以一个空的<code>AutoreleasePoolPage</code>的结构如下：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/AutoreleasePoolPage.png" alt="AutoreleasePoolPage"></p>
<h3 id="AutoreleasePoolPage-push"><a href="#AutoreleasePoolPage-push" class="headerlink" title="AutoreleasePoolPage::push()"></a>AutoreleasePoolPage::push()</h3><p>push代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static inline void *push() &#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    if (DebugPoolAllocation) &#123;</span><br><span class="line">        // Each autorelease pool starts on a new pool page.</span><br><span class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>push执行的时候首先会进行判断，如果是需要每个pool都生成一个新page，即<code>DebugPoolAllocation</code>为<code>YES</code>，则执行<code>autoreleaseNewPage</code>方法，否则执行<code>autoreleaseFast</code>方法。</p>
<h4 id="autoreleaseNewPage"><a href="#autoreleaseNewPage" class="headerlink" title="autoreleaseNewPage"></a>autoreleaseNewPage</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static __attribute__((noinline)) id *autoreleaseNewPage(id obj) &#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    if (page) return autoreleaseFullPage(obj, page);</span><br><span class="line">    else return autoreleaseNoPage(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>autoreleaseNewPage</code>分为两种情况：</p>
<ol>
<li>当前存在page执行<code>autoreleaseFullPage</code>方法；</li>
<li>当前不存在page<code>autoreleaseNoPage</code>方法。</li>
</ol>
<h4 id="autoreleaseFast"><a href="#autoreleaseFast" class="headerlink" title="autoreleaseFast"></a>autoreleaseFast</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj) &#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>autoreleaseFast</code>分为三种情况：</p>
<ol>
<li>存在page且未满，通过<code>add()</code>方法进行添加；</li>
<li>当前page已满执行<code>autoreleaseFullPage</code>方法；</li>
<li>当前不存在page执行<code>autoreleaseNoPage</code>方法。</li>
</ol>
<h4 id="hotPage"><a href="#hotPage" class="headerlink" title="hotPage"></a>hotPage</h4><p>前面讲到的page其实就是<code>hotPage</code>，通过<code>AutoreleasePoolPage *page = hotPage();</code>获取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static inline AutoreleasePoolPage *hotPage() &#123;</span><br><span class="line">    AutoreleasePoolPage *result = (AutoreleasePoolPage *)</span><br><span class="line">    tls_get_direct(key);</span><br><span class="line">    if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil;</span><br><span class="line">    if (result) result-&gt;fastcheck();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们知道当前页是存在<code>TLS（线程私有数据）</code>里面的。所以说<strong>第一次调用push的时候，没有page自然连hotPage也没有</strong>。</p>
<h4 id="autoreleaseFullPage"><a href="#autoreleaseFullPage" class="headerlink" title="autoreleaseFullPage"></a>autoreleaseFullPage</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static __attribute__((noinline)) </span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    // The hot page is full. </span><br><span class="line">    // Step to the next non-full page, adding a new page if necessary.</span><br><span class="line">    // Then add the object to that page.</span><br><span class="line">    assert(page == hotPage());</span><br><span class="line">    assert(page -&gt; full() || DebugPoolAllocation);</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        if (page -&gt; child) page = page -&gt; child;</span><br><span class="line">        else page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page -&gt; full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    return page -&gt; add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>autoreleaseFullPage</code>会从传入的<code>page</code>开始遍历整个双向链表，如果<code>page</code>满了，就看它的<code>child</code>节点，直到查找到一个未满的<code>AutoreleasePoolPage</code>。接着使用<code>AutoreleasePoolPage</code>构造函数传入<code>parent</code>创建一个新的<code>AutoreleasePoolPage</code>的节点（此时跳出了while循环）。</p>
<p>在查找到一个可以使用的<code>AutoreleasePoolPage</code>之后，会将该页面标记成<code>hotPage</code>，然后调动<code>add()</code>方法添加对象。</p>
<h4 id="autoreleaseNoPage"><a href="#autoreleaseNoPage" class="headerlink" title="autoreleaseNoPage"></a>autoreleaseNoPage</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNoPage(id obj) &#123;</span><br><span class="line">    // &quot;no page&quot;意味着没有没有池子被push或者说push了一个空的池子</span><br><span class="line">    assert(!hotPage());</span><br><span class="line"></span><br><span class="line">    bool pushExtraBoundary = false;</span><br><span class="line">    // push了一个空的池子</span><br><span class="line">    if (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">        pushExtraBoundary = true;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        _objc_inform(&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br><span class="line">        &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">        &quot;just leaking - break on &quot;</span><br><span class="line">        &quot;objc_autoreleaseNoPool() to debug&quot;,</span><br><span class="line">        pthread_self(), (void*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;</span><br><span class="line">        // 没有池子被push</span><br><span class="line">        return setEmptyPoolPlaceholder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    if (pushExtraBoundary) &#123;</span><br><span class="line">        // push了一个空的池子，添加哨兵对象</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// haveEmptyPoolPlaceholder函数的实现</span><br><span class="line">static inline bool haveEmptyPoolPlaceholder() &#123;</span><br><span class="line">    id *tls = (id *)tls_get_direct(key);</span><br><span class="line">    return (tls == EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们可以知道，当前内存中不存在<code>AutoreleasePoolPage</code>，就要从头开始构建这个自动释放池的双向链表，也就是说，新的<code>AutoreleasePoolPage</code>是没有<code>parent</code>指针的。初始化之后，将当前页标记为<code>hotPage</code>，然后会先向这个<code>page</code>中添加一个<code>POOL_BOUNDARY</code>的标记，来确保在<code>pop</code>调用的时候，不会出现异常。最后，将<code>obj</code>添加到自动释放池中。</p>
<p>所以push的流程是：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/AutoreleasePoolPush%E6%B5%81%E7%A8%8B.png" alt="AutoreleasePoolPush流程"></p>
<h3 id="AutoreleasePoolPage-pop-ctxt"><a href="#AutoreleasePoolPage-pop-ctxt" class="headerlink" title="AutoreleasePoolPage::pop(ctxt)"></a>AutoreleasePoolPage::pop(ctxt)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static inline void pop(void *token) &#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    // 第一种情况：autoreleasepool首次push的时候返回的，也就是最顶层的page执行pop会执行这一部分</span><br><span class="line">    if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        // Popping the top-level placeholder pool.</span><br><span class="line">        if (hotPage()) &#123;</span><br><span class="line">            // Pool was used. Pop its contents normally.</span><br><span class="line">            // Pool pages remain allocated for re-use as usual.</span><br><span class="line">            pop(coldPage() -&gt; begin());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Pool was never used. Clear the placeholder.</span><br><span class="line">            setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);</span><br><span class="line"></span><br><span class="line">    // https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now</span><br><span class="line">    // 第二种情况：在非ARC的情况下，在新创建的线程中不使用autoreleasepool，直接调用autorelease方法时会出现这个情况，</span><br><span class="line">    // 此时没有pool，直接进行autorelease。</span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    if (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        if (stop == page -&gt; begin() &amp;&amp; !page -&gt; parent) &#123;</span><br><span class="line">            // Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class="line">            // 1. top-level pool is popped, leaving the cold page in place</span><br><span class="line">            // 2. an object is autoreleased with no pool</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Error. For bincompat purposes this is not</span><br><span class="line">            // fatal in executables built with old SDKs.</span><br><span class="line">            return badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">    // 第三种情况：也就是我们经常碰到的情况</span><br><span class="line">    page -&gt; releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    // memory: delete empty children</span><br><span class="line">    if (DebugPoolAllocation &amp;&amp; page -&gt; empty()) &#123;</span><br><span class="line">        // special case: delete everything during page-per-pool debugging</span><br><span class="line">        AutoreleasePoolPage *parent = page -&gt; parent;</span><br><span class="line">        page -&gt; kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; else if (DebugMissingPools &amp;&amp; page -&gt; empty() &amp;&amp; !page -&gt; parent) &#123;</span><br><span class="line">        // special case: delete everything for pop(top)</span><br><span class="line">        // when debugging missing autorelease pools</span><br><span class="line">        page -&gt; kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; else if (page -&gt; child) &#123;</span><br><span class="line">        // hysteresis: keep one empty child if page is more than half full</span><br><span class="line">        if (page -&gt; lessThanHalfFull()) &#123;</span><br><span class="line">            page -&gt; child -&gt; kill();</span><br><span class="line">        &#125; else if (page -&gt; child -&gt; child) &#123;</span><br><span class="line">            page -&gt; child -&gt; child -&gt; kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们主要分析下第三种情况。</p>
<h4 id="releaseUntil"><a href="#releaseUntil" class="headerlink" title="releaseUntil"></a>releaseUntil</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void releaseUntil(id *stop) &#123;</span><br><span class="line">    while (this-&gt;next != stop) &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">        while (page-&gt;empty()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        id obj = *--page-&gt;next;</span><br><span class="line">        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        if (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setHotPage(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从next指针开始，一个一个向前调用<code>objc_release</code>，直到碰到push时压入的pool为止。</p>
<p>所以autoreleasePool的运行过程应该是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool1 = push()</span><br><span class="line">...</span><br><span class="line">    pool2 = push()</span><br><span class="line">    ...</span><br><span class="line">        pool3 = push()</span><br><span class="line">        ...</span><br><span class="line">        pop(pool3)</span><br><span class="line">    ...</span><br><span class="line">    pop(pool2)</span><br><span class="line">...</span><br><span class="line">pop(pool1)</span><br></pre></td></tr></table></figure>
<p>每次pop，实际上都会把最近一次push之后添加进去的对象全部release掉。</p>
<h2 id="autorelease方法"><a href="#autorelease方法" class="headerlink" title="autorelease方法"></a>autorelease方法</h2><p>接着看一下当对象调用<code>autorelase</code>方法发生了什么。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)autorelease &#123;</span><br><span class="line">    return ((id)self)-&gt;rootAutorelease();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline id objc_object::rootAutorelease() &#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;</span><br><span class="line"></span><br><span class="line">    return rootAutorelease2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((noinline,used)) idobjc_object::rootAutorelease2() &#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline id autorelease(id obj) &#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    assert(!obj-&gt;isTaggedPointer());</span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    assert(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码我们看到，对象调用<code>autorelase</code>方法，最后会变成<code>AutoreleasePoolPage</code>的<code>autorelease</code>函数。<code>AutoreleasePoolPage</code>的<code>autorelease</code>的本质就是调用<code>autoreleaseFast(obj)</code>函数。只不过<code>push</code>操作插入的是一个<code>POOL_BOUNDARY</code> ，而<code>autorelease</code>操作插入的是一个具体的<code>autoreleased</code>对象即<code>AutoreleasePoolPage</code>入栈操作。</p>
<p>当然这么说并不严谨，因为我们需要考虑是否是<code>Tagged Pointer</code>和是否进行优化的情况（<code>prepareOptimizedReturn</code>这个后面也会提到），如果不满足这两个条件才会进入缓存池。</p>
<h2 id="AutoreleasePool、Runloop、线程之间的关系"><a href="#AutoreleasePool、Runloop、线程之间的关系" class="headerlink" title="AutoreleasePool、Runloop、线程之间的关系"></a>AutoreleasePool、Runloop、线程之间的关系</h2><p>苹果的文档中提到：</p>
<blockquote>
<p>Each NSThread object, including the application’s main thread, has an NSRunLoop object automatically created for it as needed.</p>
</blockquote>
<blockquote>
<p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p>
</blockquote>
<blockquote>
<p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p>
</blockquote>
<p>我们可以知道：</p>
<ol>
<li><p>每一个线程，包括主线程，都会拥有一个专属的runloop，并且会在有需要的时候自动创建。</p>
</li>
<li><p>主线程在runloop开始之前会自动创建一个autoreleasePool，并在结束时pop。</p>
</li>
<li><p>每一个线程都会维护自己的autoreleasePool堆栈，也就是说每一个autoreleasePool对应一个线程。</p>
</li>
</ol>
<h2 id="进入AutoreleasePool的时机"><a href="#进入AutoreleasePool的时机" class="headerlink" title="进入AutoreleasePool的时机"></a>进入AutoreleasePool的时机</h2><p>那什么样的对象会进入autoreleasePool呢？ </p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="测试1-1"><a href="#测试1-1" class="headerlink" title="测试1.1"></a>测试1.1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *arr = [NSMutableArray new];</span><br><span class="line">NSLog(@&quot;%lu&quot;, _objc_rootRetainCount(arr));</span><br><span class="line">_objc_autoreleasePoolPrint();</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-01-22 15:50:45.129263+0800 AutoreleasePool[31529:22121744] 1</span><br><span class="line">objc[31529]: ##############</span><br><span class="line">objc[31529]: AUTORELEASE POOLS for thread 0x1176345c0</span><br><span class="line">objc[31529]: 2 releases pending.</span><br><span class="line">objc[31529]: [0x7f96e0802000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[31529]: [0x7f96e0802038]    0x600003ac8f00  __NSArrayI</span><br><span class="line">objc[31529]: [0x7f96e0802040]    0x600000ceef80  __NSSetI</span><br><span class="line">objc[31529]: ##############</span><br></pre></td></tr></table></figure>
<h4 id="测试1-2"><a href="#测试1-2" class="headerlink" title="测试1.2"></a>测试1.2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@autoreleasepool&#123;</span><br><span class="line">    NSMutableArray *arr = [NSMutableArray new];</span><br><span class="line">    NSLog(@&quot;%lu&quot;, _objc_rootRetainCount(arr));</span><br><span class="line">    _objc_autoreleasePoolPrint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-01-22 15:53:28.818873+0800 AutoreleasePool[31568:22134125] 1</span><br><span class="line">objc[31568]: ##############</span><br><span class="line">objc[31568]: AUTORELEASE POOLS for thread 0x10d20e5c0</span><br><span class="line">objc[31568]: 3 releases pending.</span><br><span class="line">objc[31568]: [0x7fcf66002000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[31568]: [0x7fcf66002038]    0x600000129200  __NSArrayI</span><br><span class="line">objc[31568]: [0x7fcf66002040]    0x60000370b020  __NSSetI</span><br><span class="line">objc[31568]: [0x7fcf66002048]  ################  POOL 0x7fcf66002048</span><br><span class="line">objc[31568]: ##############</span><br></pre></td></tr></table></figure>
<h4 id="测试1-3"><a href="#测试1-3" class="headerlink" title="测试1.3"></a>测试1.3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSMutableArray *arr = [NSMutableArray new];</span><br><span class="line">    NSLog(@&quot;%lu&quot;, _objc_rootRetainCount(arr));</span><br><span class="line">    _objc_autoreleasePoolPrint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@autoreleasepool&#123;</span><br><span class="line">    NSMutableArray *arr = [NSMutableArray new];</span><br><span class="line">    NSLog(@&quot;%lu&quot;, _objc_rootRetainCount(arr));</span><br><span class="line">     _objc_autoreleasePoolPrint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-01-22 15:55:21.271452+0800 AutoreleasePool[31596:22141965] 1</span><br><span class="line">objc[31596]: ##############</span><br><span class="line">objc[31596]: AUTORELEASE POOLS for thread 0x1166f15c0</span><br><span class="line">objc[31596]: 2 releases pending.</span><br><span class="line">objc[31596]: [0x7fdcaf002000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[31596]: [0x7fdcaf002038]    0x600003e6a500  __NSArrayI</span><br><span class="line">objc[31596]: [0x7fdcaf002040]    0x600000849db0  __NSSetI</span><br><span class="line">objc[31596]: ##############</span><br><span class="line">2019-01-22 15:55:21.272353+0800 AutoreleasePool[31596:22141965] 1</span><br><span class="line">objc[31596]: ##############</span><br><span class="line">objc[31596]: AUTORELEASE POOLS for thread 0x1166f15c0</span><br><span class="line">objc[31596]: 3 releases pending.</span><br><span class="line">objc[31596]: [0x7fdcaf002000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[31596]: [0x7fdcaf002038]    0x600003e6a500  __NSArrayI</span><br><span class="line">objc[31596]: [0x7fdcaf002040]    0x600000849db0  __NSSetI</span><br><span class="line">objc[31596]: [0x7fdcaf002048]  ################  POOL 0x7fdcaf002048</span><br><span class="line">objc[31596]: ##############</span><br></pre></td></tr></table></figure>
<h4 id="测试2-1"><a href="#测试2-1" class="headerlink" title="测试2.1"></a>测试2.1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *arr = [NSMutableArray array];</span><br><span class="line">NSLog(@&quot;%lu&quot;, _objc_rootRetainCount(arr));</span><br><span class="line">_objc_autoreleasePoolPrint();</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-01-22 15:57:02.360860+0800 AutoreleasePool[31615:22149043] 2</span><br><span class="line">objc[31615]: ##############</span><br><span class="line">objc[31615]: AUTORELEASE POOLS for thread 0x1111eb5c0</span><br><span class="line">objc[31615]: 3 releases pending.</span><br><span class="line">objc[31615]: [0x7fbf00002000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[31615]: [0x7fbf00002038]    0x600003f15c00  __NSArrayI</span><br><span class="line">objc[31615]: [0x7fbf00002040]    0x6000009705f0  __NSSetI</span><br><span class="line">objc[31615]: [0x7fbf00002048]    0x600002404f30  __NSArrayM</span><br><span class="line">objc[31615]: ##############</span><br></pre></td></tr></table></figure>
<h4 id="测试2-2"><a href="#测试2-2" class="headerlink" title="测试2.2"></a>测试2.2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    NSMutableArray *arr = [NSMutableArray array];</span><br><span class="line">    NSLog(@&quot;%lu&quot;, _objc_rootRetainCount(arr));</span><br><span class="line">    _objc_autoreleasePoolPrint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-01-22 15:58:29.932693+0800 AutoreleasePool[31634:22153810] 2</span><br><span class="line">objc[31634]: ##############</span><br><span class="line">objc[31634]: AUTORELEASE POOLS for thread 0x115aac5c0</span><br><span class="line">objc[31634]: 4 releases pending.</span><br><span class="line">objc[31634]: [0x7f867c002000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[31634]: [0x7f867c002038]    0x600000b00080  __NSArrayI</span><br><span class="line">objc[31634]: [0x7f867c002040]    0x600003d64190  __NSSetI</span><br><span class="line">objc[31634]: [0x7f867c002048]  ################  POOL 0x7f867c002048</span><br><span class="line">objc[31634]: [0x7f867c002050]    0x60000100ff30  __NSArrayM</span><br><span class="line">objc[31634]: ##############</span><br></pre></td></tr></table></figure>
<h4 id="测试2-3"><a href="#测试2-3" class="headerlink" title="测试2.3"></a>测试2.3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSMutableArray *arr = [NSMutableArray array];</span><br><span class="line">    NSLog(@&quot;%lu&quot;, _objc_rootRetainCount(arr));</span><br><span class="line">    _objc_autoreleasePoolPrint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    NSMutableArray *arr = [NSMutableArray array];</span><br><span class="line">    NSLog(@&quot;%lu&quot;, _objc_rootRetainCount(arr));</span><br><span class="line">     _objc_autoreleasePoolPrint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-01-22 16:01:11.925690+0800 AutoreleasePool[31670:22164284] 2</span><br><span class="line">objc[31670]: ##############</span><br><span class="line">objc[31670]: AUTORELEASE POOLS for thread 0x11bffa5c0</span><br><span class="line">objc[31670]: 3 releases pending.</span><br><span class="line">objc[31670]: [0x7ff965802000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[31670]: [0x7ff965802038]    0x600001c1eb00  __NSArrayI</span><br><span class="line">objc[31670]: [0x7ff965802040]    0x600002a47200  __NSSetI</span><br><span class="line">objc[31670]: [0x7ff965802048]    0x600000712490  __NSArrayM</span><br><span class="line">objc[31670]: ##############</span><br><span class="line">2019-01-22 16:01:11.926577+0800 AutoreleasePool[31670:22164284] 1</span><br><span class="line">objc[31670]: ##############</span><br><span class="line">objc[31670]: AUTORELEASE POOLS for thread 0x11bffa5c0</span><br><span class="line">objc[31670]: 4 releases pending.</span><br><span class="line">objc[31670]: [0x7ff965802000]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[31670]: [0x7ff965802038]    0x600001c1eb00  __NSArrayI</span><br><span class="line">objc[31670]: [0x7ff965802040]    0x600002a47200  __NSSetI</span><br><span class="line">objc[31670]: [0x7ff965802048]    0x600000712490  __NSArrayM</span><br><span class="line">objc[31670]: [0x7ff965802050]  ################  POOL 0x7ff965802050</span><br><span class="line">objc[31670]: ##############****</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们可以知道，使用<code>new</code>、<code>alloc</code>这样的方法创建的对象实例是不会进入autoreleasePool的，但是使用简便方法创建的对象如<code>[NSMutableArray array]</code>是会进入自动缓存池的。</p>
<p>但是在测试2.3上，我们可以看到，只有一个array进入了自动缓存池，另外一个没有进入。看一下它的方法调用栈：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/1548145578479.jpg" alt="1548145578479"></p>
<p>在《Objective-C高级编程》第66-67页提到了最优化程序运行。通过<code>objc_retainAutoreleasedReturnValue</code>和<code>objc_retainAutoreleaseReturnValue</code>函数的协作，可以不将对象注册到autoreleasePool中而直接传递，这一过程达到最优化。</p>
<h3 id="objc-retainAutoreleasedReturnValue"><a href="#objc-retainAutoreleasedReturnValue" class="headerlink" title="objc_retainAutoreleasedReturnValue"></a>objc_retainAutoreleasedReturnValue</h3><p><code>objc_retainAutoreleasedReturnValue</code>的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Accept a value returned through a +0 autoreleasing convention for use at +1.</span><br><span class="line">id</span><br><span class="line">objc_retainAutoreleasedReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (acceptOptimizedReturn() == ReturnAtPlus1) return obj;</span><br><span class="line"></span><br><span class="line">    return objc_retain(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Try to accept an optimized return.</span><br><span class="line">// Returns the disposition of the returned object (+0 or +1).</span><br><span class="line">// An un-optimized return is +0.</span><br><span class="line">static ALWAYS_INLINE ReturnDisposition </span><br><span class="line">acceptOptimizedReturn()</span><br><span class="line">&#123;</span><br><span class="line">    ReturnDisposition disposition = getReturnDisposition();</span><br><span class="line">    setReturnDisposition(ReturnAtPlus0);  // reset to the unoptimized state</span><br><span class="line">    return disposition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ALWAYS_INLINE ReturnDisposition </span><br><span class="line">getReturnDisposition()</span><br><span class="line">&#123;</span><br><span class="line">    return (ReturnDisposition)(uintptr_t)tls_get_direct(RETURN_DISPOSITION_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们可以知道<code>objc_retainAutoreleasedReturnValue</code>会尝试接收一个被优化的结果，如何是<code>ReturnAtPlus1</code>即<code>YES</code>，返回对象本身，否则执行<code>objc_retain(obj</code>。</p>
<p>这个被优化的结果是在线程私有数据TLS中的，我们可以理解为一个优化位。当优化位返回YES的时候，直接返回对象本身，否则执行retain。</p>
<h3 id="objc-retainAutoreleaseReturnValue"><a href="#objc-retainAutoreleaseReturnValue" class="headerlink" title="objc_retainAutoreleaseReturnValue"></a>objc_retainAutoreleaseReturnValue</h3><p><code>objc_retainAutoreleaseReturnValue</code>的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Prepare a value at +0 for return through a +0 autoreleasing convention.</span><br><span class="line">id </span><br><span class="line">objc_retainAutoreleaseReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus0)) return obj;</span><br><span class="line"></span><br><span class="line">    // not objc_autoreleaseReturnValue(objc_retain(obj)) </span><br><span class="line">    // because we don&apos;t need another optimization attempt</span><br><span class="line">    return objc_retainAutoreleaseAndReturn(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Try to prepare for optimized return with the given disposition (+0 or +1).</span><br><span class="line">// Returns true if the optimized path is successful.</span><br><span class="line">// Otherwise the return value must be retained and/or autoreleased as usual.</span><br><span class="line">static ALWAYS_INLINE bool </span><br><span class="line">prepareOptimizedReturn(ReturnDisposition disposition)</span><br><span class="line">&#123;</span><br><span class="line">    assert(getReturnDisposition() == ReturnAtPlus0);</span><br><span class="line"></span><br><span class="line">    if (callerAcceptsOptimizedReturn(__builtin_return_address(0))) &#123;</span><br><span class="line">        if (disposition) setReturnDisposition(disposition);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ALWAYS_INLINE bool </span><br><span class="line">callerAcceptsOptimizedReturn(const void * const ra0)</span><br><span class="line">&#123;</span><br><span class="line">    const uint8_t *ra1 = (const uint8_t *)ra0;</span><br><span class="line">    const unaligned_uint16_t *ra2;</span><br><span class="line">    const unaligned_uint32_t *ra4 = (const unaligned_uint32_t *)ra1;</span><br><span class="line">    const void **sym;</span><br><span class="line"></span><br><span class="line">#define PREFER_GOTPCREL 0</span><br><span class="line">#if PREFER_GOTPCREL</span><br><span class="line">    // 48 89 c7    movq  %rax,%rdi</span><br><span class="line">    // ff 15       callq *symbol@GOTPCREL(%rip)</span><br><span class="line">    if (*ra4 != 0xffc78948) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ra1[4] != 0x15) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ra1 += 3;</span><br><span class="line">#else</span><br><span class="line">    // 48 89 c7    movq  %rax,%rdi</span><br><span class="line">    // e8          callq symbol</span><br><span class="line">    if (*ra4 != 0xe8c78948) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ra1 += (long)*(const unaligned_int32_t *)(ra1 + 4) + 8l;</span><br><span class="line">    ra2 = (const unaligned_uint16_t *)ra1;</span><br><span class="line">    // ff 25       jmpq *symbol@DYLDMAGIC(%rip)</span><br><span class="line">    if (*ra2 != 0x25ff) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    ra1 += 6l + (long)*(const unaligned_int32_t *)(ra1 + 2);</span><br><span class="line">    sym = (const void **)ra1;</span><br><span class="line">    if (*sym != objc_retainAutoreleasedReturnValue  &amp;&amp;  </span><br><span class="line">        *sym != objc_unsafeClaimAutoreleasedReturnValue) </span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Same as objc_retainAutorelease but suitable for tail-calling </span><br><span class="line">// if you don&apos;t want to push a frame before this point.</span><br><span class="line">__attribute__((noinline))</span><br><span class="line">static id </span><br><span class="line">objc_retainAutoreleaseAndReturn(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    return objc_retainAutorelease(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">objc_retainAutorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    return objc_autorelease(objc_retain(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要涉及到<code>callerAcceptsOptimizedReturn</code>，这个函数意思不是很理解，但是里面涉及到了<code>objc_retainAutoreleasedReturnValue</code>，猜测可能是程序检测在返回值之后是否紧接着调用了<code>objc_retainAutoreleasedReturnValue</code>，如果是，就知道了外部是ARC环境走优化路线，反之就走没被优化的逻辑。</p>
<p>所以个人认为，<strong>使用<code>new</code>、<code>alloc</code>这样的方法创建的对象实例是不会进入autoreleasePool的，但是使用简便方法创建的对象，程序会进行优化后，再决定是否进入自动缓存池</strong>。</p>
<p>另外关于main函数中的<code>@autoreleasepool</code>的作用是什么？简单的说就是让那些进入自动缓存池的对象有个地方被释放。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="AutoreleasePool的本质"><a href="#AutoreleasePool的本质" class="headerlink" title="AutoreleasePool的本质"></a>AutoreleasePool的本质</h3><p>AutoreleasePool并没有特定的内存结构，它是通过以AutoreleasePoolPage为节点的双向链表，每一个AutoreleasePoolPage节点是一个堆栈结构，且每个AutoreleasePoolPage节点对应着一个线程，属于一一对应关系。</p>
<h3 id="AutoreleasePool、Runloop、线程之间的关系-1"><a href="#AutoreleasePool、Runloop、线程之间的关系-1" class="headerlink" title="AutoreleasePool、Runloop、线程之间的关系"></a>AutoreleasePool、Runloop、线程之间的关系</h3><ul>
<li><p>每一个线程，包括主线程，都会拥有一个专属的runloop，并且会在有需要的时候自动创建。</p>
</li>
<li><p>主线程在runloop开始之前会自动创建一个autoreleasePool，并在结束时pop。</p>
</li>
<li><p>每一个线程都会维护自己的autoreleasePool堆栈，也就是说每一个autoreleasePool对应一个线程。</p>
</li>
</ul>
<h3 id="AutoreleasePool是工作原理"><a href="#AutoreleasePool是工作原理" class="headerlink" title="AutoreleasePool是工作原理"></a>AutoreleasePool是工作原理</h3><ol>
<li><p>在APP中，整个主线程是运行在一个自动释放池中的。</p>
</li>
<li><p>使用<code>@autoreleasepool</code>标记，调用push()方法。</p>
</li>
<li><p>没有hotpage，调用<code>autoreleaseNoPage()</code>，设置<code>EMPTY_POOL_PLACEHOLDER</code>。</p>
</li>
<li><p>因为设置了<code>EMPTY_POOL_PLACEHOLDER</code>，所以会设置本页为<code>hotpage</code>，添加边界标记<code>POOL_BOUNDARY</code>，最后添加obj。</p>
</li>
<li><p>继续有对象调用<code>autorelease</code>，此时已经有了page，调用<code>page-&gt;add(obj)</code>。</p>
</li>
<li><p>如果page满了，调用<code>autoreleaseFullPage()</code>创建新page，重复第6点。</p>
</li>
<li><p>到达autoreleasePool边界，调用pop方法，通常情况下会释放掉<code>POOL_BOUNDARY</code>之后的所有对象</p>
</li>
</ol>
<h3 id="什么样的对象对进入AutoreleasePool"><a href="#什么样的对象对进入AutoreleasePool" class="headerlink" title="什么样的对象对进入AutoreleasePool"></a>什么样的对象对进入AutoreleasePool</h3><ul>
<li><p>使用Tagged Pointer技术的对象不会进入AutoreleasePool；</p>
</li>
<li><p>使用<code>new</code>、<code>alloc</code>这样的方法创建的对象实例是不会进入autoreleasePool的；</p>
</li>
<li><p>使用简便方法创建的对象，程序会进行优化后，再决定是否进入自动缓存池。</p>
</li>
</ul>
<h3 id="main函数中的自动释放池的作用"><a href="#main函数中的自动释放池的作用" class="headerlink" title="main函数中的自动释放池的作用"></a>main函数中的自动释放池的作用</h3><p>这个池块给出了一个pop点来显式的告诉我们这里有一个释放点，如果你的main在初始化的过程中有别的内容可以放在这里。</p>
<h3 id="什么时候需要手动创建AutoreleasePool"><a href="#什么时候需要手动创建AutoreleasePool" class="headerlink" title="什么时候需要手动创建AutoreleasePool"></a>什么时候需要手动创建AutoreleasePool</h3><ul>
<li><p>一段代码里面（比如for循环）大量使用便利构造器创建对象，可能需要手动添加自动释放池；</p>
</li>
<li><p>在子线程中可能会使用便利构造器等方法来创建对象（类方法），那么这些对象的释放只能放在自动释放池中，此时可能需要在子线程中添加自动释放池。</p>
</li>
</ul>
<h3 id="子线程在使用autorelease对象的能否确保自动释放"><a href="#子线程在使用autorelease对象的能否确保自动释放" class="headerlink" title="子线程在使用autorelease对象的能否确保自动释放"></a>子线程在使用autorelease对象的能否确保自动释放</h3><p>必须能！底层函数<code>autoreleaseNoPage</code>会在没有autoreleasepool的情况下懒加载一个出来。即使push但是没有pop也没关系，当线程exit的时候会释放资源，会执行<code>AutoreleasePoolPage::tls_dealloc</code>，在这里面会清空autoreleasepool。</p>
<h3 id="AutoreleasePool释放对象的时机"><a href="#AutoreleasePool释放对象的时机" class="headerlink" title="AutoreleasePool释放对象的时机"></a>AutoreleasePool释放对象的时机</h3><ul>
<li><p>在没有手动建立AutoreleasePool的情况下，主线程是通过RunLoop的监听来决定释放autorelease对象的时机的，而子线程则是在退出线程的时候来释放autorelease对象；</p>
</li>
<li><p>在手动建立AutoreleasePool的情况下，autorelease对象的生命周期仅在block块内。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>OC对象内存</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>Block原理</title>
    <url>/2018/09/05/Blocks%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>更新日期：2019-07-22</p>
<h2 id="Block的实质"><a href="#Block的实质" class="headerlink" title="Block的实质"></a>Block的实质</h2><p>我们先写一个最基础的block</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    void (^testBlock)(void) = ^&#123;</span><br><span class="line">        printf(&quot;asddasd&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    testBlock();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code>转化成C++代码。其中有关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    void (*testBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将代码简化一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    // 定义block变量</span><br><span class="line">    void (*testBlock)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">    </span><br><span class="line">    // 执行block</span><br><span class="line">    testBlock-&gt;FuncPtr(testBlock);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出我们定义的<code>testBlock</code>变成了<code>&amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA)</code>，执行block的时候将<code>testBlock()</code>变成了<code>testBlock-&gt;FuncPtr(testBlock)</code></p>
<p><code>__main_block_impl_0</code>是一个结构体，相关定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa; // isa是OC对象特有的标志</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr; // 该指针指向block执行函数的地址</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;   // 预留的字段</span><br><span class="line">    size_t Block_size; // block所占内存大小</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">// __main_block_impl_0是一个C++结构体可以声明函数</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __main_block_desc_0* Desc;</span><br><span class="line">    // 没有返回类型，与结构体同名的函数，这样的函数称为构造函数</span><br><span class="line">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock; // 初始化__block_impl结构体的isa成员变量</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp; // fp就是__main_block_func_0函数</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 该函数封装了block的执行代码</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    printf(&quot;asddasd&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__main_block_impl_0</code>有两个成员变量，分别是<code>__block_impl impl</code>和<code>__main_block_desc_0* Desc</code>，还有一个<code>__main_block_impl_0</code>的构造函数。<code>__block_impl</code>和<code>__main_block_desc_0</code>也是两个结构体，其成员变量作用都写在代码注释中，这里就不再说了。</p>
<p>最重要的是其构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义block变量的时候，传入的<code>__main_block_func_0</code>和<code>&amp;__main_block_desc_0_DATA</code>分别对应了<code>fp</code>和<code>* desc</code>。<code>fp</code>指向的就是<code>__main_block_func_0</code>函数，它会传给<code>impl.FuncPtr</code>，另外的<code>isa</code>的初始值是<code>_NSConcreteStackBlock</code>，<code>_NSConcreteStackBlock</code>就相当于<code>class_t</code>中的结构体类型的。</p>
<p>接着看调用部分，关于block的调用会被转化成<code>testBlock-&gt;FuncPtr(testBlock)</code>，它指向的是<code>__main_block_func_0</code>函数的地址。这里要注意<code>testBlock-&gt;FuncPtr(testBlock)</code>是我将强制转化取消后的代码，原本应该是<code>(__block_impl *)testBlock-&gt;FuncPtr(testBlock)</code>，因为<code>__block_impl imp</code>是<code>__main_block_impl_0</code>这个结构体的第一个成员变量，所以<code>__block_impl imp</code>的内存地址就是<code>__main_block_impl_0</code>结构体的内存地址。</p>
<p>所以说<strong>block的本质就是Objective-C对象，block的调用就是函数指针的调用</strong>。</p>
<h2 id="截获自动变量值"><a href="#截获自动变量值" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h2><p>根据《Objective-C高级编程》一书中提到，所谓的“截获自动变量值”意味着在执行Block语法时，Block语法表达式所使用的自动变量被保存到Block的结构体实例（即Block自身中）。</p>
<p>那不同类型变量之间的截获会有区别吗，使用以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">static int globalStaticValue = 1;</span><br><span class="line"></span><br><span class="line">int globalValue = 2;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    int a = 3;</span><br><span class="line">    </span><br><span class="line">    static int b = 4;</span><br><span class="line">    </span><br><span class="line">    void (^testBlock)(void) = ^&#123;</span><br><span class="line">        printf(&quot;%d&quot;, globalStaticValue);</span><br><span class="line">        printf(&quot;%d&quot;, globalValue);</span><br><span class="line">        printf(&quot;%d&quot;, a);</span><br><span class="line">        printf(&quot;%d&quot;, b);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    testBlock();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转化成C++代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int globalStaticValue = 1;</span><br><span class="line">int globalValue = 2;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __main_block_desc_0* Desc;</span><br><span class="line">    int a;</span><br><span class="line">    int *b;</span><br><span class="line">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int *_b, int flags=0) : a(_a), b(_b) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    int a = __cself-&gt;a; // bound by copy</span><br><span class="line">    int *b = __cself-&gt;b; // bound by copy</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%d&quot;, globalStaticValue);</span><br><span class="line">    printf(&quot;%d&quot;, globalValue);</span><br><span class="line">    printf(&quot;%d&quot;, a);</span><br><span class="line">    printf(&quot;%d&quot;, (*b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    int a = 3;</span><br><span class="line">    </span><br><span class="line">    static int b = 4;</span><br><span class="line">    </span><br><span class="line">    void (*testBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, &amp;b));</span><br><span class="line">    </span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出：</p>
<ul>
<li><strong>局部变量会被block直接截获</strong>；</li>
<li><strong>局部静态变量会被block直接截获其指针，通过指针进行方法</strong>；</li>
<li><strong>全局变量和全局静态变量并不会被截获，而是直接使用</strong>；</li>
</ul>
<h2 id="截获对象"><a href="#截获对象" class="headerlink" title="截获对象"></a>截获对象</h2><p>block是如何截获对象变量的，使用如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">static NSObject *globalObjc;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;    </span><br><span class="line">    NSObject *object = [[NSObject alloc] init];</span><br><span class="line">    __weak NSObject *weakObject = object;</span><br><span class="line">    </span><br><span class="line">    void (^testBlock)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, object);</span><br><span class="line">        NSLog(@&quot;%@&quot;, weakObject);</span><br><span class="line">        NSLog(@&quot;%@&quot;, globalObjc);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    testBlock();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</code>命令，转化成C++代码后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static NSObject *globalObjc;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __main_block_desc_0* Desc;</span><br><span class="line">    NSObject *__strong object;</span><br><span class="line">    NSObject *__weak weakObject;</span><br><span class="line">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSObject *__strong _object, NSObject *__weak _weakObject, int flags=0) : object(_object), weakObject(_weakObject) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    NSObject *__strong object = __cself-&gt;object; // bound by copy</span><br><span class="line">    NSObject *__weak weakObject = __cself-&gt;weakObject; // bound by copy</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2p_n_j9tbqx6lqb2bqv110q6d300000gn_T_main_a7d9fa_mi_0, object);</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2p_n_j9tbqx6lqb2bqv110q6d300000gn_T_main_a7d9fa_mi_1, weakObject);</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2p_n_j9tbqx6lqb2bqv110q6d300000gn_T_main_a7d9fa_mi_2, globalObjc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((void*)&amp;dst-&gt;object, (void*)src-&gt;object, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">    _Block_object_assign((void*)&amp;dst-&gt;weakObject, (void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((void*)src-&gt;object, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">    _Block_object_dispose((void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">    void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSObject *object = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line">    __attribute__((objc_ownership(weak))) NSObject *weakObject = object;</span><br><span class="line"></span><br><span class="line">    void (*testBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, object, weakObject, 570425344));</span><br><span class="line"></span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<strong>截获的变量是对象类型的，会将对象变量及其所有权修饰符一并截获</strong>。再看一下<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>。</p>
<ul>
<li>当block进行一次copy操作的时候，<code>__main_block_copy_0</code>函数内部调用<code>_Block_object_assign</code>函数，它根据对象的类型产生强引用或者弱引用；</li>
<li>当block从堆中移除的时候，<code>__main_block_dispose_0</code>函数内部调用<code>_Block_object_dispose</code>函数，它会自动释放掉引用的变量。</li>
</ul>
<p>关于截获对象的实验是在ARC环境下执行的，testBlock是<code>_NSConcreteMallocBlock</code>类型的。如果在非ARC环境下，testBlock是<code>_NSConcreteStackBlock</code>类型的即<strong>Block在栈上，则不会对截获的对象变量进行强引用</strong>。</p>
<h2 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h2><p>当我们需要对被Block截获的局部变量进行赋值操作的话，需要添加一个<code>__block</code>这个说明符，那<code>__block</code>到底有什么作用呢？</p>
<p>先看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    __block int a = 1;</span><br><span class="line">    void (^testBlock)(void) = ^&#123;</span><br><span class="line">        a = 100;</span><br><span class="line">        printf(&quot;%d&quot;, a);</span><br><span class="line">    &#125;;</span><br><span class="line">    testBlock();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用了<code>__block</code>关键字，可以修改变量a的值，所以输出结果是100。</p>
<p>先说明一下为什么不使用<code>__block</code>就不能修改值。执行block就是调用<code>__main_block_func_0</code>函数，<code>a</code>是<code>main</code>函数中的局部变量，我们不可能在一个函数中去修改另一个函数的局部变量。</p>
<p>将上面代码转换成C++代码，先看一下<code>__main_block_impl_0</code>这个结构体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __Block_byref_a_0 &#123;</span><br><span class="line">    void *__isa;</span><br><span class="line">    __Block_byref_a_0 *__forwarding;</span><br><span class="line">    int __flags;</span><br><span class="line">    int __size;</span><br><span class="line">    int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __main_block_desc_0* Desc;</span><br><span class="line">    __Block_byref_a_0 *a; // by ref</span><br><span class="line">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>__main_block_impl_0</code>结构体中多了一个<code>__Block_byref_a_0 *a</code>而不是<code>int a</code>。<code>__Block_byref_a_0</code>也是一个结构体，里面也有一个<code>isa</code>指针，因此我们也可以将它当做一个对象。另外还有一个<code>__Block_byref_a_0 *</code>类型的<code>__forwarding</code>指针和变量<code>a</code>。关于<code>__forwarding</code>指针的作用我们会在后面提到。</p>
<p>接着是主函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">    void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 1&#125;;</span><br><span class="line">    </span><br><span class="line">    void (*testBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344));</span><br><span class="line">    </span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主函数中我们可以看到<code>__block int a = 1;</code>转化成了<code>__Block_byref_a_0</code>的一个结构体，其中<code>__forwarding</code>指针指向这个结构体自己。</p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/%E8%AE%BF%E9%97%AE__block%E5%8F%98%E9%87%8F.jpg" alt="访问__block变量"></p>
<p>最后是Block执行的时候即调用<code>__main_block_func_0</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref</span><br><span class="line">  (a-&gt;__forwarding-&gt;a) = 100;</span><br><span class="line">  printf(&quot;%d&quot;, (a-&gt;__forwarding-&gt;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来的<code>a = 100;</code>则被转换成<code>__Block_byref_a_0 *a = __cself-&gt;a;</code>和<code>(a-&gt;__forwarding-&gt;a) = 100;</code>。这两句代码的意思是先获取结构体中的<code>a</code>，通过<code>a</code>结构体的<code>__forwarding</code>指针指向成员变量<code>a</code>赋值为100。</p>
<p>所以<code>__block</code>的本质就是<strong>__block将变量包装成一个对象，将截获到的值存在这个对象中，通过对截获的值进行赋值而更改原有的值</strong>。</p>
<h2 id="Block存储域"><a href="#Block存储域" class="headerlink" title="Block存储域"></a>Block存储域</h2><p>block有下面三种类型</p>
<table>
<thead>
<tr>
<th>类</th>
<th>设置对象的存储域</th>
</tr>
</thead>
<tbody>
<tr>
<td>_NSConcreteStackBlock</td>
<td>栈 </td>
</tr>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>程序的数据区域 </td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
</tr>
</tbody>
</table>
<p>那么如何确定block的类型？下面这个实验需要在MRC环境下进行测试，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    </span><br><span class="line">    void (^block1)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;%s - %d&quot;, __func__, a);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    void (^block2)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    void (^block3)(void) = [block1 copy];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@ %@ %@&quot;, [block1 class], [block2 class], [block3 class]);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/block%E7%B1%BB%E5%9E%8B.jpg" alt="block类型"></p>
<p>通过打印block的类型可以知道</p>
<table>
<thead>
<tr>
<th>类</th>
<th>环境</th>
</tr>
</thead>
<tbody>
<tr>
<td>_NSConcreteStackBlock</td>
<td>访问了自动变量值</td>
</tr>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>没有访问自动变量值</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>_NSConcreteStackBlock使用了copy</td>
</tr>
</tbody>
</table>
<p>copy操作对不同类型block的影响：</p>
<table>
<thead>
<tr>
<th>Block的类</th>
<th>副本源的配置存储域</th>
<th>复制效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>_NSConcreteStackBlock</td>
<td>栈</td>
<td>从栈复制到堆</td>
</tr>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
<td>引用计数增加</td>
</tr>
</tbody>
</table>
<p>block的copy操作能保证block不容易被销毁。但是在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，即我们打印出来的block是<code>_NSConcreteMallocBlock</code>类型的。</p>
<p>这些情况有：</p>
<ul>
<li>block作为返回值的时候；</li>
<li>block赋值给strong指针的时候；</li>
<li>block作为Cocoa API中方法名含有usingBlock的方法参数的时候；</li>
<li>block作为GCD API的参数的时候；</li>
</ul>
<p>所以如果将上面代码放在ARC环境下执行的话，则<code>block1</code>是<code>__NSMallocBlock__</code>类型的。</p>
<p>release操作会在其内部自动执行。</p>
<h2 id="block变量的存储域"><a href="#block变量的存储域" class="headerlink" title="__block变量的存储域"></a>__block变量的存储域</h2><table>
<thead>
<tr>
<th>__block变量的存储域</th>
<th>Block从栈复制到堆时的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈</td>
<td>从栈复制到堆并被Block持有</td>
</tr>
<tr>
<td>堆</td>
<td>被Block持有</td>
</tr>
</tbody>
</table>
<p>既然<code>__block</code>对应的结构体或者对象是在Block内部使用，那么Block就需要对这个对象的生命周期进行负责。接着我们从源码里面进行理解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">    void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 1&#125;;</span><br><span class="line">    </span><br><span class="line">    void (*testBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344));</span><br><span class="line">    </span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要注意两个函数<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>。</p>
<ul>
<li>当block进行一次copy操作的时候，<code>__main_block_copy_0</code>函数内部调用<code>_Block_object_assign</code>函数，它会对<code>__block</code>变量生成强引用；</li>
<li>当block从堆中移除的时候，<code>__main_block_dispose_0</code>函数内部调用<code>_Block_object_dispose</code>函数，它会自动释放掉引用的<code>__block</code>变量。</li>
</ul>
<p>上面的代码是在ARC环境下的，如果<strong>Block在栈上，并不会对<code>__block</code>变量产生引用</strong>。</p>
<p>这里还要解决一个前面遗留的问题，既然<code>__Block_byref_a_0</code>结构体中已经有变量<code>a</code>，为什么还需要使用<code>__forwarding</code>指针对<code>a</code>赋值呢或者说<code>__forwarding</code>存在的意义是什么？</p>
<p>关于<code>__forwarding</code>的作用《Objective-C高级编程》一书中的第111页、第112页中有很明确的说到：<strong><strong>block变量的结构体成员变量</strong>forwarding可以实现无论<strong>block变量配置在栈上还是堆上都能够正确地访问</strong>block变量。</strong></p>
<p>没有进行copy操作的时候：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/%E6%A0%88%E4%B8%8A%E7%9A%84block.png" alt="栈上的block"><br>进行copy操作以后：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/block%E6%8B%B7%E8%B4%9D.png" alt="block拷贝"></p>
<p>这里分为两种情况：</p>
<ol>
<li><p>如果我们没有对栈上的Block执⾏copy操作，修改被<code>__block</code>修饰的变量实际上是通过其<code>__forwarding</code>指针指向的自身，对其中的变量进行修改。</p>
</li>
<li><p>如果我们执行过copy操作，那么栈上的Block的<code>__forwarding</code>指针，实际是指向堆上的<code>__block</code>修饰的变量，⽽堆上的<code>__forwarding</code>指针则指向⾃自身的<code>__block</code>修饰的变量。在变量作用域结束的时候，栈上的<code>__block</code>变量和Block被废弃掉，但是堆上的<code>__block</code>变量和Block不受影响。</p>
</li>
</ol>
<h2 id="Block的循环引用"><a href="#Block的循环引用" class="headerlink" title="Block的循环引用"></a>Block的循环引用</h2><p>我们在使用Block的时候，如果有一个对象持有了这个Block，而在Block内部又使用了这个对象，就会造成循环引用。如以下写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">typedef void (^TestBlock) (void);</span><br><span class="line"></span><br><span class="line">@interface AObject: NSObject &#123;</span><br><span class="line">    TestBlock testBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AObject</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        testBlock = ^&#123;</span><br><span class="line">            NSLog(@&quot;self = %@&quot;, self);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%@ dealloc&quot;, self.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    AObject *a = [[AObject alloc] init];</span><br><span class="line">    NSLog(@&quot;%@&quot;, a);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，上面这段代码发生了循环引用，导致AObject对象无法被释放。通常做法是使用<code>__weak</code>关键字在Block外部声明一个弱引用。重新修改下<code>init</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        __weak AObject *weakSelf = self;</span><br><span class="line">        testBlock = ^&#123;</span><br><span class="line">            NSLog(@&quot;self = %@&quot;, weakSelf);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面在讲述截获自动变量值的时候，我们知道Block在截获对象类型的时候，会连同对象的所有权修饰符一起截获，这里截获的是<code>__weak</code>修饰的<code>weakSelf</code>,因此不会发生循环引用。</p>
<p>在为避免循环引用而使用<code>__weak</code>修饰符的时候，还要注意有可能在Block执行的时候，对象在中途被释放掉了。这个时候需要在Block内部声明一个局部变量强持有对象，这个局部变量会在到Block执行结束时自动释放，不会造成循环引用，而对象也会在Block执行结束后被释放。</p>
<p>是不是所有的Block都需要在外部声明使用<code>__weak</code>修饰呢？答案是否定的。所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block强引用self）没有问题。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[UIView animateWithDuration:duration</span><br><span class="line">                 animations:^&#123;</span><br><span class="line">                     [self.superview layoutIfNeeded];</span><br><span class="line">                 &#125;];</span><br></pre></td></tr></table></figure>
<p>但如果你使用一些参数中可能含有ivar的系统的api，如<code>NSNotificationCenter</code>就要小心一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__weak __typeof__(self) weakSelf = self;</span><br><span class="line">_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;testKey&quot;</span><br><span class="line">                                                              object:nil</span><br><span class="line">                                                               queue:nil</span><br><span class="line">                                                          usingBlock:^(NSNotification *note) &#123;</span><br><span class="line">   //使用self会循环引用，但是使用weakSelf或者strongSelf则没有问题                                                      </span><br><span class="line">    __typeof__(self) strongSelf = weakSelf;</span><br><span class="line">    [strongSelf dismissModalViewControllerAnimated:YES];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>可以看出<code>self --&gt; _observer --&gt; block --&gt; self</code>这显然是一个循环引用。总而言之，<strong>只有当self直接或间接的持有 Block，并且在Block内部又使用了self的时候，才应该使weakSelf</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>block的本质是一个封装了函数调用以及函数调用环境的OC对象；</li>
<li>block截获自动变量值的规则：<ol>
<li>局部变量会被直接截获；</li>
<li>局部静态变量会被截获其指针；</li>
<li>全局变量并不会被截获，而是直接使用；</li>
</ol>
</li>
<li>block截获对象的规则：<ol>
<li>block位于栈上，则不会对截获的对象变量进行强引用；</li>
<li>block从栈上复制到堆上，调用<code>copy</code>函数，对截获的变量进行强/弱引用；</li>
<li>block从堆上移除，调用<code>dispose</code>函数，自动释放引用的变量；</li>
</ol>
</li>
<li>block使用copy属性的原因：在MRC下，访问了自动变量的block处于栈上，容易被释放，使用copy可以将其复制到堆上，放在堆上便可以自己去控制Block的生命周期；在ARC下，对Block做了优化；</li>
<li>block的循环引用：一个对象持有了这个Block，而在Block内部又使用了这个对象，就会造成循环引用；</li>
<li>__block的作用：解决block内部无法修改自动变量值的问题；</li>
<li>__block的注意点：不能修饰全局变量和静态变量；</li>
<li><strong>block的实质：编译器将</strong>block变量包装成一个对象，将截获到的值存在这个对象中，通过对截获的值进行赋值而更改原有的值；</li>
<li><strong>forwarding指针的作用：可以实现无论</strong>block变量配置在栈上还是堆上都能够正确地访问__block变量；</li>
</ol>
<h2 id="Sunnyxx的Block面试题"><a href="#Sunnyxx的Block面试题" class="headerlink" title="Sunnyxx的Block面试题"></a>Sunnyxx的Block面试题</h2><p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/sunnyxx_block.png" alt="sunnyxx_block"></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;fishhook.h&quot;</span><br><span class="line"></span><br><span class="line">// Block定义</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __main_block_desc_0 *Desc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#pragma mark - 第一题</span><br><span class="line"></span><br><span class="line">static void test_1__main_block_func_0(struct __main_block_impl_0 *__cself)&#123;</span><br><span class="line">    NSLog(@&quot;Hello,world!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HookBlockToPrintHelloWorld(id block)&#123;</span><br><span class="line">    //    struct __block_impl *tmp = (__bridge struct __block_impl *)block;</span><br><span class="line">    //    tmp-&gt;FuncPtr = &amp;test_1__main_block_func_0;</span><br><span class="line">    // 或者</span><br><span class="line">    struct __main_block_impl_0 *tmp2 = (__bridge struct  __main_block_impl_0 *)block;</span><br><span class="line">    ((struct __block_impl *)tmp2)-&gt;FuncPtr = &amp;test_1__main_block_func_0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 第二题</span><br><span class="line"></span><br><span class="line">static void (*original_func)(struct __main_block_impl_0 *, int, NSString *);</span><br><span class="line"></span><br><span class="line">static void test_2__main_block_func_0(struct __main_block_impl_0 *__cself, int a, NSString *b) &#123;</span><br><span class="line">    NSLog(@&quot;%d %@&quot;, a, b);</span><br><span class="line">    original_func(__cself, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HookBlockToPrintArguments(id block) &#123;</span><br><span class="line">    struct __block_impl *tmp = (__bridge struct __block_impl *)block;</span><br><span class="line">    original_func = tmp-&gt;FuncPtr;</span><br><span class="line">    tmp-&gt;FuncPtr = &amp;test_2__main_block_func_0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 第三题</span><br><span class="line"></span><br><span class="line">static id (*original__Block_copy)(id);</span><br><span class="line"></span><br><span class="line">id new__Block_copy(id block) &#123;</span><br><span class="line">    id tmp = original__Block_copy(block);</span><br><span class="line">    HookBlockToPrintArguments(tmp);</span><br><span class="line">    </span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HookEveryBlockToPrintArguments() &#123;</span><br><span class="line">    struct rebinding open_rebinding = &#123;</span><br><span class="line">        &quot;_Block_copy&quot;,</span><br><span class="line">        new__Block_copy,</span><br><span class="line">        (void *)&amp;original__Block_copy</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    rebind_symbols((struct rebinding[1])&#123;open_rebinding&#125;, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    // 第一题</span><br><span class="line">    void(^block1)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    HookBlockToPrintHelloWorld(block1);</span><br><span class="line">    </span><br><span class="line">    block1();</span><br><span class="line">    </span><br><span class="line">    // 第二题</span><br><span class="line">    void (^block2)(int a, NSString *b) = ^(int a, NSString *b) &#123;</span><br><span class="line">        NSLog(@&quot;block invoke&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    HookBlockToPrintArguments(block2);</span><br><span class="line">    </span><br><span class="line">    block2(123, @&quot;aaa&quot;);</span><br><span class="line">    </span><br><span class="line">    // 第三题</span><br><span class="line">    HookEveryBlockToPrintArguments();</span><br><span class="line">    </span><br><span class="line">    void (^block3)(int a, NSString *b) = ^(int a, NSString *b) &#123;</span><br><span class="line">        NSLog(@&quot;block3 invoke&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    block3(1, @&quot;dsadas&quot;);</span><br><span class="line">    </span><br><span class="line">    void (^block4)(int a, NSString *b) = ^(int a, NSString *b) &#123;</span><br><span class="line">        NSLog(@&quot;block4 invoke&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    block4(222, @&quot;ddd&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一题分析</strong></p>
<p>想要替换原有的block实现，我们需要知道Block是如何执行代码的。通过上面的原理分析，我们知道在执行block的代码就相当于调用<code>__main_block_func_0</code>函数。该函数指针被保存在<code>__block_impl</code>结构体的<code>FuncPtr</code>中。我们知道将<code>FuncPtr</code>指向我们自己的函数就可以完成切换。</p>
<p><strong>第二题分析</strong></p>
<p>知道第一题如何解答之后，第二题相对来说简单一点，其实就是在我们自定义函数的时候，这个函数需要包括我们传入的参数，以及原有实现。</p>
<p>那么通过一个函数指针可以保存原有实现，在自定义函数中通过函数指针调用原有函数即可，而参数是本身<code>__main_block_func_0</code>函数就有的，我们只要确保我们自定义函数的参数列表与<code>__main_block_func_0</code>函数的参数列表一致就行。</p>
<p><strong>第三题分析</strong></p>
<p>这道题目说白了就是在一个适当的时机去调用<code>HookBlockToPrintArguments</code>。通过fishhook这个框架，我们可以动态的修改C语言函数。那如何确定这个C语言函数呢？这个函数需要有这么一个功能，它可以拿到原来的block对象，经过替换再重新返回。</p>
<p>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，它会调用一个<code>copy</code>函数即<code>_Block_copy</code>，所以我们需要动态修改这个函数。</p>
]]></content>
      <categories>
        <category>OC对象内存</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>KVC实现原理</title>
    <url>/2019/07/12/KVC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><code>KVC</code>全称是<code>Key Value Coding</code>，定义在<code>NSKeyValueCoding.h</code>文件中。<code>KVC</code>提供了一种间接访问其属性方法或成员变量的机制，可以通过字符串来访问对应的属性方法或成员变量。关于KVC的实现主要依赖于其搜索规则。</p>
<h2 id="搜索规则"><a href="#搜索规则" class="headerlink" title="搜索规则"></a>搜索规则</h2><p>在赋值过程中，我们会使用<code>- (void)setValue:(id)value forKey:(NSString *)key</code>或者<code>(void)setValue:(id)value forKeyPath:(NSString *)keyPath;</code>进行KVC的赋值操作。在取值过程中，我们会使用<code>- (id)valueForKey:(NSString *)key;</code>或者<code>- (id)valueForKeyPath:(NSString *)keyPath;</code>。</p>
<p>KVC在通过<code>key</code>或者<code>keyPath</code>进行操作的时候，可以查找属性方法、成员变量等，查找的时候可以兼容多种命名。具体的查找规则在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="noopener">KVC官方文档</a>中可以找到。</p>
<p>KVC的实现主要依赖于<code>setter</code>和<code>getter</code>方法，所以关于命名需要符合苹果的规范。另外在搜索过程中<code>accessInstanceVariablesDirectly</code>这个只读属性也起着重要的作用。这个属性表示是否允许读取实例变量的值，如果为YES则在KVC查找的过程中，从内存中读取属性实例变量的值，默认为YES。</p>
<h3 id="赋值原理"><a href="#赋值原理" class="headerlink" title="赋值原理"></a>赋值原理</h3><p>以<code>setValue:forKey:</code>为例，其内部实现主要有以下步骤：</p>
<ol>
<li><p>以<code>set&lt;Key&gt;:</code>、<code>_set&lt;Key&gt;</code>的顺序查找对应命名的<code>setter</code>方法，如果找到的话，调用这个方法并将值传进去(根据需要进行对象转换)；</p>
</li>
<li><p>如果没有发现<code>setter</code>方法，但是<code>accessInstanceVariablesDirectly</code>类属性返回YES，则按<code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>的顺序查找一个对应的实例变量。如果发现则将value赋值给实例变量；</p>
</li>
<li><p>如果没有发现<code>setter</code>方法或实例变量，则调用<code>setValue:forUndefinedKey:</code>方法，默认抛出一个异常，但是一个NSObject的子类可以提出合适的行为。</p>
</li>
</ol>
<p>接着我们用代码进行相关的测试：</p>
<p><strong>实验1：验证setter方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// model1</span><br><span class="line">@interface KVCTestModel1 : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KVCTestModel1</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)_setName:(NSString *)name &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// model2</span><br><span class="line">@interface KVCTestModel2 : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KVCTestModel2</span><br><span class="line"></span><br><span class="line">- (void)_setName:(NSString *)name &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// model3</span><br><span class="line">@interface KVCTestModel3 : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KVCTestModel3</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">- (void)_testKVC &#123;</span><br><span class="line">    KVCTestModel1 *model1 = [[KVCTestModel1 alloc] init];</span><br><span class="line">    [model1 setValue:@&quot;Nero&quot; forKey:@&quot;name&quot;];</span><br><span class="line">    </span><br><span class="line">    KVCTestModel2 *model2 = [[KVCTestModel2 alloc] init];</span><br><span class="line">    [model2 setValue:@&quot;Nero&quot; forKey:@&quot;name&quot;];</span><br><span class="line">    </span><br><span class="line">    KVCTestModel3 *model3 = [[KVCTestModel3 alloc] init];</span><br><span class="line">    [model3 setValue:@&quot;Nero&quot; forKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/kvc_setter1.jpg" alt="kvc_setter1"></p>
<p><strong>实验2：验证实例变量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// model1</span><br><span class="line">@interface KVCTestModel1 : NSObject &#123;</span><br><span class="line">    NSString *_name;</span><br><span class="line">    NSString *_isName;</span><br><span class="line">    NSString *name;</span><br><span class="line">    NSString *isName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// model2</span><br><span class="line">@interface KVCTestModel2 : NSObject &#123;</span><br><span class="line">    NSString *_isName;</span><br><span class="line">    NSString *name;</span><br><span class="line">    NSString *isName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// model3</span><br><span class="line">@interface KVCTestModel3 : NSObject &#123;</span><br><span class="line">    NSString *name;</span><br><span class="line">    NSString *isName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// model4</span><br><span class="line">@interface KVCTestModel4 : NSObject &#123;</span><br><span class="line">    NSString *isName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">- (void)_testKVC &#123;</span><br><span class="line">    self.kvcTestModel1 = [[KVCTestModel1 alloc] init];</span><br><span class="line">    [self.kvcTestModel1 setValue:@&quot;Nero&quot; forKey:@&quot;name&quot;];</span><br><span class="line">    </span><br><span class="line">    self.kvcTestModel2 = [[KVCTestModel2 alloc] init];</span><br><span class="line">    [self.kvcTestModel2 setValue:@&quot;Nero&quot; forKey:@&quot;name&quot;];</span><br><span class="line"></span><br><span class="line">    self.kvcTestModel3 = [[KVCTestModel3 alloc] init];</span><br><span class="line">    [self.kvcTestModel3 setValue:@&quot;Nero&quot; forKey:@&quot;name&quot;];</span><br><span class="line"></span><br><span class="line">    self.kvcTestModel4 = [[KVCTestModel4 alloc] init];</span><br><span class="line">    [self.kvcTestModel4 setValue:@&quot;Nero&quot; forKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/kvc_setter2.jpg" alt="kvc_setter2"></p>
<p>另外如果设置<code>accessInstanceVariablesDirectly</code>返回为NO，即使有符合命名规范的实例变量名，KVC也无法赋值成功；<code>setValue:forUndefinedKey:</code>默认会抛出一个异常，你可以用重写这个方法用来拦截。</p>
<p>赋值原理流程图如下：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/kvc_setter_process.jpg" alt="kvc_setter_process.jpg"></p>
<h3 id="取值原理"><a href="#取值原理" class="headerlink" title="取值原理"></a>取值原理</h3><p>以<code>valueForKey:</code>为例，其内部实现主要有以下几步：</p>
<ol>
<li><p>通过<code>getter</code>方法搜索实例，以<code>get&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code>, <code>_&lt;key&gt;</code>的顺序搜索符合规则的方法，如果有，就调用对应的方法；</p>
</li>
<li><p>如果没有发现简单<code>getter方法</code>，并且在类方法<code>accessInstanceVariablesDirectly</code>是返回YES的的情况下搜索一个名为<code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>的实例；</p>
</li>
<li><p>如果返回值是一个对象指针，则直接返回这个结果；如果返回值是一个基础数据类型，但是这个基础数据类型是被<code>NSNumber</code>支持的，则存储为<code>NSNumber</code>并返回；如果返回值是一个不支持<code>NSNumber</code>的基础数据类型，则通过<code>NSValue</code>进行存储并返回；</p>
</li>
<li><p>在上述情况都失败的情况下调用<code>valueForUndefinedKey:</code>方法，默认抛出异常，但是子类可以重写此方法。</p>
</li>
</ol>
<p>由于和前面的赋值原理实验相似，这里就不添加相关的验证代码了。另外<code>valueForKey:</code>返回的结果还可能是数组或者其他集合类型，所以在上面第1步和第2步之间还有一些其他的规则，这些规则用来判断是否是数组或者其他集合类型的规则，但是我觉得忽略这些规则跟整体流程理解冲突不大，所以就忽略掉了（具体的在官在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="noopener">KVC官方文档</a>中可以找到。）。</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p><strong>面试题分析: KVC能否能够触发KVO</strong></p>
<p>答案是肯定的。</p>
<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface KVCTestModel1 : NSObject &#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString *_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KVCTestModel1</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 测试代码</span><br><span class="line">KVCTestModel1 *model1 = [[KVCTestModel1 alloc] init];</span><br><span class="line">[model1 addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line"></span><br><span class="line">// 直接修改成员变量</span><br><span class="line">model1 -&gt; _name = @&quot;Nero1&quot;;</span><br><span class="line">NSLog(@&quot;%@&quot;, [model1 valueForKey:@&quot;name&quot;]);</span><br><span class="line"></span><br><span class="line">// 手动触发KVO</span><br><span class="line">[model1 willChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">model1 -&gt; _name = @&quot;Nero2&quot;;</span><br><span class="line">[model1 didChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;, [model1 valueForKey:@&quot;name&quot;]);</span><br><span class="line"></span><br><span class="line">// KVC赋值</span><br><span class="line">[model1 setValue:@&quot;Nero3&quot; forKeyPath:@&quot;name&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;, [model1 valueForKey:@&quot;name&quot;]);</span><br><span class="line"></span><br><span class="line">[model1 removeObserver:self forKeyPath:@&quot;name&quot;];</span><br></pre></td></tr></table></figure>
<p>打印结果：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/KVC%26KVO.jpg" alt></p>
<p>通过上面的代码我们可以认为，在以KVC的方式对变量进行赋值的时候，会判断该对象是否使用了KVO，如果是，则会触发KVO。</p>
]]></content>
      <categories>
        <category>KVO&amp;KVC</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO实现原理</title>
    <url>/2019/07/12/KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>在iOS开发中，我们可以通过KVO机制来监听某个对象的某个属性的变化。</p>
<h2 id="KVO实现步骤"><a href="#KVO实现步骤" class="headerlink" title="KVO实现步骤"></a>KVO实现步骤</h2><p>KVO的实现分为三步：</p>
<ol>
<li><p><code>- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</code></p>
</li>
<li><p><code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context;</code></p>
</li>
<li><p><code>- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</code></p>
</li>
</ol>
<h2 id="KVO实现机制"><a href="#KVO实现机制" class="headerlink" title="KVO实现机制"></a>KVO实现机制</h2><p>KVO的实现依赖于RunTime，在Apple的文档中有提到过KVO的实现：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>
</blockquote>
<blockquote>
<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>
</blockquote>
<blockquote>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
</blockquote>
<blockquote>
<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
</blockquote>
<p>Apple的文档提到KVO是使用了<code>isa-swizzling</code>的技术。当观察者注册对象的属性时，观察对象的<code>isa</code>指针被修改，指向中间类而不是真正的类。因此，<code>isa</code>指针的值不一定反映实例的实际类。另外还提到我们不应该依赖<code>isa</code>指针来确定类成员资格，而是使用类方法来确定对象实例的类。</p>
<h3 id="isa-swizzling"><a href="#isa-swizzling" class="headerlink" title="isa-swizzling"></a>isa-swizzling</h3><p>先用一段代码验证一下KVO的实现是不是进行了<code>isa-swizzling</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface KVOTestModel : NSObject</span><br><span class="line">    </span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (void)printInfo;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KVOTestModel</span><br><span class="line"></span><br><span class="line">- (void)printInfo &#123;</span><br><span class="line">    NSLog(@&quot;isa:%@, supper class:%@&quot;, NSStringFromClass(object_getClass(self)), class_getSuperclass(object_getClass(self)));</span><br><span class="line">    NSLog(@&quot;self:%@, [self superclass]:%@&quot;, self, [self superclass]);</span><br><span class="line">    NSLog(@&quot;name setter function pointer:%p&quot;, class_getMethodImplementation(object_getClass(self), @selector(setName:)));</span><br><span class="line">    NSLog(@&quot;printInfo function pointer:%p&quot;, class_getMethodImplementation(object_getClass(self), @selector(printInfo)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在<code>ViewController</code>中使用KVO监听<code>KVOTestMod</code>对象的相关属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma mark - Lifceycle</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.kvoTestModel = [[KVOTestModel alloc] init];</span><br><span class="line">    NSLog(@&quot;Before KVO ---------------------------------------&quot;);</span><br><span class="line">    [self.kvoTestModel printInfo];</span><br><span class="line">    [self.kvoTestModel addObserver:self</span><br><span class="line">                        forKeyPath:@&quot;name&quot;</span><br><span class="line">                           options:NSKeyValueObservingOptionNew</span><br><span class="line">                           context:nil];</span><br><span class="line">    NSLog(@&quot;After KVO ---------------------------------------&quot;);</span><br><span class="line">    [self.kvoTestModel printInfo];</span><br><span class="line">    [self.kvoTestModel removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line">    NSLog(@&quot;Remove KVO ---------------------------------------&quot;);</span><br><span class="line">    [self.kvoTestModel printInfo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - KVO</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(id)object</span><br><span class="line">                        change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change</span><br><span class="line">                       context:(void *)context &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印一下结果：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/kvo_isa_swizzling.jpg" alt="isa-swizzling"></p>
<p>添加KVO之后，<code>isa</code>已经替换成了<code>NSKVONotifying_Person</code>,而根据<code>class_getSuperclass</code>得到的结果竟然是<code>Person</code>, 然后<code>name</code>是使我们KVO需要观察的属性，它的<code>setter</code>函数指针变了。</p>
<p>这里先直接总结KVO的实现原理：</p>
<ul>
<li><p>add observer</p>
<ol>
<li>通过runtime生成一个以<code>NSKVONotifying_</code>+<code>类名</code>的形式来命名的派生类；</li>
<li>将被观察的对象的<code>isa</code>指针指向这个派生类；</li>
<li>重写派生类的<code>setter</code>方法，重写<code>setter</code>方法的本质是在赋值语句之前调用<code>willChangeValueForKey</code>，赋值之后调用<code>didChangeValueForKey</code>，在<code>didChangeValueForKey</code>中调用<code>observeValueForKeyPath:ofObject:change:context:</code>方法。</li>
</ol>
</li>
<li><p>remove observer</p>
<p>  将其的<code>isa</code>指针指向原来的类对象中</p>
</li>
</ul>
<h3 id="KVO派生类"><a href="#KVO派生类" class="headerlink" title="KVO派生类"></a>KVO派生类</h3><p>在使用了KVO添加了观察者以后，runtime会生成一个<code>NSKVONotifying_</code>开头的派生类，那这个类做了些什么呢？验证代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// KVOTestModel类</span><br><span class="line"></span><br><span class="line">@interface KVOTestModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KVOTestModel</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 打印类的方法列表</span><br><span class="line">void printClassMethod(Class aClass) &#123;</span><br><span class="line">    unsigned int count;</span><br><span class="line">    Method *methodList = class_copyMethodList(aClass, &amp;count);</span><br><span class="line">    NSMutableString *methodNames = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        Method aMethod =methodList[i];</span><br><span class="line">        NSString *aMethodString = NSStringFromSelector(method_getName(aMethod));</span><br><span class="line">        [methodNames appendString:[NSString stringWithFormat:@&quot;%@, &quot;, aMethodString]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(methodList);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;, methodNames);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用代码</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.kvoTestModel = [[KVOTestModel alloc] init];</span><br><span class="line">    self.kvoTestModel2 = [[KVOTestModel alloc] init];</span><br><span class="line">    </span><br><span class="line">    [self.kvoTestModel addObserver:self</span><br><span class="line">                        forKeyPath:@&quot;name&quot;</span><br><span class="line">                           options:NSKeyValueObservingOptionNew</span><br><span class="line">                           context:nil];</span><br><span class="line">    </span><br><span class="line">    printClassMethod(object_getClass(self.kvoTestModel));</span><br><span class="line">    printClassMethod(object_getClass(self.kvoTestModel2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/kvo%E6%B4%BE%E7%94%9F%E7%B1%BB.jpg" alt="kvo派生类"></p>
<p>从上面的结果可以得出，派生类重写了四个方法分别是：</p>
<ol>
<li>重写Setter方法；</li>
<li>重写Class方法，苹果官方并不想让我们知道KVO的具体实现，所以重写了Class方法以返回其原来的类，这也证实了使用了KVO的实例对象为什么调用<code>class</code>方法和<code>object_getClass</code>方法但是结果不一样；</li>
<li>实现了dealloc方法，用来实现KVO的一些收尾工作；</li>
<li>实现了_isKVOA方法，应该是KVO内部的一个私有方法；</li>
</ol>
<h3 id="重写Setter方法"><a href="#重写Setter方法" class="headerlink" title="重写Setter方法"></a>重写Setter方法</h3><p>上面提到必须是派生类重写<code>setter</code>方法，如果是直接对属性进行赋值的话，是不会触发KVO的。虽然Apple并没有开源KVO的代码，但是我们可以通过验证的方式进行推导。</p>
<p>在<code>KVOTestModel</code>文件中添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma mark - Override</span><br><span class="line"></span><br><span class="line">- (void)willChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;willChangeValueForKey beigin&quot;);</span><br><span class="line">    </span><br><span class="line">    [super willChangeValueForKey:key];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;willChangeValueForKey end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;didChangeValueForKey beigin&quot;);</span><br><span class="line">    </span><br><span class="line">    [super didChangeValueForKey:key];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;didChangeValueForKey end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Setter</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    _name = name;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/kvo_setter.jpg" alt="setter"></p>
<p>从上面的结果我们可以知道KVO在重写<code>setter</code>方法后大概分成三个步骤：</p>
<ol>
<li>先调用<code>willChangeValueForKey</code>；</li>
<li>调用父类的<code>setter</code>方法；</li>
<li>调用<code>didChangeValueForKey</code>，<code>didChangeValueForKey</code>中会调用KVO的相关代理方法来通知观察者。</li>
</ol>
<h3 id="keyPath"><a href="#keyPath" class="headerlink" title="keyPath"></a>keyPath</h3><p>keyPath使用我们用来监听的属性，它的实质是什么？先看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Person.h</span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *nick;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Person.m</span><br><span class="line">@synthesize nick = realNick;</span><br><span class="line"></span><br><span class="line">- (void)setNick:(NSString *)nick &#123;</span><br><span class="line">    realNick = nick;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)nick &#123;</span><br><span class="line">    return realNick;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ViewController</span><br><span class="line">- (void)_testKeyPath &#123;</span><br><span class="line">    self.person = [[Person alloc] init];</span><br><span class="line">    [self.person addObserver:self</span><br><span class="line">                  forKeyPath:@&quot;nick&quot;//&quot;realNick&quot;</span><br><span class="line">                     options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld</span><br><span class="line">                     context:nil];</span><br><span class="line">    self.person.nick = @&quot;Nero&quot;;</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;nick&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际结果是，使用<code>nick</code>能够监听到对应变化，而使用真正的实例变量<code>realNick</code>时，无法监听到值。<code>keyPath</code>指向的并不是真正的实例变量，而是对于<code>setter</code>方法的关联，KVO会使用<code>keypath</code>作为后缀去寻找原类的<code>setter</code>方法的方法签名，和实际存取对象和属性名称没有关系。所以这也是为什么我们重命名了<code>setter</code>方法之后，没有办法再去使用KVO或KVC了，需要手动调用一次<code>willChangeValue</code>方法。</p>
<h2 id="手动触发一个KVO"><a href="#手动触发一个KVO" class="headerlink" title="手动触发一个KVO"></a>手动触发一个KVO</h2><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Person</span><br><span class="line">@interface Person : NSObject &#123;</span><br><span class="line">@public NSInteger age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//ViewController</span><br><span class="line">- (void)_testImplementKVOManually &#123;</span><br><span class="line">    self.person = [[Person alloc] init];</span><br><span class="line">    [self.person addObserver:self</span><br><span class="line">                  forKeyPath:@&quot;age&quot;</span><br><span class="line">                     options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld</span><br><span class="line">                     context:nil];</span><br><span class="line">    [self.person willChangeValueForKey:@&quot;age&quot;];//获取旧值</span><br><span class="line">    self.person-&gt;age = 26;</span><br><span class="line">    [self.person didChangeValueForKey:@&quot;age&quot;];//获取新值</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KVO的跨线程监听"><a href="#KVO的跨线程监听" class="headerlink" title="KVO的跨线程监听"></a>KVO的跨线程监听</h2><p>我们知道使用Notification时，跨线程发送通知是无法被接受到的，但是KVO是可以跨线程监听的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)_testKVOinGCD &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;test.concurrent.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    self.person = [Person new];</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, [NSDate date]);</span><br><span class="line">        self.person.name = @&quot;Nero&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, [NSDate date]);</span><br><span class="line">        sleep(1);</span><br><span class="line">        [self.person addObserver:self</span><br><span class="line">                      forKeyPath:@&quot;name&quot;</span><br><span class="line">                         options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld</span><br><span class="line">                         context:nil];</span><br><span class="line">        NSLog(@&quot;%@&quot;, [NSDate date]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, [NSDate date]);</span><br><span class="line">        self.person.name = @&quot;NeroXie&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在两个不同的线程里创建的Observer和Target，观察变化也是能够生效的。<br>这里使用了<code>dispatch_barrier_async</code>是确保第三个task在前两个task运行后再执行，而且使用的队列必须是自定义的并发队列，如果使用全局队列，栅栏就不想起作用了，因为<code>dispatch_barrier_async</code>相当于<code>dispatch_asysc</code></p>
<h2 id="KVO拾遗"><a href="#KVO拾遗" class="headerlink" title="KVO拾遗"></a>KVO拾遗</h2><ul>
<li>子类继承父类的一个属性(无论是否被暴露)，当这个属性被改变时，KVO都能观察到。</li>
</ul>
<p>因为继承的关系Father &lt;- Son &lt;- KVOSon，当我监听一个父类属性的keyPath的时候，Son实例同样可以通过消息查找找到父类的setter方法，再将该方法加入到KVOSon类当中去。</p>
<ul>
<li>子类继承父类属性并重写了它的setter方法，当这个属性被改变时，KVO能观察到。</li>
</ul>
<p>在上一条中知道，其实子类监听父类属性，并不依赖继承，而是通过ISA指针在消息转发的时候能够获取到父类方法就足够。所以当我们重写父类setter方法，相当于在子类定义了该setter函数，在我们去用sel找方法签名时，直接在子类中就拿到了，甚至都不需要去到父类里。所以理解了KVO监听父类属性和继承没有直接联系这一点，就不再纠结set方法是否重写这个问题了。</p>
<h2 id="补充：以Block的形式实现KVO"><a href="#补充：以Block的形式实现KVO" class="headerlink" title="补充：以Block的形式实现KVO"></a>补充：以Block的形式实现KVO</h2><p>通过上面的API我们知道KVO的调用相对来说是有点繁琐的，所以我用Category实现了KVO的Block形式的调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 声明</span><br><span class="line">@interface NSObject(KVOBlock)</span><br><span class="line"></span><br><span class="line">- (NSString *)nn_addObserverForKeyPath:(NSString *)keyPath</span><br><span class="line">                               options:(NSKeyValueObservingOptions)options</span><br><span class="line">                            usingBlock:(void (^)(id obj, NSString *keyPath, NSDictionary *change))block;</span><br><span class="line"></span><br><span class="line">- (void)nn_removeBlockObserverWithIdentifier:(NSString *)identifier;</span><br><span class="line">- (void)nn_removeAllBlockObservers;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 实现</span><br><span class="line">#pragma mark - NSObject+KVOBlock</span><br><span class="line"></span><br><span class="line">static void *NNObserverBlockContext = &amp;NNObserverBlockContext;</span><br><span class="line"></span><br><span class="line">typedef void (^NNObserverBlock) (id obj, NSString *keyPath, NSDictionary&lt;NSKeyValueChangeKey,id&gt; *change);</span><br><span class="line"></span><br><span class="line">#pragma mark - Private Class</span><br><span class="line"></span><br><span class="line">@interface _NNInternalObserver : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) BOOL isObserving;</span><br><span class="line">@property (nonatomic, weak) id observed;</span><br><span class="line">@property (nonatomic, copy) NSString *keyPath;</span><br><span class="line">@property (nonatomic, copy) NNObserverBlock observerBlock;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation _NNInternalObserver</span><br><span class="line"></span><br><span class="line">#pragma mark - Init</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithObserved:(id)observed</span><br><span class="line">                         keyPath:(NSString *)keyPath</span><br><span class="line">                   observerBlock:(NNObserverBlock)observerBlock &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        self.isObserving = NO;</span><br><span class="line">        self.observed = observed;</span><br><span class="line">        self.keyPath = keyPath;</span><br><span class="line">        self.observerBlock = [observerBlock copy];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    if (self.keyPath) [self stopObserving];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Helper</span><br><span class="line"></span><br><span class="line">- (void)startObservingWithOptions:(NSKeyValueObservingOptions)options &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        if (self.isObserving) return;</span><br><span class="line">        </span><br><span class="line">        [self.observed addObserver:self forKeyPath:self.keyPath options:options context:NNObserverBlockContext];</span><br><span class="line">        </span><br><span class="line">        self.isObserving = YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopObserving &#123;</span><br><span class="line">    NSParameterAssert(self.keyPath);</span><br><span class="line">    </span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (!self.isObserving) return;</span><br><span class="line">        if (!self.observed) return;</span><br><span class="line">        </span><br><span class="line">        [self.observed removeObserver:self forKeyPath:self.keyPath context:NNObserverBlockContext];</span><br><span class="line">        </span><br><span class="line">        self.observed = nil;</span><br><span class="line">        self.keyPath = nil;</span><br><span class="line">        self.observerBlock = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - KVO</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if (context != NNObserverBlockContext) return;</span><br><span class="line">    </span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        self.observerBlock(object, keyPath, change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface NSObject()</span><br><span class="line"></span><br><span class="line">/** 保存所有的block */</span><br><span class="line">@property (nonatomic, strong, setter=nn_setObserverBlockMap:) NSMutableDictionary *nn_observerBlockMap;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSObject(KVOBlock)</span><br><span class="line"></span><br><span class="line">/** 所有修改过dealloc方法的类 */</span><br><span class="line">+ (NSMutableSet *)nn_observedClasses &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    static NSMutableSet *classes = nil;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        classes = [[NSMutableSet alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return classes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Public</span><br><span class="line"></span><br><span class="line">- (NSString *)nn_addObserverForKeyPath:(NSString *)keyPath</span><br><span class="line">                               options:(NSKeyValueObservingOptions)options</span><br><span class="line">                                  usingBlock:(void (^)(id obj, NSString *keyPath, NSDictionary *change))block &#123;</span><br><span class="line">    NSString *identifier = [NSProcessInfo processInfo].globallyUniqueString;</span><br><span class="line">    [self nn_addObserverForKeyPath:keyPath identifier:identifier options:options block:block];</span><br><span class="line">    </span><br><span class="line">    return identifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)nn_removeBlockObserverWithIdentifier:(NSString *)identifier &#123;</span><br><span class="line">    NSParameterAssert(identifier.length);</span><br><span class="line">    </span><br><span class="line">    NSMutableDictionary *dict;</span><br><span class="line">    </span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        dict = self.nn_observerBlockMap;</span><br><span class="line">        if (!dict) return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _NNInternalObserver *observer = dict[identifier];</span><br><span class="line">    [observer stopObserving];</span><br><span class="line">    [dict removeObjectForKey:identifier];</span><br><span class="line">    if (dict.count == 0) self.nn_observerBlockMap = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)nn_removeAllBlockObservers &#123;</span><br><span class="line">    NSDictionary *dict;</span><br><span class="line">    </span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        dict = [self.nn_observerBlockMap copy];</span><br><span class="line">        self.nn_observerBlockMap = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [dict.allValues enumerateObjectsUsingBlock:^(_NNInternalObserver *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        [obj stopObserving];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Core Method</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> KVO Block 实现</span><br><span class="line"> </span><br><span class="line"> @param keyPath     被观察的属性</span><br><span class="line"> @param identifier  唯一标识符 用来标记内部观察者</span><br><span class="line"> @param options     观察选项</span><br><span class="line"> @param block       KVO Block</span><br><span class="line"> */</span><br><span class="line">- (void)nn_addObserverForKeyPath:(NSString *)keyPath</span><br><span class="line">                      identifier:(NSString *)identifier</span><br><span class="line">                         options:(NSKeyValueObservingOptions)options</span><br><span class="line">                            block:(NNObserverBlock)block &#123;</span><br><span class="line">    NSParameterAssert(keyPath.length);</span><br><span class="line">    NSParameterAssert(identifier.length);</span><br><span class="line">    NSParameterAssert(block);</span><br><span class="line">    </span><br><span class="line">    Class classToSwizzle = self.class;</span><br><span class="line">    NSMutableSet *classes = self.class.nn_observedClasses;</span><br><span class="line">    @synchronized (classes) &#123;</span><br><span class="line">        NSString *className = NSStringFromClass(classToSwizzle);</span><br><span class="line">        if (![classes containsObject:className]) &#123;</span><br><span class="line">            SEL deallocSelector = sel_registerName(&quot;dealloc&quot;);</span><br><span class="line">            </span><br><span class="line">            __block void (*originalDealloc)(__unsafe_unretained id, SEL) = NULL;</span><br><span class="line">            </span><br><span class="line">            id newDealloc = ^(__unsafe_unretained id objSelf) &#123;</span><br><span class="line">                [objSelf nn_removeAllBlockObservers];</span><br><span class="line">                </span><br><span class="line">                if (originalDealloc == NULL) &#123;</span><br><span class="line">                    struct objc_super superInfo = &#123;</span><br><span class="line">                        .receiver = objSelf,</span><br><span class="line">                        .super_class = class_getSuperclass(classToSwizzle)</span><br><span class="line">                    &#125;;</span><br><span class="line">                    </span><br><span class="line">                    void (*msgSend)(struct objc_super *, SEL) = (__typeof__(msgSend))objc_msgSendSuper;</span><br><span class="line">                    msgSend(&amp;superInfo, deallocSelector);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    originalDealloc(objSelf, deallocSelector);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            IMP newDeallocIMP = imp_implementationWithBlock(newDealloc);</span><br><span class="line">            </span><br><span class="line">            if (!class_addMethod(classToSwizzle, deallocSelector, newDeallocIMP, &quot;v@:&quot;)) &#123;</span><br><span class="line">                Method deallocMethod = class_getInstanceMethod(classToSwizzle, deallocSelector);</span><br><span class="line">                originalDealloc = (void(*)(__unsafe_unretained id, SEL))method_getImplementation(deallocMethod);</span><br><span class="line">                originalDealloc = (void(*)(__unsafe_unretained id, SEL))method_setImplementation(deallocMethod, newDeallocIMP);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            [classes addObject:className];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _NNInternalObserver *observer = [[_NNInternalObserver alloc] initWithObserved:self</span><br><span class="line">                                                                          keyPath:keyPath</span><br><span class="line">                                                                    observerBlock:block];</span><br><span class="line">    [observer startObservingWithOptions:options];</span><br><span class="line">    </span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (!self.nn_observerBlockMap) self.nn_observerBlockMap = [NSMutableDictionary dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self.nn_observerBlockMap[identifier] = observer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Setter &amp; Getter</span><br><span class="line"></span><br><span class="line">- (void)nn_setObserverBlockMap:(NSMutableDictionary *)nn_observerBlockMap &#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(nn_observerBlockMap), nn_observerBlockMap, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMutableDictionary *)nn_observerBlockMap &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, @selector(nn_observerBlockMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">self.kvoTestModel = [[KVOTestModel alloc] init];</span><br><span class="line"></span><br><span class="line">NSString *identifier =</span><br><span class="line">[self.kvoTestModel nn_addObserverForKeyPath:@&quot;name&quot;</span><br><span class="line">                                    options:NSKeyValueObservingOptionNew</span><br><span class="line">                                 usingBlock:^(id obj, NSString *keyPath, NSDictionary *change) &#123;</span><br><span class="line">                                     NSLog(@&quot;%@&quot;, change);</span><br><span class="line">                                 &#125;];</span><br><span class="line"></span><br><span class="line">self.kvoTestModel.name = @&quot;Nero&quot;;</span><br><span class="line"></span><br><span class="line">// 手动结束KVO监听</span><br><span class="line">[self.kvoTestModel nn_removeBlockObserverWithIdentifier:identifier];</span><br><span class="line">    </span><br><span class="line">// 自动结束KVO监听</span><br><span class="line">self.kvoTestModel = nil;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>KVO&amp;KVC</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>ModuleManager设计介绍</title>
    <url>/2021/03/06/ModuleManager/</url>
    <content><![CDATA[<p>更新于2022-11-24 完善文档</p>
<p>NNModule-swift 用于解决Swift项目中的组件间通信问题，主要用于业务模块之间的解耦（这里并不包含一些基础模块，如网络层）， 希望通过 NNModule-swift 向大家提供一种思路，对遇到类似问题的同学能有所启发。</p>
<p>ModuleManager 类是NNModule-swift中用于管理服务的主要类，用于在App启动加载所有的服务。</p>
<p>项目地址：<a href="https://github.com/YiHuaXie/NNModule" target="_blank" rel="noopener">NNModule-swift</a></p>
<h2 id="何为服务"><a href="#何为服务" class="headerlink" title="何为服务"></a>何为服务</h2><p>ModuleManger 以注册服务的方式为核心进行组件间的解耦。服务的本质就是定义了一系列行为的一套接口，ModuleManager 将所有需要跨模块通信的功能全部定义为服务。在 ModuleManager 中所有提供的服务均基于 <code>ModuleBasicSerivce</code> ，它需要一个对应的实现者，在项目中我们称为 Impl。调用者是通过定义好的服务进行接口调用，而不是通过具体的类名即具体的 Impl 类调用接口。</p>
<p><code>ModuleBasicService</code> 定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ModuleBasicService</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    <span class="comment">// 创建 Impl 实例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> implInstance: <span class="type">Self</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">ModuleBasicService</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取 Impl 实例默认实现</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> implInstance: <span class="type">ModuleBasicService</span> &#123; <span class="keyword">self</span>.<span class="keyword">init</span>() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="功能类服务"><a href="#功能类服务" class="headerlink" title="功能类服务"></a>功能类服务</h3><p>我们将需要进行跨模块通信的一些功能集抽象为一种功能类服务，所有的功能类服务均基于<code>ModuleFunctionalService</code>。功能类服务对应的 Impl 负责实现功能类服务中的所有接口，它与功能类服务为1对1关系，即使在项目中有多个类实现了同一个功能类服务（即有多个Impl），但是实际调用的 Impl 实例有且只有一个。每个功能类服务的 Impl 是分散各个模块中的，调用者只需要知道某个功能类服务能提供某个行为即可，对于具体的 Impl 的具体信息大可不必关心。</p>
<p><code>ModuleFunctionalService</code>定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ModuleFunctionalService</span>: <span class="title">ModuleBasicService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Impl 优先级</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> implPriority: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">ModuleFunctionalService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> implPriority: <span class="type">Int</span> &#123; <span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>implPriority</code> 用于指定 Impl 类的优先级，当某个功能类服务存在多个 Impl 类时，只会选择优先级最高的 Impl 类作为功能类服务的 Impl。</p>
<p>根据对功能类服务的说明，得到下面这个关系图：</p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/nn_module_func_service_uml.png" alt="功能类服务类图"></p>
<p>示例代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册路由服务</span></span><br><span class="line"><span class="type">Module</span>.register(service: <span class="type">ModuleRouteService</span>.<span class="keyword">self</span>, used: <span class="type">URLRouter</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="comment">// 注册登录服务</span></span><br><span class="line"><span class="type">Module</span>.register(service: <span class="type">LoginService</span>.<span class="keyword">self</span>, used: <span class="type">LoginManager</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过路由服务注册路由</span></span><br><span class="line"><span class="type">Module</span>.routeService.registerRoute(<span class="string">"xxxx"</span>) &#123; url, navigator <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(url.parameters)</span><br><span class="line">    navigator.push(<span class="type">A2ViewController</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过路由服务调用路由</span></span><br><span class="line"><span class="type">Module</span>.routeService.openRoute(<span class="string">"xxxx"</span>, parameters: [<span class="string">"model"</span>: xxxx])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过登录服务获取是否登录</span></span><br><span class="line"><span class="type">Module</span>.service(of: <span class="type">LoginService</span>.<span class="keyword">self</span>).isLogin</span><br></pre></td></tr></table></figure>
<h3 id="注册类服务"><a href="#注册类服务" class="headerlink" title="注册类服务"></a>注册类服务</h3><p>对于某些功能类服务（比如路由服务）来说，它自身就需要由其他模块为它注册内容，因此衍生出一系列注册类服务。注册类服务的职责便是为功能类服务注册内容，在 Modulemanager 中所有的注册类服务均基于 <code>ModuleRegisteredService</code>，它同样需要有对应的 Impl 来实现所有的接口，但与功能类服务的不同的是，注册类服务与 Impl 为1对多关系，多个 Impl 共同完成某个功能类服务的注册内容。</p>
<p><code>ModuleRegisteredService</code> 的定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ModuleRegisteredService</span>: <span class="title">ModuleBasicService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否保活实例，默认为 false</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> keepaliveRegiteredImpl: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">ModuleRegisteredService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> keepaliveRegiteredImpl: <span class="type">Bool</span> &#123; <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>keepaliveRegiteredImpl</code> 用于保活实例，这么设计处于以下几个方面考虑：</p>
<ol>
<li>若没有其他对象持有会导致它被调用完后会被释放，如果这些 Impl 涉及到数据操作的话，很容易出现数据错误和丢失的情况</li>
<li>基于第1点提到的情况，虽然 <code>ModuleBasicService</code> 的 <code>implInstance</code> 可以指定实例比如单例对象，但是我们不能对所有的 impl 类都声明一个单例属性，这显然是不必要的</li>
<li>对于某些类来说，它可能是A功能的实现者，同时它又要为B功能提供注册，那么设置<code>keepaliveRegiteredImpl</code> 属性为 true 可以保证实例的唯一性以及防止数据分散在不同的实例上 </li>
</ol>
<p>举个例子，ModuleManager 中有一个用于 TabBar 配置的服务 <code>ModuleTabService</code>，对，每个 tabBar Item 对应 ViewController 位于不同的业务模块中，为了解耦我们不能直接将这些 ViewController 所在的 module 直接引入，因此需要一个注册 tabBar Item 的 <code>RegisterTabItemService</code> 服务来帮助 <code>ModuleTabService</code> 对应的 Impl 获取到所有的 TabBarItem。</p>
<p>根据上面所述，可以得到下面这个类图：</p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/nn_module_tab_service_uml.png" alt="tab服务类图"></p>
<p>示例代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tabService 额外提供添加注册类服务的接口 RegisterTabItemService</span></span><br><span class="line"><span class="comment">// 调用 tabSerivce 添加 RegisterTabItemService 的 Impl</span></span><br><span class="line"><span class="type">Module</span>.tabService.addRegister(<span class="type">BModuleImpl</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// BModuleImpl 作为 RegisterTabItemService 的 Impl</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BModuleImpl</span>: <span class="title">NSObject</span>, <span class="title">RegisterTabItemService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">registerTabBarItems</span><span class="params">()</span></span> -&gt; [<span class="type">TabBarItemMeta</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> config = <span class="type">Module</span>.service(of: <span class="type">ModuleConfigService</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> index = config.tabBarItemIndex(<span class="keyword">for</span>: <span class="string">"user"</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> bundle = resourceBundle(of: <span class="string">"BModule"</span>)</span><br><span class="line">        <span class="keyword">let</span> nav = <span class="type">UINavigationController</span>(rootViewController: <span class="type">UserViewController</span>())</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">UIImage</span>(named: <span class="string">"tabbar_user_normal"</span>, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">let</span> selectedImage = <span class="type">UIImage</span>(named: <span class="string">"tabbar_user_normal"</span>, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line">        nav.tabBarItem = <span class="type">ESTabBarItem</span>(<span class="type">NormalTabBarItemContentView</span>(), title: <span class="string">"user"</span>, image: image, selectedImage: selectedImage)</span><br><span class="line">        <span class="keyword">let</span> meta = <span class="type">TabBarItemMeta</span>(viewController: nav, tabIndex: index)</span><br><span class="line">        <span class="keyword">return</span> [meta]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>通过前面的介绍相信你已经了解如何通过声明服务去进行组件解耦的了，现在的问题是我们在什么时机去注册这些服务。这里有两点是非常明确的：</p>
<ol>
<li>注册服务的时机一定是在获取服务对应的实例之前就必须完成的，因此我们需要寻找足够早的时机。</li>
<li>注册服务的代码实现一定是分散在各个业务组件中，不可能全部放在一起。</li>
</ol>
<p>在 OC 中我们可以通过 <code>load</code> 函数实现服务的注册，但是 Swift 不再支持 <code>load</code> 这样的函数，因此我们可能要自己实现一个类似的功能。</p>
<h3 id="方案1-使用json配置-指定类-接口"><a href="#方案1-使用json配置-指定类-接口" class="headerlink" title="方案1.使用json配置+指定类+接口"></a>方案1.使用json配置+指定类+接口</h3><p>该方案的大致思路：</p>
<ol>
<li>在主工程中用一个 json 文件去保存所有的业务模块</li>
<li>定义出一套注册服务的接口，然后让每个业务模块的指定类去实现这套接口</li>
<li>当 App 初始化的时读取这个 json 文件获取所有的业务模块，并调用模块中的指定类的接口完成服务的注册</li>
</ol>
<p>大致实现如下：</p>
<p>在主工程中定义一个 <strong>module_config.json</strong> 文件，格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"modules"</span>: [</span><br><span class="line">        <span class="string">"AModule"</span>,</span><br><span class="line">        <span class="string">"BModule"</span>,</span><br><span class="line">        <span class="string">"CModule"</span></span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义注册服务的接口 <code>RegisterServiceProtocol</code>，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">RegisterServiceProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">registerService</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们规定每个业务模块需要创建一个以 <strong>业务模块名+Impl</strong> 为规则的类，用这个类来实现 <code>RegisterServiceProtocol</code> 中的接口，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AModule 中的 AModuleImpl 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AModuleImpl</span>: <span class="title">RegisterServiceProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register service</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">registerService</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Module</span>.register(service: <span class="type">HomeService</span>.<span class="keyword">self</span>, used: <span class="type">HomeManager</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... other code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然上述方法是可行的，但是在实际应用的时候可能会有几个问题：</p>
<ol>
<li>json 文件在没有脚本辅助的情况下容易忘记更改，导致服务不生效。</li>
<li>业务模块的 <strong>ModuleImpl</strong> 类承担着业务模块中心管理的角色，当业务模块极其复杂时可能会导致 <strong>ModuleImpl</strong> 类比较复杂。虽然业务模块复杂绝大部分可能因为业务拆解有问题，但我依旧希望能通过代码的方式进行一次挽救来减少这个文件的代码量。</li>
<li>集中式管理太多，主工程的 <strong>module_config.json</strong> 文件、各个业务模块下的 <strong>ModuleImpl</strong> 类都是集中式管理，一旦组件发生变动，会经常性的涉及到这些文件的修改。</li>
</ol>
<p>针对上述的问题，我曾经尝试使用 Runtime 遍历所有类的方式去加载所有的类，并从中筛选出那些遵循协议的类调用相关注册接口，但是测试结果证明，<code>objc_getClassList</code> 函数执行的耗时比较久，此路不通。但是如果想要减少集中式管理，我们就不得不使用动态机制，一旦涉及到动态调用，我们只能去从 Runtime 中去找解决方案（虽然是 swift 项目，但也不得已为之）。</p>
<h3 id="方案2-调用指定类方法列表中的所有方法"><a href="#方案2-调用指定类方法列表中的所有方法" class="headerlink" title="方案2. 调用指定类方法列表中的所有方法"></a>方案2. 调用指定类方法列表中的所有方法</h3><p>从 Runtime 中我们可以知道，通过 <code>class_copyMethodList</code> 函数可以获取到类的所有方法，另外分类可以非常灵活的添加方法。如果我们能指定一个类，并在 App 启动时调用它的类方法列表中的所有方法，那么是不是就能实现类似于 <code>load</code> 函数的效果。</p>
<p>使用分类的话会存在一个问题，当分类中出现同名函数的时候，<code>class_copyMethodList</code>确实有两个函数地址，但是调用时只会调用编译顺序最后添加的方法，这是因为 <code>objc_msgSend</code>的机制，但是在实际情况中我们并不能保证不出现同名函数的可能性，所以使用<code>objc_msgSend</code> 的方式调用可能是行不通的。好在 Runtime 提供了 <code>method_invoke</code> 函数，它可以直接调用函数的指针而且性能比消息机制还快。</p>
<p>还有一点需要注意，<code>class_copyMethodList</code> 中保存的是 OC 函数，对于 Swift 项目来说，需要在函数声明中添加 <code>@objc</code> 标记。</p>
<p>理清楚思路，我们就可以实现如何方法列表中的所有方法，实现如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用类的类方法列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadAllMethods</span><span class="params">(from aClass: AnyClass)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> metaClass: <span class="type">AnyClass</span> = object_getClass(aClass) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> methodList = class_copyMethodList(metaClass, &amp;<span class="built_in">count</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> handle = dlopen(<span class="literal">nil</span>, <span class="type">RTLD_LAZY</span>)</span><br><span class="line">    <span class="keyword">let</span> methodInvoke = dlsym(handle, <span class="string">"method_invoke"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="type">Int</span>(<span class="built_in">count</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> method = methodList[i]</span><br><span class="line">        <span class="built_in">unsafeBitCast</span>(methodInvoke, to:(<span class="meta">@convention</span>(<span class="built_in">c</span>)(<span class="type">Any</span>, <span class="type">Method</span>)-&gt;<span class="type">Void</span>).<span class="keyword">self</span>)(metaClass, method)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dlclose(handle)</span><br><span class="line">    free(methodList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于这个方案，我们在业务模块中注册服务将会变得异常的简单，只需要添加分类，在分类中添加带有<code>@objc</code>标记的类方法即可。由于分类添加函数的灵活性，对于解决 <strong>ModuleImpl</strong> 类中代码臃肿也起到了比较大的帮助。</p>
<p>经过模拟测试，假设某个类有1000个分类，每个分类中都有一个类方法，通过 <code>method_invoke</code> 调用这个1000个不包含具体代码的类方法的耗时小于2毫秒，方案的函数耗时比对可以运行 <a href="https://github.com/YiHuaXie/NNModule/tree/main/Example_RegisterationTime" target="_blank" rel="noopener">Example_RegisterationTime</a></p>
<h3 id="Module-RegisterService"><a href="#Module-RegisterService" class="headerlink" title="Module.RegisterService"></a>Module.RegisterService</h3><p>ModuleManager 中声明了 <code>Module.RegisterService</code> 用来提供注册功能类服务的时机。<br>在 <code>Module.RegisterService</code> 分类中添加类方法，使用<code>Module.register&lt;Service&gt;(service serviceType: Service.Type, used implClass: AnyClass)</code>即可完成功能类服务的注册。</p>
<p>ModuleManager 会在初始化时调用 <code>Module.RegisterService</code> 的所有类方法列表完成所有功能类服务的注册。在注册功能类服务的过程是不会初始化 Impl，Impl 的实例初始化会放在第一次使用服务的时候，这主要为了减少在 App 启动大量创建 Impl 的实例。</p>
<p>示例代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 AModule 组件内添加 Module.RegisterService 分类，注册 HouseService</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Module</span>.<span class="title">RegisterService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">aModuleRegisterService</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Module</span>.register(service: <span class="type">HouseService</span>.<span class="keyword">self</span>, used: <span class="type">HouseManager</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意两点：</p>
<ol>
<li>在 <code>Module.RegisterService</code> 分类的类方法中尽量不要初始化功能类服务的 Impl 实例或使用功能类服务，因为不确定使用到的功能类服务是否都已完成注册</li>
<li>功能类服务的 Impl 类的初始化函数中使用其他功能类服务要避免形成环路</li>
</ol>
<h3 id="Module-Awake"><a href="#Module-Awake" class="headerlink" title="Module.Awake"></a>Module.Awake</h3><p>ModuleManager 中声明了 <code>Module.Awake</code> 为某些功能类服务提供添加注册类服务的时机。比如 ModuleManager 中默认提供了 routeService、tabService、launchTaskService，这些功能类服务都是需要各个业务模块为它们提供注册类服务。</p>
<p>在 <code>Module.AModule</code> 分类中添加类方法，调用功能类服务的相关接口完成注册类服务的注册。</p>
<p>示例代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 BModule 组件内添加 Module.Awake 分类，添加路由与启动任务</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Module</span>.<span class="title">Awake</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">bModuleAwake</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Module</span>.launchTaskService.addRegister(<span class="type">ModuleLaunchTaskTest</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="type">Module</span>.routeService.registerRoute(<span class="string">"xxxx"</span>) &#123; url, navigator <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// do some thing</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意两点：</p>
<ol>
<li>在调用 <code>Module.Awake</code> 分类的类方法时，应用已经完成了所有功能类服务的注册，可以使用相关的功能类服务</li>
<li>对于有注册类服务的功能类服务来说，在正常使用功能前需要所有注册类服务的 Impl 类完成注册</li>
</ol>
<h2 id="ModuleManager提供的解耦方式"><a href="#ModuleManager提供的解耦方式" class="headerlink" title="ModuleManager提供的解耦方式"></a>ModuleManager提供的解耦方式</h2><h3 id="1-面向协议的服务注册"><a href="#1-面向协议的服务注册" class="headerlink" title="1. 面向协议的服务注册"></a>1. 面向协议的服务注册</h3><p>通过面向协议的服务注册方案是整个 ModuleManager 的核心思路，它通过服务注册的方式来实现远程接口调用的。业务模块提供自己对外服务的协议声明到中间层（这个中间层指的是所有业务模块均需要依赖的某个公共模块），调用方可以通过查看中间层定义的接口来进行具体的调用。</p>
<p>如下图：</p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/nn_module_services.jpg" alt="ModuleSerivces中定义的服务"></p>
<p>示例代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提前注册Login服务</span></span><br><span class="line"><span class="type">Module</span>.register(service: <span class="type">LoginService</span>.<span class="keyword">self</span>, used: <span class="type">LoginManager</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Login服务的Impl实例</span></span><br><span class="line"><span class="keyword">let</span> loginImpl = <span class="type">Module</span>.service(of: <span class="type">LoginService</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="comment">// 获取是否登录</span></span><br><span class="line">loginImpl.isLogin</span><br></pre></td></tr></table></figure>
<h3 id="2-基于-URL-的路由方案"><a href="#2-基于-URL-的路由方案" class="headerlink" title="2. 基于 URL 的路由方案"></a>2. 基于 URL 的路由方案</h3><p>使用路由进行跳转是最常见的页面解耦方式，关于路由的具体的使用方式可以查看<a href="https://github.com/YiHuaXie/NNModule/blob/main/Resources/URLRouter.md" target="_blank" rel="noopener">NNModule-swift/URLRouter</a>。</p>
<p>示例代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册路由</span></span><br><span class="line"><span class="type">Module</span>.routeService.register(<span class="string">"A2Page"</span>) &#123; url, navigator <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(url.parameters)</span><br><span class="line">    navigator.push(<span class="type">A2ViewController</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由跳转</span></span><br><span class="line"><span class="type">Module</span>.routeService.<span class="keyword">open</span>(<span class="string">"A2Page"</span>, parameters: [<span class="string">"model"</span>: <span class="keyword">self</span>])</span><br></pre></td></tr></table></figure>
<h3 id="3-基于协议的远程接口调用"><a href="#3-基于协议的远程接口调用" class="headerlink" title="3. 基于协议的远程接口调用"></a>3. 基于协议的远程接口调用</h3><p>基于协议的远程接口调用设计初衷是为了替代使用 <code>performSelector</code> 进行远程接口调用，<code>performSelector</code> 函数除了自身语法比较有些隐晦以外，API 只支持1对1的调用（虽然可以通过封装做到1对多的效果），思前想后最终还是决定使用协议的方式进行远程接口调用。</p>
<p>NNModule-swift 提供了 EventSet 和 EventBus 类，均通过事先定义好的接口进行远程调用。EventSet 是一个多代理，EventBus可以理解为是一个面向协议的通知中心。关于 EventSet 和 EventBus 的具体的使用方式可以查看<a href="https://github.com/YiHuaXie/NNModule/blob/main/Resources/EventTransfer.md" target="_blank" rel="noopener">NNModule-swift/EventTransfer</a>。</p>
<p>示例代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听登录相关接口</span></span><br><span class="line"><span class="type">EventBus</span>.<span class="keyword">default</span>.register(<span class="type">LoginEvent</span>.<span class="keyword">self</span>, target: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用登录成功</span></span><br><span class="line"><span class="type">EventBus</span>.<span class="keyword">default</span>.send(<span class="type">LoginEvent</span>.<span class="keyword">self</span>) &#123; $<span class="number">0</span>.didLoginSuccess() &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-基于-NotificationCenter-的通知方案"><a href="#4-基于-NotificationCenter-的通知方案" class="headerlink" title="4. 基于 NotificationCenter 的通知方案"></a>4. 基于 NotificationCenter 的通知方案</h3><p>基于通知的模块间通讯方案，实现思路非常简单， 直接基于系统的 NSNotificationCenter 即可。优势是实现简单，非常适合处理一对多的通讯场景。劣势是仅适用于简单通讯场景。复杂数据传输，同步调用等方式都不太方便。模块化通讯方案中，更多的是把通知方案作为以上几种方案的补充。具体使用方式可以查看<a href="https://github.com/YiHuaXie/NNModule/blob/main/Resources/StickyNotification.md" target="_blank" rel="noopener">NNModule-swift/StickyNotification</a></p>
<h2 id="ModuleManager-的具体使用"><a href="#ModuleManager-的具体使用" class="headerlink" title="ModuleManager 的具体使用"></a>ModuleManager 的具体使用</h2><p>关于 ModuleManager 的具体使用可查看<a href="https://github.com/YiHuaXie/NNModule" target="_blank" rel="noopener">NNModule-swift</a>。</p>
]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>OC内存大小的相关计算</title>
    <url>/2020/01/31/OC%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>在面试的过程中，我们较大概率地会被问一个类所占的内存大小。本篇博客从下面一段测试代码开始分析整个内存大小的计算过程。</p>
<p>测试代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> A &#123;</span><br><span class="line">&#125; TestA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> AA &#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">&#125; TestAA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> AAA &#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125; TestAAA;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student1</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student1</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student2</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">    <span class="keyword">int</span> _c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student2</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">+ (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"TestA sizeof: %lu"</span>,<span class="keyword">sizeof</span>(TestA));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"TestAA sizeof: %lu"</span>,<span class="keyword">sizeof</span>(TestAA));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"TestAAA sizeof: %lu"</span>,<span class="keyword">sizeof</span>(TestAAA));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------------------------------------"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSObject class_getInstanceSize = %zd"</span>, class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSObject malloc_size = %zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span>*)[<span class="built_in">NSObject</span> new]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------------------------------------"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Person class_getInstanceSize = %zd"</span>, class_getInstanceSize([Person <span class="keyword">class</span>]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Person malloc_size = %zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span>*)[Person new]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------------------------------------"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Student1 class_getInstanceSize = %zd"</span>, class_getInstanceSize([Student1 <span class="keyword">class</span>]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Student1 malloc_size = %zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span>*)[Student1 new]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Student1 sizeof = %zd"</span>, <span class="keyword">sizeof</span>([Student1 <span class="keyword">class</span>]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------------------------------------"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Student2 class_getInstanceSize = %zd"</span>, class_getInstanceSize([Student2 <span class="keyword">class</span>]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Student2 malloc_size = %zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span>*)[Student2 new]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果（运行在模拟器下）如下：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/print_memorySize.jpg" alt="class_getInstanceSize&amp;malloc_size"></p>
<p>其中<code>class_getInstanceSize</code>指的是成员变量占用的内存大小，<code>malloc_size</code>指的是指针指向内存空间的大小即实际分配的内存大小。</p>
<p>关于内存大小的计算主要依赖于运行环境以及内存对齐。上面的都是运行在arm64环境下，因此内存对齐决定了它们的值为什么不同。</p>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>内存对齐说白了就是为了提高CPU寻址操作性能的一种规则。我们可以通过<code>#pragma pack(n)</code>，n=1、2、4、8、16 来改变这一系数，其中的n就是要指定的“对齐系数”。内存对齐的规则如下：</p>
<blockquote>
<ol>
<li>数据成员对齐规则：结构体或联合体的第一个数据成员放在偏移为0的位置，以后每个数据成员的位置为min（对齐系数，自身长度）的整数倍，下个位置不为本数据成员的整数倍位置的自动补齐。</li>
<li>数据成员为结构体：该数据成员的内最大长度的整数倍的位置开始存储。</li>
<li>整体对齐规则：数据成员按照1，2步骤对齐之后，其自身也要对齐，对齐原则是min（对齐系数，数据成员最大长度）的整数倍。</li>
</ol>
</blockquote>
<h3 id="内存对齐计算"><a href="#内存对齐计算" class="headerlink" title="内存对齐计算"></a>内存对齐计算</h3><p>在64位编译器环境下</p>
<p>代码示例1：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对齐系数为8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="keyword">struct</span> AA &#123;</span><br><span class="line">    <span class="keyword">int</span> a;   <span class="comment">// 4字节</span></span><br><span class="line">    <span class="keyword">char</span> b;  <span class="comment">// 1字节</span></span><br><span class="line">    <span class="keyword">short</span> c; <span class="comment">// 2字节</span></span><br><span class="line">    <span class="keyword">char</span> d;  <span class="comment">// 1字节</span></span><br><span class="line">&#125; Test1AA;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Test1AA: %lu"</span>,<span class="keyword">sizeof</span>(Test1AA));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test1AA: 12</span><br></pre></td></tr></table></figure>
<p>计算过程如下：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%AE%A1%E7%AE%971.jpg" alt="内存对齐计算1"></p>
<p>代码示例2：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="keyword">struct</span> AA &#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">struct</span> BB &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">double</span> b;</span><br><span class="line">        <span class="keyword">float</span> c;</span><br><span class="line">    &#125; Test2BB;</span><br><span class="line">&#125; Test2AA;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Test2AA: %lu"</span>,<span class="keyword">sizeof</span>(Test2AA));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test2AA: 32</span><br></pre></td></tr></table></figure>
<p>计算过程如下：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%AE%A1%E7%AE%972.jpg" alt="内存对齐计算2"></p>
<h2 id="OC类的内存分析"><a href="#OC类的内存分析" class="headerlink" title="OC类的内存分析"></a>OC类的内存分析</h2><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><h4 id="class-getInstanceSize"><a href="#class-getInstanceSize" class="headerlink" title="class_getInstanceSize"></a>class_getInstanceSize</h4><p>上面讲到<code>class_getInstanceSize</code>表示成员变量所占的内存大小，那么对于Person类创建的实例来说，它的成员变量大小应该为12，为什么结果却是16。</p>
<p><code>class_getInstanceSize</code>的内存也有它自己的内存对齐，通过<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc源码</a>中的<code>class_getInstanceSize</code>的底层实现可以知道，<code>class_getInstanceSize</code>的实现依赖于底层函数<code>word_align</code>，该函数返回的结果是8的倍数，另外从<code>alloc</code>函数开始进行分析，到<code>instanceSize</code>函数中可以知道所有对象的内存大小至少是16个字节，所以对象申请的内存空间是以8字节进行内存对齐且至少是16个字节。</p>
<p><code>word_align</code>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">word_align</span><span class="params">(<span class="keyword">uint32_t</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// WORD_MASK在64下的定义为7UL，就是7，所以相当于(x + 7) &amp; ~7</span></span><br><span class="line">    <span class="comment">// 0000 0111    -&gt; 7</span></span><br><span class="line">    <span class="comment">// x:12，12就是Person类中成员变量的大小</span></span><br><span class="line">    <span class="comment">// 12+7 = 19</span></span><br><span class="line">    <span class="comment">// 0001 0011    -&gt; 19</span></span><br><span class="line">    <span class="comment">// &amp;</span></span><br><span class="line">    <span class="comment">// 1111 1000    -&gt; ~7  ~运算，二进制中，0变1，1变0. </span></span><br><span class="line">    <span class="comment">// 0001 0000    -&gt; 16</span></span><br><span class="line">    <span class="keyword">return</span> (x + WORD_MASK) &amp; ~WORD_MASK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="malloc-size"><a href="#malloc-size" class="headerlink" title="malloc_size"></a>malloc_size</h4><p>通过<a href="https://opensource.apple.com/tarballs/libmalloc/" target="_blank" rel="noopener">malloc源码</a>中的<code>segregated_size_to_fit</code>函数可以知道系统开辟内存空间是以16字节进行内存对齐。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> MALLOC_INLINE <span class="keyword">size_t</span></span><br><span class="line">segregated_size_to_fit(<span class="keyword">nanozone_t</span> *nanozone, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> *pKey) &#123;</span><br><span class="line">	<span class="keyword">size_t</span> k, slot_bytes;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == size) &#123;</span><br><span class="line">		<span class="comment">// NANO_REGIME_QUANTA_SIZE: (1 &lt;&lt; SHIFT_NANO_QUANTUM) 即 16</span></span><br><span class="line">		size = NANO_REGIME_QUANTA_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// size: 8 </span></span><br><span class="line">	<span class="comment">// 0000 1000   -&gt; 8</span></span><br><span class="line">	<span class="comment">// size + NANO_REGIME_QUANTA_SIZE - 1 = 8 + 15 = 23</span></span><br><span class="line">	<span class="comment">// 0001 0111   -&gt; 23</span></span><br><span class="line">	<span class="comment">// &gt;&gt; 4</span></span><br><span class="line">	<span class="comment">// 0000 0001</span></span><br><span class="line">	<span class="comment">// &lt;&lt; 4</span></span><br><span class="line">	<span class="comment">// 0001 0000   -&gt; 16</span></span><br><span class="line">	k = (size + NANO_REGIME_QUANTA_SIZE - <span class="number">1</span>) &gt;&gt; SHIFT_NANO_QUANTUM;</span><br><span class="line">	slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;</span><br><span class="line">	*pKey = k - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Person、Student的内存分析"><a href="#Person、Student的内存分析" class="headerlink" title="Person、Student的内存分析"></a>Person、Student的内存分析</h3><p>回到一开始的测试代码，根据上面内存对齐的3个规则，Person、Student1、Student2的实际分配内存（malloc_size）计算过程如下：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%AE%A1%E7%AE%973.jpg" alt="内存对齐计算3"></p>
<h3 id="使用View-Memory查看内存"><a href="#使用View-Memory查看内存" class="headerlink" title="使用View Memory查看内存"></a>使用View Memory查看内存</h3><p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/xcode_view_memory.jpg" alt="xcode_view_memory"></p>
<p>从上面这张图中我们可以知道，两个16进制代表1个字节，一行有32个字节。<code>01 00 00 00</code>、<code>03 00 00 00</code>、<code>05 00 00 00</code>（小端）对应的就是<code>_a</code>、<code>_b</code>、<code>_c</code>，另外前8个字节就是isa。整体内存布局也与我们手动计算实际内存分配的结果一致。</p>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p><code>sizeof</code>用来返回类型的大小，其内部也是进行了内存对齐的。将测试代码中的结构体<code>A</code>、<code>AA</code>、<code>AAA</code>通过内存对齐规则进行分析，确实得到<code>0</code>，<code>1</code>，<code>8</code>。</p>
<p>这里我们使用结构体<code>AA</code>进行举例：</p>
<ul>
<li>根据规则1，数据成员占1个字节，位于0号地址；</li>
<li>无结构体成员变量，跳过规则2；</li>
<li>根据规则3，<code>min(1, n) = 1</code>，取1的整数倍，即结构体分配的内存大小为1个字节。</li>
</ul>
<p>关于使用<code>sizeof</code>去获取OC类内存大小的时候，我发现一个比较有意思的东西。</p>
<p>测试代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> N_NSObject_IMPL &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> N_Person_IMPL &#123;</span><br><span class="line">    <span class="keyword">struct</span> N_NSObject_IMPL <span class="built_in">NSObject_IVARS</span>;</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> N_Student_IMPL &#123;</span><br><span class="line">    <span class="keyword">struct</span> N_Person_IMPL Person_IVARS;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">    <span class="keyword">char</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">    <span class="keyword">char</span> _c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">+ (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *o = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="keyword">struct</span> N_NSObject_IMPL *so = (__bridge <span class="keyword">struct</span> N_NSObject_IMPL *)o;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"[NSObject new] sizeof = %lu"</span>, <span class="keyword">sizeof</span>(o));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"[NSObject class] sizeof = %lu"</span>, <span class="keyword">sizeof</span>([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"struct N_NSObject_IMPL sizeof = %lu"</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> N_NSObject_IMPL));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"*so sizeof = %lu"</span>, <span class="keyword">sizeof</span>(so));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------------------------------------"</span>);</span><br><span class="line">    Person *p = [Person new];</span><br><span class="line">    <span class="keyword">struct</span> N_Person_IMPL *sp = (__bridge <span class="keyword">struct</span> N_Person_IMPL *)p;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"[Person new] sizeof = %lu"</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"[Person class] sizeof = %lu"</span>, <span class="keyword">sizeof</span>([Person <span class="keyword">class</span>]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"struct N_Person_IMPL sizeof = %lu"</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> N_Person_IMPL));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"*sp sizeof = %lu"</span>, <span class="keyword">sizeof</span>(sp));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------------------------------------"</span>);</span><br><span class="line">    Student *s = [Student new];</span><br><span class="line">    <span class="keyword">struct</span> N_Student_IMPL *ss = (__bridge <span class="keyword">struct</span> N_Student_IMPL *)s;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"[Student new] sizeof = %lu"</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"[Student class] sizeof = %lu"</span>, <span class="keyword">sizeof</span>([Student <span class="keyword">class</span>]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"N_Student_IMPL sizeof = %lu"</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> N_Student_IMPL));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Student malloc_size = %zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span>*)s));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"*ss sizeof = %lu"</span>, <span class="keyword">sizeof</span>(ss));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/print_sizeof.jpg" alt="打印sizeof"></p>
<p><code>N_NSObject_IMPL</code>、<code>N_Person_IMPL</code>、<code>N_Student_IMPL</code>是将OC转成C++代码时对应的结构，使用<code>sizeof</code>获取这些结构体大小的时候，值与<code>class_getInstanceSize</code>的值是一样的。</p>
<p>使用<code>sizeof</code>获取指针、实例、类其结果都是8，这又是为什么呢？个人认为传实例和类的时候可以看做传的其实就是对应的指针。指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，地址基本就是整形，因此无论用什么类、对象作为<code>sizeof</code>的参数（这里就将<code>sizeof</code>看成是一个函数），其结果都一样的。</p>
<p>最后再总结下<code>class_getInstanceSize</code>、<code>malloc_size</code>、<code>sizeof</code>的区别：</p>
<ul>
<li><code>class_getInstanceSize</code>表示成员变量的所占的内存大小</li>
<li><code>malloc_size</code>表示实际分配的内存大小</li>
<li><code>sizeof</code>表示变量或者类型的大小，传入结构体，返回的则是结构的大小，传入指针（这里的指针表示C指针，OC的引用）即传入值，则返回传入值的类型大小</li>
</ul>
]]></content>
      <categories>
        <category>OC对象内存</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>OC对象的生成与销毁</title>
    <url>/2018/12/02/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E9%94%80%E6%AF%81/</url>
    <content><![CDATA[<p>在iOS开发中了，我们每天都会使用<code>+ alloc</code>和<code>- init</code>这两个方进行对象的初始化。我们也这知道整个对象的初始化过程其实就是<strong>开辟一块内存空间，并且初始化isa_t结构体的过程</strong>。</p>
<h2 id="alloc的实现"><a href="#alloc的实现" class="headerlink" title="alloc的实现"></a>alloc的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id _objc_rootAlloc(Class cls) &#123;</span><br><span class="line">    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程其实就是<code>NSObject</code>对<code>callAlloc</code>方法的实现。</p>
<h3 id="callAlloc"><a href="#callAlloc" class="headerlink" title="callAlloc"></a>callAlloc</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> cls:CustomClass</span><br><span class="line"> checkNil:是否检查Cls</span><br><span class="line"> allocWithZone：是否分配到指定空间，默认为false，内部会对其进行优化</span><br><span class="line">*/</span><br><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone=false) &#123;</span><br><span class="line">    //没有class或则checkNil为YES，返回空</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line"></span><br><span class="line">//确保只有Objective-C 2.0语言的文件所引用</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    //判断class有没有默认的allocWithZone方法</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        // class可以快速分配</span><br><span class="line">        if (fastpath(cls-&gt;canAllocFast())) &#123;</span><br><span class="line">            //hasCxxDtor();是C++析构函数，判断是否有析构函数</span><br><span class="line">            bool dtor = cls-&gt;hasCxxDtor();</span><br><span class="line">            //申请class的内存空间</span><br><span class="line">            id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize());</span><br><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span><br><span class="line">            //初始化isa指针</span><br><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span><br><span class="line">            return obj;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //使用class_createInstance创建class</span><br><span class="line">            id obj = class_createInstance(cls, 0);</span><br><span class="line">            if (slowpath(!obj)) return callBadAllocHandler(cls);</span><br><span class="line">            return obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    //说明有默认的allocWithZone的方法，调用allocWithZone方法</span><br><span class="line">    if (allocWithZone) return [cls allocWithZone:nil];</span><br><span class="line">    return [cls alloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>__OBJC2__</code>下当前类有没有默认的<code>allocWithZone</code>方法是通过<code>hasCustomAWZ()</code>函数判断的。<code>YES</code>代表有则会调用<code>[cls allocWithZone:nil]</code>方法。<code>NO</code>代表没有，这时候会根据当前类是否可以快速分配，<code>NO</code>的话调用<code>class_createInstance</code>函数；<code>YES</code>则分配内存并初始化isa。</p>
<h3 id="allocWithZone"><a href="#allocWithZone" class="headerlink" title="allocWithZone"></a>allocWithZone</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return _objc_rootAllocWithZone(self, (malloc_zone_t *)zone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id _objc_rootAllocWithZone(Class cls, malloc_zone_t *zone) &#123;</span><br><span class="line">    id obj;</span><br><span class="line"></span><br><span class="line">#if __OBJC2__</span><br><span class="line">    // allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    (void)zone;</span><br><span class="line">    obj = class_createInstance(cls, 0);</span><br><span class="line">#else</span><br><span class="line">    if (!zone) &#123;</span><br><span class="line">        obj = class_createInstance(cls, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        obj = class_createInstanceFromZone(cls, 0, zone);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    if (slowpath(!obj)) obj = callBadAllocHandler(cls);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>allocWithZone</code>函数的本质是调用<code>_objc_rootAllocWithZone</code>函数。</p>
<p><code>_objc_rootAllocWithZone</code>的逻辑分为两种情况：</p>
<ol>
<li>先判断是否是<code>__OBJC2__</code>，如果是则调用<code>class_createInstance</code>；</li>
<li>判断<code>zone</code>是否为空，如果为空调用<code>class_createInstance</code>，如果不为空，调用<code>class_createInstanceFromZone</code>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//class_createInstance</span><br><span class="line">id class_createInstance(Class cls, size_t extraBytes) &#123;</span><br><span class="line">    return _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//class_createInstanceFromZone</span><br><span class="line">id class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone) &#123;</span><br><span class="line">    return _class_createInstanceFromZone(cls, extraBytes, zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>class_createInstance</code>和<code>class_createInstanceFromZone</code>的本质都是调用<code>_class_createInstanceFromZone</code>。</p>
<p>另外通过前面的源代码我们可以发现：<strong>用alloc方式创建，只要当前类有allocWithZone方法，最终一定是调用class_createInstance</strong>。</p>
<h3 id="class-createInstanceFromZone"><a href="#class-createInstanceFromZone" class="headerlink" title="_class_createInstanceFromZone"></a><strong>_class_createInstanceFromZone</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static __attribute__((always_inline)) </span><br><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span><br><span class="line">                              bool cxxConstruct = true, </span><br><span class="line">                              size_t *outAllocatedSize = nil) &#123;</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    bool hasCxxCtor = cls-&gt;hasCxxCtor();//构造函数</span><br><span class="line">    bool hasCxxDtor = cls-&gt;hasCxxDtor();//析构函数</span><br><span class="line">    bool fast = cls-&gt;canAllocNonpointer(); //是对isa的类型的区分，如果一个类不能使用isa_t类型的isa的话，fast就为false，但是在Objective-C 2.0中，大部分类都是支持的</span><br><span class="line">    //在分配内存之前，需要知道对象在内存中的大小，也就是instanceSize的作用。对象必须大于等于16字节。</span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        //分配内存空间</span><br><span class="line">        obj = (id)calloc(1, size);</span><br><span class="line">        if (!obj) return nil;</span><br><span class="line">        //初始化isa指针</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //此时的fast 为 false</span><br><span class="line">        //在C语言中，malloc表示在内存的动态存储区中分配一块长度为“size”字节的连续区域，返回该区域的首地址；calloc表示在内存的动态存储区中分配n块长度为“size”字节的连续区域，返回首地址。</span><br><span class="line">        if (zone) &#123;</span><br><span class="line">            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj = (id)calloc(1, size);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">        //初始化isa指针</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class="line">        obj = _objc_constructOrFree(obj, cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化isa"><a href="#初始化isa" class="headerlink" title="初始化isa"></a>初始化isa</h3><p><code>_class_createInstanceFromZone</code>中不光开辟了内存空间，还初始化了isa。初始化isa的方法有<code>initInstanceIsa</code>和<code>initIsa</code>，但是本质都是调用<code>initIsa(Class cls, bool nonpointer, bool hasCxxDtor)</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">    if (!nonpointer) &#123;</span><br><span class="line">        isa.cls = cls; //obj-&gt;initIsa(cls)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">        assert(!DisableNonpointerIsa);</span><br><span class="line">        assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">        assert(cls-&gt;classArrayIndex() &gt; 0);</span><br><span class="line">        newisa.bits = ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        // isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line">#else</span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        // isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        // isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        // This write must be performed in a single store in some cases</span><br><span class="line">        // (for example when realizing a class because other threads</span><br><span class="line">        // may simultaneously try to use the class).</span><br><span class="line">        // fixme use atomics here to guarantee single-store and to</span><br><span class="line">        // guarantee memory order w.r.t. the class index table</span><br><span class="line">        // ...but not too atomic because we don&apos;t want to hurt instantiation</span><br><span class="line">        isa = newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据《OC引用计数器的原理》，现在再看一下初始化isa的方法。这个方法的意思是首先判断是否开启指针优化。</p>
<p>没有开启指针优化的话访问 <code>objc_object</code>的<code>isa</code>会直接返回<code>isa_t</code>结构中的<code>cls</code>变量，<code>cls</code>变量会指向对象所属的类的结构。</p>
<p>开启指针优化的话通过<code>newisa(0)</code>函数初始化一个isa，并根据<code>SUPPORT_INDEXED_ISA</code>分别设置对应的值。iOS设备的话这个值是0，所以执行<code>else</code>的代码。</p>
<p>到这里alloc的实现过程已经结束了，根据上面的源码分析，用一张图表示上述过程：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/alloc%E6%B5%81%E7%A8%8B.png" alt></p>
<p>这里可能会有个疑问，既然<code>alloc</code>将分配内存空间和初始化isa的事情都做了，那么<code>init</code>的作用是什么呢？</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    return _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id _objc_rootInit(id obj) &#123;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>init</code>的作用就是返回当前对象。这里有个问题既然<code>init</code>只是返回当前对象，为什么要多此一举呢？</p>
<p>Apple给出的注释：</p>
<blockquote>
<p>In practice, it will be hard to rely on this function. Many classes do not properly chain -init calls.</p>
</blockquote>
<p>意思是在实践中，很难依靠这个功能。许多类没有正确链接<code>init</code>调用。所以这个函数很可能不被调用。也许是历史遗留问题吧。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id)new &#123;</span><br><span class="line">    return [callAlloc(self, false/*checkNil*/) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以说<code>UIView *view = [UIView new];</code>和<code>UIView *view = [[UIView alloc]init];</code>是一样的。</p>
<h2 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h2><p>分析了对象的生成，我们现在看一下对象是如何被销毁的。<code>dealloc</code>的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _objc_rootDealloc(id obj) &#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc() &#123;</span><br><span class="line">    if (isTaggedPointer()) return;  // fixme necessary?</span><br><span class="line"></span><br><span class="line">    if (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rootDealloc</code>分为三种情况：</p>
<ol>
<li>如果是TaggedPointer，直接return；</li>
<li>进行一些关于isa的条件判断，如果满足就释放分配的内存控件；</li>
<li>调用<code>object_dispose</code>函数，这是最重要的；</li>
</ol>
<h3 id="objc-destructInstance"><a href="#objc-destructInstance" class="headerlink" title="objc_destructInstance"></a>objc_destructInstance</h3><p>我们先看<code>object_dispose</code>函数的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id object_dispose(id obj) &#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了两件事情：</p>
<ol>
<li>调用<code>objc_destructInstance</code>函数</li>
<li>释放分配的内存空间</li>
</ol>
<p><code>objc_destructInstance</code>的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* objc_destructInstance</span><br><span class="line">* Destroys an instance without freeing memory. </span><br><span class="line">* Calls C++ destructors.</span><br><span class="line">* Calls ARC ivar cleanup.</span><br><span class="line">* Removes associative references.</span><br><span class="line">* Returns `obj`. Does nothing if `obj` is nil.</span><br><span class="line">**********************************************************************/</span><br><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">        bool cxx = obj-&gt;hasCxxDtor();//是否有析构函数</span><br><span class="line">        bool assoc = obj-&gt;hasAssociatedObjects();//是否有关联对象</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);//调用析构函数</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);//删除关联对象</span><br><span class="line">        obj-&gt;clearDeallocating();//清空引用计数表并清除弱引用表</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_destructInstance</code>做了三件事情：</p>
<ol>
<li>执行<code>object_cxxDestruct</code>调用析构函数</li>
<li>执行<code>_object_remove_assocations</code>删除关联对象</li>
<li>执行<code>clearDeallocating</code>清空引用计数表并清除弱引用表，将所有weak引用指nil（这也解释了为什么使用weak能自动置空）</li>
</ol>
<h4 id="object-cxxDestruct"><a href="#object-cxxDestruct" class="headerlink" title="object_cxxDestruct"></a>object_cxxDestruct</h4><p>在源码中<code>object_cxxDestruct</code>的实现由<code>object_cxxDestructFromClass</code>完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void object_cxxDestructFromClass(id obj, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    void (*dtor)(id);</span><br><span class="line"></span><br><span class="line">    // Call cls&apos;s dtor first, then superclasses&apos;s dtors.</span><br><span class="line"></span><br><span class="line">    for ( ; cls; cls = cls-&gt;superclass) &#123;</span><br><span class="line">        if (!cls-&gt;hasCxxDtor()) return; </span><br><span class="line">        dtor = (void(*)(id))</span><br><span class="line">            lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct);</span><br><span class="line">        if (dtor != (void(*)(id))_objc_msgForward_impcache) &#123;</span><br><span class="line">            if (PrintCxxCtors) &#123;</span><br><span class="line">                _objc_inform(&quot;CXX: calling C++ destructors for class %s&quot;, </span><br><span class="line">                             cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            (*dtor)(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的意思就是沿着继承链逐层向上搜寻<code>SEL_cxx_destruct</code>这个<code>selector</code>，找到函数实现(void (*)(id)(函数指针)并执行。说白了就是找析构函数，并执行析构函数。</p>
<p>析构函数中书如何处理成员变量的？</p>
<ol>
<li>对于strong来说执行<code>objc_storeStrong(&amp;ivar, nil)</code>release旧对象，ivar赋新值nil；</li>
<li>对于weak来说执行<code>objc_destroyWeak(&amp;ivar)</code>消除对象weak表中的ivar地址。</li>
</ol>
<p>关于这个函数<a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/" target="_blank" rel="noopener">Sunnyxx ARC下dealloc过程及.cxx_destruct的探究</a>中也有提到。</p>
<p>用一张图表示<code>dealloc</code>的流程：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/dealloc%E6%B5%81%E7%A8%8B.png" alt></p>
<p>至于<code>dealloc</code>的调用时机，是跟引用计数器相关的。</p>
]]></content>
      <categories>
        <category>OC对象内存</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>OC内存管理-引用计数器</title>
    <url>/2018/12/02/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="引用计数的存储策略"><a href="#引用计数的存储策略" class="headerlink" title="引用计数的存储策略"></a>引用计数的存储策略</h2><ol>
<li>有些对象如果支持使用<code>Tagged Pointer</code>，苹果会直接将其指针值作为引用计数返回；</li>
<li>如果当前设备是<code>64</code>位环境并且使用<code>Objective-C 2.0</code>，那么“一些”对象会使用其<code>isa</code>指针的一部分空间来存储它的引用计数；</li>
<li>否则<code>Runtime</code>会使用一张散列表来管理引用计数。</li>
</ol>
<h2 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h2><p>从64bit开始，iOS引入了<code>Tagged Pointer</code>技术，用来优化<code>NSNumber</code>、<code>NSDate</code>、<code>NSString</code>等小对象的内存。</p>
<p>我们知道在没有使用<code>Tagged Pointer</code>之前，<code>NSNumber</code>、<code>NSDate</code>、<code>NSString</code>等对象需要动态分配内存，维护引用计数等。对象的指针存的是一个指向堆空间的地址值。以<code>NSNumber</code>为例，我们在创建NSObject对象的时候，至少需要16个字节的内存大小（这个与OC内存对齐所使用的系数有关），另外还要用其他的内存空间来存<code>NSNumber</code>所对应的值，看上去这无疑在增加内存的开销。</p>
<p>在使用了<code>Tagged Pointer</code>之后，它的指针不再是地址了，而是真正的值，准确的说是Tag+Data。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要<code>malloc</code>和<code>free</code>。</p>
<p>在内存的读取上使用了<code>Tagged Pointer</code>技术的对象也会比之前快很多。</p>
<p>下面的代码用来反映在64位系统下<code>Tagged Pointer</code>的应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSNumber *number1 = @1;</span><br><span class="line">        NSNumber *number2 = @2;</span><br><span class="line">        NSNumber *number3 = @3;</span><br><span class="line">        NSNumber *number4 = @4;</span><br><span class="line">        </span><br><span class="line">        NSNumber *numberLarger = @(MAXFLOAT);</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;number1 pointer is %p&quot;, number1);</span><br><span class="line">        NSLog(@&quot;number2 pointer is %p&quot;, number2);</span><br><span class="line">        NSLog(@&quot;number3 pointer is %p&quot;, number3);</span><br><span class="line">        NSLog(@&quot;number4 pointer is %p&quot;, number4);</span><br><span class="line">        NSLog(@&quot;numberLarger pointer is %p&quot;, numberLarger);</span><br><span class="line">        </span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印结果：</span><br><span class="line">2018-09-25 15:26:05.788382+0800 NSObjectProject[68029:24580896] number1 pointer is 0x9c344c19d780bc93</span><br><span class="line">2018-09-25 15:26:05.789257+0800 NSObjectProject[68029:24580896] number2 pointer is 0x9c344c19d780bca3</span><br><span class="line">2018-09-25 15:26:05.789383+0800 NSObjectProject[68029:24580896] number3 pointer is 0x9c344c19d780bcb3</span><br><span class="line">2018-09-25 15:26:05.789489+0800 NSObjectProject[68029:24580896] number4 pointer is 0x9c344c19d780bcc3</span><br><span class="line">2018-09-25 15:26:05.789579+0800 NSObjectProject[68029:24580896] numberLarger pointer is 0x600001e60d80</span><br></pre></td></tr></table></figure>
<p>上面的打印结果中，除了<code>numberLarger</code>这个变量之外，其他变量都使用<code>Tagged Pointer</code>技术。那如何知道对象是否是<code>Tagged Pointer</code>的对象呢？接着看一下源码中的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline bool objc_object::isTaggedPointer() &#123;</span><br><span class="line">    return _objc_isTaggedPointer(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline bool _objc_isTaggedPointer(const void * _Nullable ptr) &#123;</span><br><span class="line">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_OBJC_TAG_MASK</code>是一个依赖于环境的宏，其相关定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__</span><br><span class="line">    // 64-bit Mac - tag bit is LSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 0</span><br><span class="line">#else</span><br><span class="line">    // Everything else - tag bit is MSB</span><br><span class="line">#   define OBJC_MSB_TAGGED_POINTERS 1</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if OBJC_MSB_TAGGED_POINTERS</span><br><span class="line">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="line">#else</span><br><span class="line">#   define _OBJC_TAG_MASK 1UL</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>如果是mac OS 64bit的环境下，<code>_OBJC_TAG_MASK</code>是<code>1UL</code>，如果是iOS 64bit的环境下，<code>_OBJC_TAG_MASK</code>是<code>1UL&lt;&lt;63</code>（<code>1UL</code>就是1）。</p>
<p>所以判断是否<code>Tagged Pointer</code>的对象需要分环境考虑。如果是mac 64bit的环境下，则查看其指针最低有效位是否为1，如果是iOS 64bit的环境下，则使用<code>1UL&lt;&lt;63</code>，即1往左偏移63即<code>0x1000000000000000</code>，即查看最高有效位是否为1。</p>
<p>上述实验是在iphone手机下运行的结果。我们将上面地址（16进制）的第一位转成二进制，分别是<code>1001</code>、<code>1001</code>、<code>1001</code>、<code>1001</code>、<code>0110</code>，做<code>$</code>运算后，除了<code>numberLarger</code>对应的变量以外，其他的都是<code>0x1000000000000000</code>。另外我们在创建对象的时候，只要是从堆空间里创建的对象，它的最低有效位一定是<code>0</code>。这还是因为OC对象的内存对齐使用的系数为16，所以内存地址一定是16的倍数。但是使用了<code>Tagged Pointer</code>技术的对象，它的最低有效位就不一定是<code>0</code>了。从这里也证明了使用<code>Tagged Pointer</code>的对象的内存并不存储在堆中，也不需要<code>malloc</code>和<code>free</code>。在后续的源码中，也会看到但凡是<code>Tagged Pointer</code>的对象，很多都会直接<code>return</code>。</p>
<p>到这里我们得出几个结论：</p>
<ol>
<li><strong>从64bit开始，iOS对NSNumber、NSDate、NSString等小对象会优先使用Tagged Pointer技术进行存储，即指针存储。当指针存储不下内容的时候，才会使用堆空间即动态分配内存；</strong></li>
<li><strong>在mac OS 64bit下，通过看最低有效位是否为1判断是否Tagged Pointer的对象，在iOS 64bit下，通过查看最高有效位是否为1来判断；</strong></li>
</ol>
<p>我们知道，所有对象都有其对应的<code>isa</code>指针，那么引入<code>Tagged Pointer</code>会对<code>isa</code>指针产生什么影响。</p>
<h2 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h2><h3 id="isa的本质——isa-t联合体"><a href="#isa的本质——isa-t联合体" class="headerlink" title="isa的本质——isa_t联合体"></a>isa的本质——isa_t联合体</h3><p>在Objective-C语言中，类也是对象，且每个对象都包含一个<code>isa</code>指针，<code>isa</code>指针指向该对象所属的类。<br>在arm64架构之前，<code>isa</code>就是一个普通的指针，存储着Class或者Meta-Class对象的内存地址。从arm64开始，Runtime对<code>isa</code>进行了优化，变成了一个<code>union</code>（共用体或者联合体）结构，还使用位域来存储更多的信息。</p>
<p>在C语言中，结构体可以包含多个类型不同的成员，各个成员会占用不同的内存，互相之间没有影响。结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙）。而联合体，是一种与结构体非常接近的数据结构，但是有所区别。共用体占用的内存等于最长的成员占用的内存，这就是说共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p>
<p>在<code>objc_object</code>这个结构体中定义了<code>isa</code>指针，这里我们只看<code>arm64</code>下的相关定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// isa_t的定义</span><br><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">#if SUPPORT_PACKED_ISA</span><br><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t nonpointer        : 1;</span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000</span><br><span class="line">        uintptr_t magic             : 6;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t deallocating      : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 19;</span><br><span class="line">#       define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#       define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line">    &#125;;</span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">// SUPPORT_PACKED_ISA</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>nonpointer</strong> 该变量占用1 bit内存空间，可以有两个值：0和1，分别代表不同的<code>isa_t</code>的类型：</p>
</li>
<li><p><strong>has_assoc</strong> 该变量与对象的关联引用有关。</p>
</li>
<li><p><strong>has_cxx_dtor</strong> 表示该对象是否有析构函数，如果有析构函数，则需要做析构逻辑；如果没有，则可以更快的释放对象。</p>
</li>
<li><p><strong>shiftcls</strong> 在开启指针优化的情况下，用33bits存储类指针的值。在<code>initIsa()</code>中有<code>newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</code>这样的代码，就是将类指针存在isa中。</p>
</li>
<li><p><strong>magic</strong> 用于调试器判断当前对象是真的对象还是没有初始化的空间</p>
</li>
<li><p><strong>weakly_referenced</strong> 标志对象是否被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放。</p>
</li>
<li><p><strong>deallocating</strong> 标志对象是否正在释放内存。</p>
</li>
<li><p><strong>extra_rc</strong> 存储的是引用计数</p>
</li>
<li><p><strong>has_sidetable_rc</strong> 当引用计数器过大的时候，那么引用计数会存储在一个叫<code>SideTable</code>的类的属性中。</p>
</li>
<li><p><strong>ISA_MAGIC_MASK</strong> 通过掩码方式获取<code>magic</code>值。</p>
</li>
<li><p><strong>SA_MASK</strong> 通过掩码方式获取<code>isa</code>的类指针值。</p>
</li>
<li><p><strong>RC_ONE</strong>和<strong>RC_HALF</strong> 用于引用计数的相关计算。</p>
</li>
</ul>
<p><code>nonpointer</code>的0表示开启指针优化即普通的指针，访问objc_object的isa会直接返回cls变量，cls变量会指向对象所属的类的结构；1表示开启指针优化，不能直接访问objc_object的isa成员变量（此时的isa而是一个<code>Tagged Pointer</code>），isa中包含了类信息、对象的引用计数等信息。</p>
<p><code>extra_rc</code>占了19位，可以存储的最大引用计数应该是$2^{19} - 1 + 1= 524288$（为什么要这么写是因为<code>extra_rc</code>保存的是值-1，而在获取引用计数的时候会+1），当超过它就需要<code>SideTables</code>。<code>SideTables</code>内包含一个<code>RefcountMap</code>，用来保存引用计数，根据对象地址取出其引用计数，类型是<code>size_t</code>。</p>
<p>这里有个问题，为什么既要使用一个<code>extra_rc</code>又要使用<code>SideTables</code>？</p>
<p>可能是因为历史问题，以前cpu是<code>32</code>位的，<code>isa</code>中能存储的引用计数就只有$2^7=128$。因此在<code>arm64</code>下，引用计数通常是存储在<code>isa</code>中的。</p>
<p>更具体的会在retain操作的时候讲到。</p>
<h3 id="isa-t联合体里面的宏"><a href="#isa-t联合体里面的宏" class="headerlink" title="isa_t联合体里面的宏"></a>isa_t联合体里面的宏</h3><h4 id="SUPPORT-PACKED-ISA"><a href="#SUPPORT-PACKED-ISA" class="headerlink" title="SUPPORT_PACKED_ISA"></a>SUPPORT_PACKED_ISA</h4><p>表示平台是否支持在<code>isa</code>指针中插入除<code>Class</code>之外的信息。</p>
<ol>
<li>如果支持就会将<code>Class</code>信息放入<code>isa_t</code>定义的struct内，并附上一些其他信息，例如上面的<code>nonpointer</code>等等；</li>
<li>如果不支持，那么不会使用<code>isa_t</code>内定义的<code>struct</code>，这时<code>isa_t</code>只使用<code>cls</code>（Class 指针）。</li>
</ol>
<p><strong>在iOS以及MacOSX设备上，<code>SUPPORT_PACKED_ISA</code>定义为1</strong>。</p>
<h4 id="SUPPORT-INDEXED-ISA"><a href="#SUPPORT-INDEXED-ISA" class="headerlink" title="SUPPORT_INDEXED_ISA"></a>SUPPORT_INDEXED_ISA</h4><p><code>SUPPORT_INDEXED_ISA</code>表示<code>isa_t</code>中存放的<code>Class</code>信息是<code>Class</code>的地址。在<code>initIsa()</code>中有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();</span><br></pre></td></tr></table></figure>
<p><strong>iOS设备上SUPPRT_INDEXED_ISA是0</strong>。</p>
<h3 id="isa类型有关的宏"><a href="#isa类型有关的宏" class="headerlink" title="isa类型有关的宏"></a>isa类型有关的宏</h3><h4 id="SUPPORT-NONPOINTER-ISA"><a href="#SUPPORT-NONPOINTER-ISA" class="headerlink" title="SUPPORT_NONPOINTER_ISA"></a>SUPPORT_NONPOINTER_ISA</h4><p>用于标记是否支持优化的<code>isa</code>指针，其定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if !SUPPORT_INDEXED_ISA  &amp;&amp;  !SUPPORT_PACKED_ISA</span><br><span class="line">#   define SUPPORT_NONPOINTER_ISA 0</span><br><span class="line">#else</span><br><span class="line">#   define SUPPORT_NONPOINTER_ISA 1</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>那如何判断是否支持优化的isa指针？</p>
<ol>
<li>已知iOS系统的<code>SUPPORT_PACKED_ISA</code>为1，<code>SUPPORT_INDEXED_ISA</code>为0，从上面的定义可以看出，iOS系统的<code>SUPPORT_NONPOINTER_ISA</code>为1；</li>
<li>在环境变量中设置<code>OBJC_DISABLE_NONPOINTER_ISA</code>。</li>
</ol>
<p>这里需要注意的是，即使是64位环境下，优化的<code>isa</code>指针并不是就一定会存储引用计数，毕竟用19bit iOS 系统）保存引用计数不一定够。另外这19位保存的是引用计数的值减一。</p>
<h2 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h2><p>在源码中我们经常会看到<code>SideTable</code>这个结构体。它的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line"></span><br><span class="line">    //省略其他代码</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面可知，<code>SideTable</code>中有三个成员变量：</p>
<ol>
<li><code>slock</code>用于保证原子操作的自旋锁；</li>
<li><code>refcnts</code>用于引用计数的<code>hash</code>表；</li>
<li><code>weak_table</code>用于weak引用的<code>hash</code>表。</li>
</ol>
<p>这里我们主要看引用计数的哈希表。<code>RefcountMap</code>的定义：<code>typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap;</code></p>
<p>可以看出<code>SideTable</code>用来保存引用计数具体是用<code>DenseMap</code>这个类（在<code>llvm-DenseMap.h</code>中）实现的。<code>DenseMap</code>以<code>DisguisedPtr&lt;objc_object&gt;</code>为<code>key</code>，<code>size_t</code>为<code>value</code>，<code>DisguisedPtr</code>类是对<code>objc_object *</code>指针及其一些操作进行的封装，其内容可以理解为对象的内存地址，值的类型为<code>__darwin_size_t</code>，在 darwin 内核一般等同于 <code>unsigned long</code>。其实这里保存的值也是等于引用计数减1。</p>
<h2 id="引用计数的获取"><a href="#引用计数的获取" class="headerlink" title="引用计数的获取"></a>引用计数的获取</h2><p>通过<code>retainCount</code>可以获取到引用计数器，其定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSUInteger)retainCount &#123;</span><br><span class="line">    return ((id)self)-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline uintptr_t objc_object::rootRetainCount() &#123;</span><br><span class="line">    if (isTaggedPointer()) return (uintptr_t)this;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    // 加锁，用汇编指令ldxr来保证原子性</span><br><span class="line">    isa_t bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    // 释放锁，使用汇编指令clrex</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">    if (bits.nonpointer) &#123;</span><br><span class="line">        uintptr_t rc = 1 + bits.extra_rc;</span><br><span class="line">        if (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    return sidetable_retainCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//sidetable_retainCount()函数实现</span><br><span class="line">uintptr_t objc_object::sidetable_retainCount() &#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line"></span><br><span class="line">    size_t refcnt_result = 1;</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">    if (it != table.refcnts.end()) &#123;</span><br><span class="line">        // this is valid for SIDE_TABLE_RC_PINNED too</span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    return refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可知，获取引用计数的时候分为三种情况：</p>
<ol>
<li><code>Tagged Pointer</code>的话，直接返回isa本身；</li>
<li>非<code>Tagged Pointer</code>，且开启了指针优化，此时引用计数先从<code>extra_rc</code>中去取（这里将取出来的值进行了+1操作，所以在存的时候需要进行-1操作），接着判断是否有<code>SideTable</code>，如果有再加上存在<code>SideTable</code>中的计数；</li>
<li>非<code>Tagged Pointer</code>，没有开启了指针优化，使用<code>sidetable_retainCount()</code>函数返回。</li>
</ol>
<h2 id="手动操作对引用计数的影响"><a href="#手动操作对引用计数的影响" class="headerlink" title="手动操作对引用计数的影响"></a>手动操作对引用计数的影响</h2><h3 id="objc-retain"><a href="#objc-retain" class="headerlink" title="objc_retain()"></a>objc_retain()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if __OBJC2__</span><br><span class="line">__attribute__((aligned(16))) id objc_retain(id obj) &#123;</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    return obj-&gt;retain();</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">id objc_retain(id obj) &#123; return [obj retain]; &#125;</span><br></pre></td></tr></table></figure>
<p>首先判断是否是<code>Tagged Pointer</code>的对象，是就返回对象本身，否则通过对象的<code>retain()</code>返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline id objc_object::retain() &#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    // hasCustomRR方法检查类（包括其父类）中是否含有默认的方法</span><br><span class="line">    if (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        return rootRetain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, SEL_retain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断是否是<code>Tagged Pointer</code>，这个函数并不希望处理的对象是<code>Tagged Pointer</code>；接着通过<code>hasCustomRR</code>函数检查类（包括其父类）中是否含有默认的方法，有则调用自定义的方法；如果没有，调用<code>rootRetain()</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALWAYS_INLINE id objc_object::rootRetain() &#123;</span><br><span class="line">    return rootRetain(false, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将源码精简后的逻辑</span><br><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    </span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    // 加锁，用汇编指令ldxr来保证原子性</span><br><span class="line">    oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    newisa = oldisa;</span><br><span class="line">    </span><br><span class="line">    if (newisa.nonpointer = 0) &#123;</span><br><span class="line">        // newisa.nonpointer = 0说明所有位数都是地址值</span><br><span class="line">        // 释放锁，使用汇编指令clrex</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        </span><br><span class="line">        // 由于所有位数都是地址值，直接使用SideTable来存储引用计数</span><br><span class="line">        return sidetable_retain();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 存储extra_rc++后的结果</span><br><span class="line">    uintptr_t carry;</span><br><span class="line">    // extra_rc++</span><br><span class="line">    newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);</span><br><span class="line">    </span><br><span class="line">    if (carry == 0) &#123;</span><br><span class="line">        // extra_rc++后溢出，进位到side table</span><br><span class="line">        newisa.extra_rc = RC_HALF;</span><br><span class="line">        newisa.has_sidetable_rc = true;</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    // 将newisa写入isa</span><br><span class="line">    StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)</span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的可以看到：</p>
<ul>
<li><code>Tagged Pointer</code>直接返回对象本身；</li>
<li><code>newisa.nonpointer == 0</code>没有开启指针优化，直接使用<code>SideTable</code>来存储引用计数；</li>
<li>开启指针优化，使用isa的<code>extra_rc</code>保存引用计数，当超出的时候，使用<code>SideTable</code>来存储额外的引用计数。</li>
</ul>
<h3 id="objc-release"><a href="#objc-release" class="headerlink" title="objc_release()"></a>objc_release()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if __OBJC2__</span><br><span class="line">__attribute__((aligned(16)))</span><br><span class="line">void </span><br><span class="line">objc_release(id obj) &#123;</span><br><span class="line">    if (!obj) return;</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return;</span><br><span class="line">    return obj-&gt;release();</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">void objc_release(id obj) &#123; [obj release]; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//release()源码</span><br><span class="line">inline void</span><br><span class="line">objc_object::release()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    if (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        rootRelease();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边的逻辑和<code>objc_retain()</code>的逻辑一致，所以直接看<code>rootRelease()</code>函数，与上面一样，下面的代码也是经过精简的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALWAYS_INLINE bool</span><br><span class="line">objc_object::rootRelease(bool performDealloc, bool handleUnderflow) &#123;</span><br><span class="line">    if (isTaggedPointer()) return false;</span><br><span class="line">    </span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line">    </span><br><span class="line">retry:</span><br><span class="line">    oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    newisa = oldisa;</span><br><span class="line">    if (newisa.nonpointer == 0) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        if (sideTableLocked) sidetable_unlock();</span><br><span class="line">        return sidetable_release(performDealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    uintptr_t carry;</span><br><span class="line">    // extra_rc--</span><br><span class="line">    newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);</span><br><span class="line">    if (carry == 0) &#123;</span><br><span class="line">        // 需要从SideTable借位，或者引用计数为0</span><br><span class="line">        goto underflow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 存储引用计数到isa</span><br><span class="line">    StoreReleaseExclusive(&amp;isa.bits,</span><br><span class="line">                          oldisa.bits, newisa.bits)</span><br><span class="line">    return false;</span><br><span class="line">    </span><br><span class="line">underflow:</span><br><span class="line">    // 从SideTable借位</span><br><span class="line">    // 或引用计数为0，调用delloc</span><br><span class="line">    </span><br><span class="line">    // 此处省略N多代码</span><br><span class="line">    // 总结一下:修改Side Table与extra_rc，</span><br><span class="line">    </span><br><span class="line">    // 引用计数减为0时，调用dealloc</span><br><span class="line">    if (performDealloc) &#123;</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到：</p>
<ol>
<li>判断是否是<code>Tagged Pointer</code>的对象，是就直接返回；</li>
<li>没有开启指针优化，使用<code>SideTable</code>存储的引用计数-1；</li>
<li>开启指针优化，使用isa的<code>extra_rc</code>保存的引用计数-1，当<code>carry==0</code>表示需要从<code>SideTable</code>保存的引用计数也用完了或者说引用计数为0，所以执行最后一步；</li>
<li>最后调用<code>dealloc</code>，所以这也回答了之前的《OC内存管理–对象的生成与销毁》中<code>dealloc</code>什么时候被调用这个问题，在<code>rootRelease(bool performDealloc, bool handleUnderflow)</code>函数中如果判断出引用计数为0了，就要调用<code>dealloc</code>函数了。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>引用计数存在什么地方？</p>
<ul>
<li><code>Tagged Pointer</code>不需要引用计数，苹果会直接将对象的指针值作为引用计数返回；</li>
<li>开启了指针优化（<code>nonpointer == 1</code>）的对象其引用计数优先存在<code>isa</code>的<code>extra_rc</code>中，大于<code>524288</code>便存在<code>SideTable</code>的<code>RefcountMap</code>或者说是<code>DenseMap</code>中；</li>
<li>没有开启指针优化的对象直接存在<code>SideTable</code>的<code>RefcountMap</code>或者说是<code>DenseMap</code>中。</li>
</ul>
</li>
<li><p>retain/release的实质</p>
<ul>
<li><code>Tagged Pointer</code>不参与<code>retain</code>/<code>release</code>；</li>
<li>找到引用计数存储区域，然后+1/-1，并根据是否开启指针优化，处理进位/借位的情况；</li>
<li>当引用计数减为0时，调用<code>dealloc</code>函数。</li>
</ul>
</li>
<li><p>isa是什么</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">Class ISA();</span><br><span class="line"></span><br><span class="line">// getIsa() allows this to be a tagged pointer object</span><br><span class="line">Class getIsa();</span><br></pre></td></tr></table></figure>
<ul>
<li>首先要知道，isa指针已经不一定是类指针了，所以需要用<code>ISA()</code>获取类指针；</li>
<li><code>Tagged Pointer</code>的对象没有<code>isa</code>指针，有的是<code>isa_t</code>的结构体；</li>
<li>其他对象的isa指针还是类指针。</li>
</ul>
</li>
<li><p>对象的值是什么</p>
<ul>
<li>如果是<code>Tagged Pointer</code>，对象的值就是指针；</li>
<li>如果非<code>Tagged Pointer</code>， 对象的值是指针指向的内存区域中的值。</li>
</ul>
</li>
</ol>
<h2 id="补充-一道多线程安全的题目"><a href="#补充-一道多线程安全的题目" class="headerlink" title="补充: 一道多线程安全的题目"></a>补充: 一道多线程安全的题目</h2><p>以下代码运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *target;</span><br><span class="line">//....</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;parallel&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">for (int i = 0; i &lt; 1000000 ; i++) &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        self.target = [NSString stringWithFormat:@&quot;ksddkjalkjd%d&quot;,i];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案：大概率地发生Crash。</p>
<p>Crash的原因：过度释放。</p>
<p>这道题看着虽然是多线程范围的，但是解题的最重要思路确是在引用计数上，更准确的来说是看对强引用的理解程度。关键知识点如下：</p>
<ol>
<li>全局队列和自定义并行队列在异步执行的时候会根据任务系统决定开辟线程个数；</li>
<li><code>target</code>使用<code>strong</code>进行了修饰，Block是会截获对象的修饰符的；</li>
<li>即使使用<code>_target</code>效果也是一样，因为默认使用<code>strong</code>修饰符隐式修饰；</li>
<li><code>strong</code>的源代码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc_storeStrong(id *location, id obj) &#123;</span><br><span class="line">    id prev = *location;</span><br><span class="line">    if (obj == prev) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    *location = obj;</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设这个并发队列创建了两个线程A和B，由于是异步的，可以同时执行。因此会出现这么一个场景，在线程A中，代码执行到了<code>objc_retain(obj)</code>，但是在线程B中可能执行到了<code>objc_release(prev)</code>，此时<code>prev</code>已经被释放了。那么当A在执行到<code>objc_release(prev)</code>就会过度释放，从而导致程序crash。</p>
<p>解决方法：</p>
<ol>
<li>加个互斥锁</li>
<li>使用串行队列，使用串行队列的话，其实内部是靠<code>DISPATCH_OBJ_BARRIER_BIT</code>设置阻塞标志位</li>
<li>使用weak</li>
<li>Tagged Pointer，如果说上面的<code>self.target</code>指向的是一个<code>Tagged Pointer</code>技术的<code>NSString</code>，那程序就没有问题。</li>
</ol>
]]></content>
      <categories>
        <category>OC对象内存</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>OC消息机制和super关键字</title>
    <url>/2019/03/12/OC%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>在Objective-C里面调用一个方法<code>[object method]</code>，运行时会将它翻译成<code>objc_msgSend(id self, SEL op, ...)</code>的形式。</p>
<h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p><code>objc_msgSend</code>的实现在<code>objc-msg-arm.s</code>、<code>objc-msg-arm64.s</code>等文件中，是通过汇编实现的。这里主要看在<code>arm64</code>即<code>objc-msg-arm64.s</code>的实现。由于汇编不熟，里面的实现只能连看带猜。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line">	MESSENGER_START</span><br><span class="line"></span><br><span class="line">	cmp	x0, #0			// nil check and tagged pointer check</span><br><span class="line">	b.le	LNilOrTagged		//  (MSB tagged pointer looks negative)</span><br><span class="line">	ldr	x13, [x0]		// x13 = isa</span><br><span class="line">	and	x16, x13, #ISA_MASK	// x16 = class	</span><br><span class="line">LGetIsaDone:</span><br><span class="line">	CacheLookup NORMAL		// calls imp or objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">LNilOrTagged:</span><br><span class="line">    /* nil check，如果为空就是调用LReturnZero，LReturnZero里调用MESSENGER_END_NIL*/</span><br><span class="line">	b.eq	LReturnZero		// nil check</span><br><span class="line"></span><br><span class="line">	// tagged</span><br><span class="line">	mov	x10, #0xf000000000000000</span><br><span class="line">	cmp	x0, x10</span><br><span class="line">	b.hs	LExtTag</span><br><span class="line">	adrp	x10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class="line">	add	x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br><span class="line">	ubfx	x11, x0, #60, #4</span><br><span class="line">	ldr	x16, [x10, x11, LSL #3]</span><br><span class="line">	b	LGetIsaDone</span><br><span class="line"></span><br><span class="line">LExtTag:</span><br><span class="line">	// ext tagged</span><br><span class="line">	adrp	x10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class="line">	add	x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br><span class="line">	ubfx	x11, x0, #52, #8</span><br><span class="line">	ldr	x16, [x10, x11, LSL #3]</span><br><span class="line">	b	LGetIsaDone</span><br><span class="line">	</span><br><span class="line">LReturnZero:</span><br><span class="line">	// x0 is already zero</span><br><span class="line">	mov	x1, #0</span><br><span class="line">	movi	d0, #0</span><br><span class="line">	movi	d1, #0</span><br><span class="line">	movi	d2, #0</span><br><span class="line">	movi	d3, #0</span><br><span class="line">	MESSENGER_END_NIL</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure>
<p>上面的流程可能是这样的：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/objc_msgsend.png" alt="objc_msgsend"></p>
<p>从<code>CacheLookup</code>的注释有两处：</p>
<ol>
<li><code>calls imp or objc_msgSend_uncached</code></li>
<li><code>Locate the implementation for a selector in a class method cache.</code></li>
</ol>
<p>即使看不懂汇编代码，但是从上面的注释我们可以猜测，消息机制会先从缓存中去查找。</p>
<h3 id="objc-msgSend-uncached"><a href="#objc-msgSend-uncached" class="headerlink" title="__objc_msgSend_uncached"></a>__objc_msgSend_uncached</h3><p>通过方法名我们可以知道，没有缓存的时候应该会执行<code>__objc_msgSend_uncached</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">// THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">// Out-of-band x16 is the class to search</span><br><span class="line"></span><br><span class="line">MethodTableLookup</span><br><span class="line">br	x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>
<p>这里的<code>MethodTableLookup</code>里涉及到<code>objc-runtime-new.mm</code>文件中的<code>_class_lookupMethodAndLoadCache3</code>。该函数会调用<code>lookUpImpOrForward</code>函数。</p>
<h3 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward"></a>lookUpImpOrForward</h3><p><code>lookUpImpOrForward</code>会返回一个<code>imp</code>，它的函数实现比较长，但是注释写的非常清楚。它的实现主要由以下几步（这里直接从缓存获取开始）：</p>
<ol>
<li>通过<code>cache_getImp</code>从缓存中获取方法，有则返回，否则进入第2步；</li>
<li>通过<code>getMethodNoSuper_nolock</code>从类的方法列表中获取，有加入缓存中并返回，否则进入第3步；</li>
<li>通过父类的缓存和父类的方法列表中寻找是否有对应的imp，此时会进入一个<code>for</code>循环，沿着类的父类一直往上找，直接找到NSObject为止。如果找到返回，否则进入第4步；</li>
<li>进入方法决议（method resolve）的过程即调用<code>_class_resolveMethod</code>，如果失败，进入第5步；</li>
<li>在缓存、当前类、父类以及方法决议都没有找到的情况下，Objective-C还为我们提供了最后一次翻身的机会，调用<code>_objc_msgForward_impcache</code>进行方法转发，如果找到便加入缓存；如果没有就crash。</li>
</ol>
<p>上述过程中有几个比较重要的函数：</p>
<h4 id="class-resolveMethod"><a href="#class-resolveMethod" class="headerlink" title="_class_resolveMethod"></a><strong>_class_resolveMethod</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _class_resolveMethod(Class cls, SEL sel, id inst) &#123;</span><br><span class="line">    if (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        // try [cls resolveInstanceMethod:sel]</span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        // try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">        // and [cls resolveInstanceMethod:sel]</span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        if (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数会根据当前传入的类的是不是一个元类，在<code>_class_resolveInstanceMethod</code>和<code>_class_resolveClassMethod</code>中选择一个进行调用。注释也说明了这两个方法的作用就是判断当前类是否实现了 <code>resolveInstanceMethod:</code>或者<code>resolveClassMethod:</code>方法，然后用<code>objc_msgSend</code>执行上述方法。</p>
<h4 id="class-resolveClassMethod"><a href="#class-resolveClassMethod" class="headerlink" title="_class_resolveClassMethod"></a><strong>_class_resolveClassMethod</strong></h4><p><code>_class_resolveClassMethod</code>和<code>_class_resolveInstanceMethod</code>实现类似，这里就只看<code>_class_resolveClassMethod</code>的实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void _class_resolveClassMethod(Class cls, SEL sel, id inst) &#123;</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123;</span><br><span class="line">         //没有找到resolveClassMethod方法，直接返回。</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved = msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    // 缓存结果</span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);</span><br><span class="line">    // 以下代码省略不影响阅读                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="objc-msgForward-impcache"><a href="#objc-msgForward-impcache" class="headerlink" title="_objc_msgForward_impcache"></a><strong>_objc_msgForward_impcache</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">MESSENGER_START</span><br><span class="line">nop</span><br><span class="line">MESSENGER_END_SLOW</span><br><span class="line"></span><br><span class="line">// No stret specialization.</span><br><span class="line">b	__objc_msgForward</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">adrp	x17, __objc_forward_handler@PAGE</span><br><span class="line">ldr	x17, [x17, __objc_forward_handler@PAGEOFF]</span><br><span class="line">br	x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward</span><br></pre></td></tr></table></figure>
<p><code>_objc_msgForward_impcache</code>用来进行消息转发，但是其真正的核心是调用<code>_objc_msgForward</code>。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>关于<code>_objc_msgForward</code>在<code>objc</code>中并没有其相关实现，只能看到<code>_objc_forward_handler</code>。其实<code>_objc_msgForward</code>的实现是在<code>CFRuntime.c</code>中的，但是开源出来的<code>CFRuntime.c</code>并没有相关实现，但是也不影响我们对真理的追求。</p>
<p>我们做几个实验来验证消息转发。</p>
<h4 id="消息重定向测试"><a href="#消息重定向测试" class="headerlink" title="消息重定向测试"></a>消息重定向测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// .h文件</span><br><span class="line">@interface AObject : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">// .m文件</span><br><span class="line">@implementation AObject</span><br><span class="line"></span><br><span class="line">/** 验证消息重定向 */</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(sendMessage)) &#123;</span><br><span class="line">         return [BObject new];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .h文件</span><br><span class="line">@interface BObject : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .m文件</span><br><span class="line">@implementation BObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage &#123;</span><br><span class="line">    NSLog(@&quot;%@ send message&quot;, self.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">AObject *a = [AObject new];</span><br><span class="line">[a sendMessage];</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-03-12 10:18:54.252949+0800 iOSCodeLearning[18165:5967575] BObject send message</span><br></pre></td></tr></table></figure>
<p>在<code>forwardingTargetForSelector:</code>处打个断点，查看一下调用栈：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/message_redirection.jpg" alt="message_redirection"></p>
<p><code>_CF_forwarding_prep_0</code>和<code>___forwarding___</code>这两个方法会先被调用了，之后调用了<code>forwardingTargetForSelector:</code>。</p>
<h4 id="方法签名测试"><a href="#方法签名测试" class="headerlink" title="方法签名测试"></a>方法签名测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// .h文件</span><br><span class="line">@interface AObject : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">// .m文件</span><br><span class="line">@implementation AObject</span><br><span class="line"></span><br><span class="line">/** 消息重定向 */</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">   return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 方法签名测试 */</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(sendMessage)) &#123;</span><br><span class="line">        return [BObject instanceMethodSignatureForSelector:@selector(sendMessage)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    SEL selector = [anInvocation selector];</span><br><span class="line">    if (selector == @selector(sendMessage)) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:[BObject new]];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .h文件</span><br><span class="line">@interface BObject : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .m文件</span><br><span class="line">@implementation BObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage &#123;</span><br><span class="line">    NSLog(@&quot;%@ send message&quot;, self.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">AObject *a = [AObject new];</span><br><span class="line">[a sendMessage];</span><br></pre></td></tr></table></figure>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/method_signature.jpg" alt="method_signature"></p>
<p>代码执行结果和消息重定向测试的运行结果一致。<code>_CF_forwarding_prep_0</code>和<code>___forwarding___</code>这两个方法又再次被调用了，之后代码会先执行<code>forwardingTargetForSelector:</code>（消息重定向），消息重定向如果失败后调用<code>methodSignatureForSelector:</code>和<code>forwardInvocation:</code>方法签名。所以说<code>___forwarding___</code>方法才是消息转发的真正实现。</p>
<h4 id="crash测试"><a href="#crash测试" class="headerlink" title="crash测试"></a>crash测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// .h文件</span><br><span class="line">@interface AObject : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">// .m文件</span><br><span class="line">@implementation AObject</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 验证Crash */</span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(sendMessage)) &#123;</span><br><span class="line">        NSLog(@&quot;%@ doesNotRecognizeSelector&quot;, self.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .h文件</span><br><span class="line">@interface BObject : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .m文件</span><br><span class="line">@implementation BObject</span><br><span class="line"></span><br><span class="line">- (void)sendMessage &#123;</span><br><span class="line">    NSLog(@&quot;%@ send message&quot;, self.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">AObject *a = [AObject new];</span><br><span class="line">[a sendMessage];</span><br></pre></td></tr></table></figure>
<p>代码运行结果肯定是crash，结合上面的代码我们知道消息转发会调用<code>___forwarding___</code>这个内部方法。<code>___forwarding___</code>方法调用顺序是<code>forwardingTargetForSelector:</code>-&gt;<code>methodSignatureForSelector:</code>-&gt;<code>doesNotRecognizeSelector:</code></p>
<p>我们用一张图表示整个消息发送的过程：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="消息机制流程图"></p>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>我们先查看一下执行<code>[super init]</code>的时候，调用了那些方法<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/super_init.jpg" alt="super_init"></p>
<p><code>objc_msgSendSuper2</code>的声明在<code>objc-abi.h</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// objc_msgSendSuper2() takes the current search class, not its superclass.</span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_msgSendSuper2(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span><br><span class="line">    OBJC_AVAILABLE(10.6, 2.0, 9.0, 1.0, 2.0);</span><br></pre></td></tr></table></figure>
<p><code>objc_super</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_super &#123;</span><br><span class="line">    /// Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line"></span><br><span class="line">    /// Specifies the particular superclass of the instance to message. </span><br><span class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br><span class="line">    /* For compatibility with old objc-runtime.h header */</span><br><span class="line">    __unsafe_unretained _Nonnull Class class;</span><br><span class="line">#else</span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line">#endif</span><br><span class="line">    /* super_class is the first class to search */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的定义我们可以知道<code>receiver</code>即消息的实际接收者，<br><code>super_class</code>为指向当前类的父类。</p>
<p>所以该函数实际的操作是：从<code>objc_super</code>结构体指向的<code>super_class</code>开始查找，直到会找到NSObject的方法为止。找到后以<code>receiver</code>去调用。当然整个查找的过程还是和消息发送的流程一样。</p>
<p>所以我们能理解为什么下面这段代码执行的结果都是<code>AObject</code>了吧。虽然使用<code>[super class]</code>，但是真正执行方法的对象还是<code>AObject</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 代码</span><br><span class="line">@implementation AObject</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, [super class]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [self class]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">2019-03-12 19:44:46.003313+0800 iOSCodeLearning[34431:7234182] AObject</span><br><span class="line">2019-03-12 19:44:46.003442+0800 iOSCodeLearning[34431:7234182] AObject</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native实现一个带筛选功能的搜房列表（1）</title>
    <url>/2019/06/06/React-Native%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B8%A6%E7%AD%9B%E9%80%89%E5%8A%9F%E8%83%BD%E7%9A%84%E6%90%9C%E6%88%BF%E5%88%97%E8%A1%A8%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>最近在写RN项目中需要实现一个带筛选功能的搜房列表，写完这个功能后发现有一些新的心得，在这里写下来跟大家分享一下。</p>
<p>开始之前，我们先看一下最终实现的效果<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/nnhybrid/searchHouse.gif" alt="search_house"></p>
<p>文章中的代码都来自<a href="https://github.com/YiHuaXie/NNHybrid" target="_blank" rel="noopener">代码传送门–NNHybrid</a>。主要集中在<code>SearchHousePage.js</code>、<code>searchHouse.js</code>和<code>FHTFilterMenuManager.m</code>。我会通过<strong>列表下拉刷新和上拉加载更多的实现</strong>、<strong>使用Redux</strong>以及<strong>RN与原生iOS通信</strong>这三方面向大家分享这个页面的开发过程。</p>
<p>首先我们来看一下列表是如何实现的。</p>
<h2 id="如何实现下拉刷新和上拉加载更多"><a href="#如何实现下拉刷新和上拉加载更多" class="headerlink" title="如何实现下拉刷新和上拉加载更多"></a>如何实现下拉刷新和上拉加载更多</h2><p>在移动端的开发过程中，写一个带下拉刷新和上拉加载更多的列表可以说是一个常态。在React Native中我们一般使用FlatList或SectionList组件实现，这里我使用FlatList来实现这个列表。</p>
<p>我们知道FlatList默认是有下拉刷新功能的，但是自定义效果比较差，而且效果也不如iOS中MJRefresh的效果好，另外FlatList没有加载更多的功能，所以需要我们自己去实现下拉刷新和上拉加载更多。在下拉刷新的时候如果出现空数据或者报错，我们可能需要分别实现对应的占位视图。</p>
<p>基于上述要求，我们可以通过改变state中的headerRefreshState的值对头部刷新控件样式进行更改，而通过props中的footerRefreshState的值对底部刷新控件样式进行更改。</p>
<p>根据上面所述，我们可以用下面这张图来描述列表在不同刷新状态时候对应的样式。<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/RefreshState.png" alt="RefreshState"></p>
<h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><h3 id="RefreshConst"><a href="#RefreshConst" class="headerlink" title="RefreshConst"></a>RefreshConst</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 默认刷新控件高度</span><br><span class="line">export const defaultHeight = 60;</span><br><span class="line"></span><br><span class="line">// 下拉刷新状态</span><br><span class="line">export const HeaderRefreshState = &#123;</span><br><span class="line">    Idle: &apos;Idle&apos;, //无刷新的情况</span><br><span class="line">    Pulling: &apos;Pulling&apos;, //松开刷新</span><br><span class="line">    Refreshing: &apos;Refreshing&apos;, //正在刷新</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加载更多状态</span><br><span class="line">export const FooterRefreshState = &#123;</span><br><span class="line">    Idle: &apos;Idle&apos;, //无刷新的情况</span><br><span class="line">    Refreshing: &apos;Refreshing&apos;, //正在刷新</span><br><span class="line">    NoMoreData: &apos;NoMoreData&apos;, //没有更多数据</span><br><span class="line">    EmptyData: &apos;EmptyData&apos;, //空数据</span><br><span class="line">    Failure: &apos;Failure&apos;, //错误提示</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下拉刷新默认props</span><br><span class="line">export const defaultHeaderProps = &#123;</span><br><span class="line">    headerIsRefreshing: false,</span><br><span class="line">    headerHeight: defaultHeight,</span><br><span class="line">    headerIdleText: &apos;下拉可以刷新&apos;,</span><br><span class="line">    headerPullingText: &apos;松开立即刷新&apos;,</span><br><span class="line">    headerRefreshingText: &apos;正在刷新数据中...&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加载更多默认props</span><br><span class="line">export const defaultFooterProps = &#123;</span><br><span class="line">    footerRefreshState: FooterRefreshState.Idle,</span><br><span class="line">    footerHeight: defaultHeight,</span><br><span class="line">    footerRefreshingText: &apos;更多数据加载中...&apos;,</span><br><span class="line">    footerFailureText: &apos;点击重新加载&apos;,</span><br><span class="line">    footerNoMoreDataText: &apos;已加载全部数据&apos;,</span><br><span class="line">    footerEmptyDataText: &apos;暂时没有相关数据&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RefreshFlatList"><a href="#RefreshFlatList" class="headerlink" title="RefreshFlatList"></a>RefreshFlatList</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">    StyleSheet,</span><br><span class="line">    View,</span><br><span class="line">    Text,</span><br><span class="line">    Image,</span><br><span class="line">    FlatList,</span><br><span class="line">    ActivityIndicator,</span><br><span class="line">    Animated,</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line">import &#123; PropTypes &#125; from &apos;prop-types&apos;;</span><br><span class="line">import AppUtil from &apos;../../utils/AppUtil&apos;;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">    HeaderRefreshState,</span><br><span class="line">    FooterRefreshState,</span><br><span class="line">    defaultHeaderProps,</span><br><span class="line">    defaultFooterProps,</span><br><span class="line">&#125; from &apos;./RefreshConst&apos;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 头部刷新组件的箭头或菊花</span><br><span class="line"> */</span><br><span class="line">const headerArrowOrActivity = (headerRefreshState, arrowAnimation) =&gt; &#123;</span><br><span class="line">    if (headerRefreshState == HeaderRefreshState.Refreshing) &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;ActivityIndicator</span><br><span class="line">                style=&#123;&#123; marginRight: 10 &#125;&#125;</span><br><span class="line">                size=&quot;small&quot;</span><br><span class="line">                color=&#123;AppUtil.app_theme&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Animated.Image</span><br><span class="line">                source=&#123;require(&apos;../../resource/images/arrow/refresh_arrow.png&apos;)&#125;</span><br><span class="line">                style=&#123;&#123;</span><br><span class="line">                    width: 20,</span><br><span class="line">                    height: 20,</span><br><span class="line">                    marginRight: 10,</span><br><span class="line">                    transform: [&#123;</span><br><span class="line">                        rotateZ: arrowAnimation.interpolate(&#123;</span><br><span class="line">                            inputRange: [0, 1],</span><br><span class="line">                            outputRange: [&apos;0deg&apos;, &apos;-180deg&apos;]</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;]</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 头部刷新组件的Text组件</span><br><span class="line"> */</span><br><span class="line">const headerTitleComponent = (headerRefreshState, props) =&gt; &#123;</span><br><span class="line">    const &#123; headerIdleText, headerPullingText, headerRefreshingText &#125; = props;</span><br><span class="line"></span><br><span class="line">    let headerTitle = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    switch (headerRefreshState) &#123;</span><br><span class="line">        case HeaderRefreshState.Idle:</span><br><span class="line">            headerTitle = headerIdleText;</span><br><span class="line">            break;</span><br><span class="line">        case HeaderRefreshState.Pulling:</span><br><span class="line">            headerTitle = headerPullingText;</span><br><span class="line">            break;</span><br><span class="line">        case HeaderRefreshState.Refreshing:</span><br><span class="line">            headerTitle = headerRefreshingText;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;Text style=&#123;&#123; fontSize: 13, color: AppUtil.app_theme &#125;&#125;&gt;</span><br><span class="line">            &#123;headerTitle&#125;</span><br><span class="line">        &lt;/Text&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 默认加载更多组件</span><br><span class="line">export const defaultFooterRefreshComponent = (&#123;</span><br><span class="line">    footerRefreshState,</span><br><span class="line">    footerRefreshingText,</span><br><span class="line">    footerFailureText,</span><br><span class="line">    footerNoMoreDataText,</span><br><span class="line">    footerEmptyDataText,</span><br><span class="line">    onHeaderRefresh,</span><br><span class="line">    onFooterRefresh,</span><br><span class="line">    data &#125;) =&gt; &#123;</span><br><span class="line">    switch (footerRefreshState) &#123;</span><br><span class="line">        case FooterRefreshState.Idle:</span><br><span class="line">            return (</span><br><span class="line">                &lt;View style=&#123;styles.footerContainer&#125; /&gt;</span><br><span class="line">            );</span><br><span class="line">        case FooterRefreshState.Refreshing:</span><br><span class="line">            return (</span><br><span class="line">                &lt;View style=&#123;styles.footerContainer&#125; &gt;</span><br><span class="line">                    &lt;ActivityIndicator size=&quot;small&quot; color=&#123;AppUtil.app_theme&#125; /&gt;</span><br><span class="line">                    &lt;Text style=&#123;[styles.footerText, &#123; marginLeft: 7 &#125;]&#125;&gt;</span><br><span class="line">                        &#123;footerRefreshingText&#125;</span><br><span class="line">                    &lt;/Text&gt;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">            );</span><br><span class="line">        case FooterRefreshState.Failure:</span><br><span class="line">            return (</span><br><span class="line">                &lt;TouchableOpacity onPress=&#123;() =&gt; &#123;</span><br><span class="line">                    if (AppUtil.isEmptyArray(data)) &#123;</span><br><span class="line">                        onHeaderRefresh &amp;&amp; onHeaderRefresh();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        onFooterRefresh &amp;&amp; onFooterRefresh();</span><br><span class="line">                    &#125; Î</span><br><span class="line">                &#125;&#125;&gt;</span><br><span class="line">                    &lt;View style=&#123;styles.footerContainer&#125;&gt;</span><br><span class="line">                        &lt;Text style=&#123;styles.footerText&#125;&gt;&#123;footerFailureText&#125;&lt;/Text&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line">                &lt;/TouchableOpacity&gt;</span><br><span class="line">            );</span><br><span class="line">        case FooterRefreshState.EmptyData:</span><br><span class="line">            return (</span><br><span class="line">                &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; onHeaderRefresh &amp;&amp; onHeaderRefresh(); &#125;&#125;&gt;</span><br><span class="line">                    &lt;View style=&#123;styles.footerContainer&#125;&gt;</span><br><span class="line">                        &lt;Text style=&#123;styles.footerText&#125;&gt;&#123;footerEmptyDataText&#125;&lt;/Text&gt;</span><br><span class="line">                    &lt;/View&gt;</span><br><span class="line">                &lt;/TouchableOpacity&gt;</span><br><span class="line">            );</span><br><span class="line">        case FooterRefreshState.NoMoreData:</span><br><span class="line">            return (</span><br><span class="line">                &lt;View style=&#123;styles.footerContainer&#125; &gt;</span><br><span class="line">                    &lt;Text style=&#123;styles.footerText&#125;&gt;&#123;footerNoMoreDataText&#125;&lt;/Text&gt;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class RefreshFlatList extends Component &#123;</span><br><span class="line"></span><br><span class="line">    static propTypes = &#123;</span><br><span class="line">        listRef: PropTypes.any,</span><br><span class="line">        data: PropTypes.array,</span><br><span class="line">        renderItem: PropTypes.func,</span><br><span class="line"></span><br><span class="line">        // Header相关属性</span><br><span class="line">        headerIsRefreshing: PropTypes.bool,</span><br><span class="line"></span><br><span class="line">        headerHeight: PropTypes.number,</span><br><span class="line"></span><br><span class="line">        onHeaderRefresh: PropTypes.func,</span><br><span class="line"></span><br><span class="line">        headerIdleText: PropTypes.string,</span><br><span class="line">        headerPullingText: PropTypes.string,</span><br><span class="line">        headerRefreshingText: PropTypes.string,</span><br><span class="line"></span><br><span class="line">        headerRefreshComponent: PropTypes.func,</span><br><span class="line"></span><br><span class="line">        // Footer相关属性</span><br><span class="line">        footerRefreshState: PropTypes.string,</span><br><span class="line"></span><br><span class="line">        onFooterRefresh: PropTypes.func,</span><br><span class="line"></span><br><span class="line">        footerHeight: PropTypes.number,</span><br><span class="line"></span><br><span class="line">        footerRefreshingText: PropTypes.string,</span><br><span class="line">        footerFailureText: PropTypes.string,</span><br><span class="line">        footerNoMoreDataText: PropTypes.string,</span><br><span class="line">        footerEmptyDataText: PropTypes.string,</span><br><span class="line"></span><br><span class="line">        footerRefreshComponent: PropTypes.func,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    static defaultProps = &#123;</span><br><span class="line">        listRef: &apos;flatList&apos;,</span><br><span class="line">        ...defaultHeaderProps,</span><br><span class="line">        ...defaultFooterProps,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line"></span><br><span class="line">        const &#123; headerHeight, footerHeight &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        this.isDragging = false;</span><br><span class="line">        this.headerHeight = headerHeight;</span><br><span class="line">        this.footerHeight = footerHeight;</span><br><span class="line"></span><br><span class="line">        this.state = &#123;</span><br><span class="line">            arrowAnimation: new Animated.Value(0),</span><br><span class="line">            headerRefreshState: HeaderRefreshState.Idle,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">        const &#123; headerIsRefreshing, listRef &#125; = nextProps;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (headerIsRefreshing !== this.props.headerIsRefreshing) &#123;</span><br><span class="line">            // console.log(&apos;调用一下&apos;+ headerIsRefreshing + this.props.headerIsRefreshing);</span><br><span class="line">            const offset = headerIsRefreshing ? -this.headerHeight : 0;</span><br><span class="line">            const headerRefreshState = headerIsRefreshing ? HeaderRefreshState.Refreshing : HeaderRefreshState.Idle;</span><br><span class="line"></span><br><span class="line">            if (!headerIsRefreshing) this.state.arrowAnimation.setValue(0);</span><br><span class="line"></span><br><span class="line">            this.refs[listRef].scrollToOffset(&#123; animated: true, offset &#125;);</span><br><span class="line">            this.setState(&#123; headerRefreshState &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载下拉刷新组件</span><br><span class="line">     */</span><br><span class="line">    _renderHeader = () =&gt; &#123;</span><br><span class="line">        const &#123; headerRefreshComponent &#125; = this.props;</span><br><span class="line">        const &#123; arrowAnimation, headerRefreshState &#125; = this.state;</span><br><span class="line"></span><br><span class="line">        if (headerRefreshComponent) &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;View style=&#123;&#123; marginTop: -this.headerHeight, height: this.headerHeight &#125;&#125;&gt;</span><br><span class="line">                    &#123;headerRefreshComponent(headerRefreshState)&#125;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;View style=&#123;&#123;</span><br><span class="line">                    alignItems: &apos;center&apos;,</span><br><span class="line">                    justifyContent: &apos;center&apos;,</span><br><span class="line">                    flexDirection: &apos;row&apos;,</span><br><span class="line">                    marginTop: -this.headerHeight,</span><br><span class="line">                    height: this.headerHeight</span><br><span class="line">                &#125;&#125; &gt;</span><br><span class="line">                    &#123;headerArrowOrActivity(headerRefreshState, arrowAnimation)&#125;</span><br><span class="line">                    &#123;headerTitleComponent(headerRefreshState, this.props)&#125;</span><br><span class="line">                &lt;/View &gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载更多组件</span><br><span class="line">     */</span><br><span class="line">    _renderFooter = () =&gt; &#123;</span><br><span class="line">        const &#123;</span><br><span class="line">            footerRefreshState,</span><br><span class="line">            footerRefreshComponent,</span><br><span class="line">        &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        if (footerRefreshComponent) &#123;</span><br><span class="line">            const component = footerRefreshComponent(footerRefreshState);</span><br><span class="line">            if (component) return component;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return defaultFooterRefreshComponent(&#123; ...this.props &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;FlatList</span><br><span class="line">                &#123;...this.props&#125;</span><br><span class="line">                ref=&#123;this.props.listRef&#125;</span><br><span class="line">                onScroll=&#123;event =&gt; this._onScroll(event)&#125;</span><br><span class="line">                onScrollEndDrag=&#123;event =&gt; this._onScrollEndDrag(event)&#125;</span><br><span class="line">                onScrollBeginDrag=&#123;event =&gt; this._onScrollBeginDrag(event)&#125;</span><br><span class="line">                onEndReached=&#123;this._onEndReached&#125;</span><br><span class="line">                ListHeaderComponent=&#123;this._renderHeader&#125;</span><br><span class="line">                ListFooterComponent=&#123;this._renderFooter&#125;</span><br><span class="line">                onEndReachedThreshold=&#123;0.1&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 列表正在滚动</span><br><span class="line">     * @private</span><br><span class="line">     * @param &#123;&#123;&#125;&#125; event </span><br><span class="line">     */</span><br><span class="line">    _onScroll(event) &#123;</span><br><span class="line">        const offsetY = event.nativeEvent.contentOffset.y;</span><br><span class="line">        if (this.isDragging) &#123;</span><br><span class="line">            if (!this._isRefreshing()) &#123;</span><br><span class="line">                if (offsetY &lt;= -this.headerHeight) &#123;</span><br><span class="line">                    // 松开以刷新</span><br><span class="line">                    this.setState(&#123; headerRefreshState: HeaderRefreshState.Pulling &#125;);</span><br><span class="line">                    this.state.arrowAnimation.setValue(1);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 下拉以刷新</span><br><span class="line">                    this.setState(&#123; headerRefreshState: HeaderRefreshState.Idle &#125;);</span><br><span class="line">                    this.state.arrowAnimation.setValue(0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 列表开始拖拽</span><br><span class="line">     * @private</span><br><span class="line">     * @param &#123;&#123;&#125;&#125; event</span><br><span class="line">     */</span><br><span class="line">    _onScrollBeginDrag(event) &#123;</span><br><span class="line">        this.isDragging = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 列表结束拖拽</span><br><span class="line">     * @private</span><br><span class="line">     * @param &#123;&#123;&#125;&#125; event</span><br><span class="line">     */</span><br><span class="line">    _onScrollEndDrag(event) &#123;</span><br><span class="line">        this.isDragging = false;</span><br><span class="line">        const offsetY = event.nativeEvent.contentOffset.y;</span><br><span class="line">        const &#123; listRef, onHeaderRefresh &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        if (!this._isRefreshing()) &#123;</span><br><span class="line">            if (this.state.headerRefreshState === HeaderRefreshState.Pulling) &#123;</span><br><span class="line">                this.refs[listRef].scrollToOffset(&#123; animated: true, offset: -this.headerHeight &#125;);</span><br><span class="line">                this.setState(&#123; headerRefreshState: HeaderRefreshState.Refreshing &#125;);</span><br><span class="line">                onHeaderRefresh &amp;&amp; onHeaderRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (offsetY &lt;= 0) &#123;</span><br><span class="line">                this.refs[listRef].scrollToOffset(&#123; animated: true, offset: -this.headerHeight &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 列表是否正在刷新</span><br><span class="line">     */</span><br><span class="line">    _isRefreshing = () =&gt; &#123;</span><br><span class="line">        return (</span><br><span class="line">            this.state.headerRefreshState === HeaderRefreshState.Refreshing &amp;&amp;</span><br><span class="line">            this.props.footerRefreshState === FooterRefreshState.Refreshing</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 触发加载更多</span><br><span class="line">     */</span><br><span class="line">    _onEndReached = () =&gt; &#123;</span><br><span class="line">        const &#123; onFooterRefresh, data &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        if (!this._isRefreshing() &amp;&amp;</span><br><span class="line">            !AppUtil.isEmptyArray(data) &amp;&amp;</span><br><span class="line">            this.props.footerRefreshState !== FooterRefreshState.NoMoreData) &#123;</span><br><span class="line">            onFooterRefresh &amp;&amp; onFooterRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">    headerContainer: &#123;</span><br><span class="line">        position: &apos;absolute&apos;,</span><br><span class="line">        left: 0,</span><br><span class="line">        right: 0,</span><br><span class="line">    &#125;,</span><br><span class="line">    customHeader: &#123;</span><br><span class="line">        position: &apos;absolute&apos;,</span><br><span class="line">        left: 0,</span><br><span class="line">        right: 0,</span><br><span class="line">    &#125;,</span><br><span class="line">    defaultHeader: &#123;</span><br><span class="line">        position: &apos;absolute&apos;,</span><br><span class="line">        alignItems: &apos;center&apos;,</span><br><span class="line">        justifyContent: &apos;center&apos;,</span><br><span class="line">        flexDirection: &apos;row&apos;,</span><br><span class="line">        left: 0,</span><br><span class="line">        right: 0,</span><br><span class="line">    &#125;,</span><br><span class="line">    footerContainer: &#123;</span><br><span class="line">        flex: 1,</span><br><span class="line">        flexDirection: &apos;row&apos;,</span><br><span class="line">        justifyContent: &apos;center&apos;,</span><br><span class="line">        alignItems: &apos;center&apos;,</span><br><span class="line">        padding: 10,</span><br><span class="line">        height: 60,</span><br><span class="line">    &#125;,</span><br><span class="line">    footerText: &#123;</span><br><span class="line">        fontSize: 14,</span><br><span class="line">        color: AppUtil.app_theme</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="PlaceholderView"><a href="#PlaceholderView" class="headerlink" title="PlaceholderView"></a>PlaceholderView</h3><p><code>PlaceholderView.js</code>用来实现占位图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class PlaceholderView extends Component &#123;</span><br><span class="line"></span><br><span class="line">    static propTypes = &#123;</span><br><span class="line">        height: PropTypes.number,</span><br><span class="line">        imageSource: PropTypes.any,</span><br><span class="line">        tipText: PropTypes.string,</span><br><span class="line">        infoText: PropTypes.string,</span><br><span class="line">        spacing: PropTypes.number,</span><br><span class="line">        needReload: PropTypes.bool,</span><br><span class="line">        reloadHandler: PropTypes.func</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static defaultProps = &#123;</span><br><span class="line">        height: AppUtil.windowHeight,</span><br><span class="line">        hasError: false,</span><br><span class="line">        tipText: &apos;&apos;,</span><br><span class="line">        infoText: &apos;&apos;,</span><br><span class="line">        spacing: 10,</span><br><span class="line">        needReload: false,</span><br><span class="line">        reloadHandler: null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderImage = imageSource =&gt; &#123;</span><br><span class="line">        return imageSource ? (</span><br><span class="line">            &lt;NNImage style=&#123;styles.image&#125; enableAdaptation=&#123;true&#125; source=&#123;imageSource&#125; /&gt;</span><br><span class="line">        ) : null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderTipText = tipText =&gt; &#123;</span><br><span class="line">        return !AppUtil.isEmptyString(tipText) ? (</span><br><span class="line">            &lt;Text style=&#123;styles.tipText&#125;&gt;&#123;tipText&#125;&lt;/Text&gt;</span><br><span class="line">        ) : null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderInfoText = infoText =&gt; &#123;</span><br><span class="line">        return !AppUtil.isEmptyString(infoText) ? (</span><br><span class="line">            &lt;Text style=&#123;styles.infoText&#125;&gt;&#123;infoText&#125;&lt;/Text&gt;</span><br><span class="line">        ) : null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderReloadButton = (needReload, reloadHandler) =&gt; &#123;</span><br><span class="line">        return needReload ? (</span><br><span class="line">            &lt;TouchableOpacity onPress=&#123;() =&gt; &#123;</span><br><span class="line">                if (reloadHandler) &#123;</span><br><span class="line">                    reloadHandler();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;&gt;</span><br><span class="line">                &lt;View style=&#123;styles.reloadButton&#125;&gt;</span><br><span class="line">                    &lt;Text style=&#123;styles.reloadButtonText&#125;&gt;重新加载&lt;/Text&gt;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">            &lt;/TouchableOpacity&gt;</span><br><span class="line">        ) : null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123;</span><br><span class="line">            height,</span><br><span class="line">            imageSource,</span><br><span class="line">            tipText,</span><br><span class="line">            infoText,</span><br><span class="line">            needReload,</span><br><span class="line">            reloadHandler,</span><br><span class="line">        &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;&#123; ...styles.container, height &#125;&#125;&gt;</span><br><span class="line">                &#123;this.renderImage(imageSource)&#125;</span><br><span class="line">                &#123;this.renderTipText(tipText)&#125;</span><br><span class="line">                &#123;this.renderInfoText(infoText)&#125;</span><br><span class="line">                &#123;this.renderReloadButton(needReload, reloadHandler)&#125;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h2><p>在<code>SearchHousePage.js</code>中实现列表，主要代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footerRefreshComponent(footerRefreshState, data) &#123;</span><br><span class="line">    switch (footerRefreshState) &#123;</span><br><span class="line">        // 自定义footerFailureComponent，当有数据的时候返回null，这样列表就会使用默认的footerFailureComponent，否则显示错误占位图</span><br><span class="line">        case FooterRefreshState.Failure: &#123;</span><br><span class="line">            return AppUtil.isEmptyArray(data) ? (</span><br><span class="line">                &lt;PlaceholderView</span><br><span class="line">                    height=&#123;AppUtil.windowHeight - AppUtil.fullNavigationBarHeight - 44&#125;</span><br><span class="line">                    imageSource=&#123;require(&apos;../../resource/images/placeHolder/placeholder_error.png&apos;)&#125;</span><br><span class="line">                    tipText=&apos;出了点小问题&apos;</span><br><span class="line">                    needReload=&#123;true&#125;</span><br><span class="line">                    reloadHandler=&#123;() =&gt; this._loadData(true)&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            ) : null;</span><br><span class="line">        &#125;</span><br><span class="line">        // 空数据占位图的实现</span><br><span class="line">        case FooterRefreshState.EmptyData: &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;PlaceholderView</span><br><span class="line">                    height=&#123;AppUtil.windowHeight - AppUtil.fullNavigationBarHeight - 44&#125;</span><br><span class="line">                    imageSource=&#123;require(&apos;../../resource/images/placeHolder/placeholder_house.png&apos;)&#125;</span><br><span class="line">                    tipText=&apos;真的没了&apos;</span><br><span class="line">                    infoText=&apos;更换筛选条件试试吧&apos;</span><br><span class="line">                /&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 列表的实现</span><br><span class="line">&lt;RefreshFlatList</span><br><span class="line">    ref=&apos;flatList&apos;</span><br><span class="line">    style=&#123;&#123; marginTop: AppUtil.fullNavigationBarHeight + 44 &#125;&#125;</span><br><span class="line">    showsHorizontalScrollIndicator=&#123;false&#125;</span><br><span class="line">    data=&#123;searchHouse.houseList&#125;</span><br><span class="line">    keyExtractor=&#123;item =&gt; `$&#123;item.id&#125;`&#125;</span><br><span class="line">    renderItem=&#123;(&#123; item, index &#125;) =&gt; this._renderHouseCell(item, index)&#125;</span><br><span class="line">    headerIsRefreshing=&#123;searchHouse.headerIsRefreshing&#125;</span><br><span class="line">    footerRefreshState=&#123;searchHouse.footerRefreshState&#125;</span><br><span class="line">    onHeaderRefresh=&#123;() =&gt; this._loadData(true)&#125;</span><br><span class="line">    onFooterRefresh=&#123;() =&gt; this._loadData(false)&#125;</span><br><span class="line">    footerRefreshComponent=&#123;footerRefreshState =&gt; this.footerRefreshComponent(footerRefreshState, searchHouse.houseList)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="各状态对应的效果图"><a href="#各状态对应的效果图" class="headerlink" title="各状态对应的效果图"></a>各状态对应的效果图</h3><p><strong>NoMoreData</strong></p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/RefreshStateNoMoreData.jpg" alt="RefreshStateNoMoreData"></p>
<p><strong>列表无数据时的Failure</strong></p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/RefreshFailurePlaceholder.jpg" alt="RefreshFailurePlaceholder"></p>
<p><strong>列表有数据时的Failure</strong></p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/RefreshStateFailure.jpg" alt="RefreshStateFailure"></p>
<p><strong>EmptyData</strong></p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/RefreshEmptyPlaceholder.jpg" alt="RefreshEmptyPlaceholder"></p>
<h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p>到这里，我们已经完成了一个带下拉刷新和上拉加载更多的列表，并且实现了空数据占位。接着就是介绍数据的加载，在<a href="https://www.neroxie.com/2019/06/06/React-Native%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B8%A6%E7%AD%9B%E9%80%89%E5%8A%9F%E8%83%BD%E7%9A%84%E6%90%9C%E6%88%BF%E5%88%97%E8%A1%A8%EF%BC%882%EF%BC%89/">React Native实现一个带筛选功能的搜房列表（2）</a>中我会介绍如何使用redux进行数据的加载。另外上面提供的代码均是从项目当中截取的，如果需要查看完整代码的话，在<a href="https://github.com/YiHuaXie/NNHybrid" target="_blank" rel="noopener">代码传送门–NNHybrid</a>中。</p>
<p>相关代码路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RefreshFlatList: /NNHybridRN/components/refresh/RefreshFlatList.js</span><br><span class="line"></span><br><span class="line">RefreshConst: /NNHybridRN/components/refresh/RefreshConst.js</span><br><span class="line"></span><br><span class="line">PlaceholderView: /NNHybridRN/components/common/PlaceholderView.js</span><br><span class="line"></span><br><span class="line">SearchHousePage: /NNHybridRN/sections/searchHouse/SearchHousePage.js</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NNHybrid</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native实现一个带筛选功能的搜房列表（2）</title>
    <url>/2019/06/06/React-Native%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B8%A6%E7%AD%9B%E9%80%89%E5%8A%9F%E8%83%BD%E7%9A%84%E6%90%9C%E6%88%BF%E5%88%97%E8%A1%A8%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p>在<a href="https://www.neroxie.com/2019/06/06/React-Native%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B8%A6%E7%AD%9B%E9%80%89%E5%8A%9F%E8%83%BD%E7%9A%84%E6%90%9C%E6%88%BF%E5%88%97%E8%A1%A8%EF%BC%881%EF%BC%89/">上一篇</a>中，我们实现了一个下拉刷新和上拉加载更多的列表，那根据一般的开发步骤，接着应该就是进行网络请求，在网络请求之后更新列表数据和列表的刷新状态。</p>
<p>这篇文章会向大家介绍一下Redux的基本概念以及在页面中如何使用Redux进行状态管理。</p>
<p>文章中的代码都来自<a href="https://github.com/YiHuaXie/NNHybrid" target="_blank" rel="noopener">代码传送门–NNHybrid</a>。开始之前，我们先看一下最终实现的效果<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/nnhybrid/searchHouse.gif" alt="search_house"></p>
<h2 id="Redux概念"><a href="#Redux概念" class="headerlink" title="Redux概念"></a>Redux概念</h2><p>首先先简单介绍一下Redux的一些概念。Redux是JavaScript状态容器，提供可预测化的状态管理，其工作流程如下：</p>
<p>整个工作流程为：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/nnhybrid/reduxProcess.png" alt="reduxProcess"></p>
<ol>
<li>View需要订阅Store中的state；</li>
<li>操作View（点击了View上的一个按钮或者执行一个网络请求），发出Action；</li>
<li>Store自动调用Reducer，并且传入两个参数(Old State和Action)，Reducer会返回新的State，如果有Middleware，Store会将Old State和Action传递给Middleware，Middleware会调用Reducer 然后返回新的State；</li>
<li>State一旦有变化，Store就会调用监听函数，来更新View；</li>
</ol>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store是存储state的容器，负责提供所有的状态。整个应用只能有一个Store，这么做的目的是为了让组件之间的通信更加简单。</p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/nnhybrid/reduxCommunication.jpg" alt="reduxCommunication"></p>
<p>在没有Store的情况下，组件之间需要通信就比较麻烦，如果一个父组件要将状态传递到子组件，就需要通过props一层一层往下传，一个子组件的状态发生改变并且要让父组件知道，则必须暴露一个事件出去才能通信。这就使得组件之间通信依赖于组件的层次结构。此时如果有两个平级的节点想要通信，就需要通过它们的父组件进行中转。<br>有了这个全局的Store之后，所有的组件变成了和Store进行通信。这样组件之间通信就会变少，当Store发生变化，对应的组件也能拿到相关的数据。当组件内部有时间触发Store的变化时，更新Store即可。这也就是所谓的单向数据流过程。</p>
<p>Store的职责如下：</p>
<ul>
<li>维持应用的state；</li>
<li>提供<code>getState()</code>方法获取state；</li>
<li>提供<code>dispatch(action)</code>方法更新state；</li>
<li>通过<code>subscribe(listener)</code>注册监听器；</li>
<li>通过<code>subscribe(listener)</code>返回的函数注销监听器。</li>
</ul>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>当我们想要更改store中的state时，我们便需要使用Action。Action是Store数据的唯一来源，每一次修改state便要发起一次Action。</p>
<p>Action可以理解为是一个Javascript对象。其内部必须包含一个<code>type</code>字段来表示将要执行的动作，除了 <code>type</code>字段外，Action的结构完全由自己决定。多数情况下，<code>type</code>字段会被定义成字符串常量。</p>
<p>Action举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: Types.SEARCH_HOUSE_LOAD_DATA_SUCCESS,</span><br><span class="line">    currentPage: ++currentPage,</span><br><span class="line">    houseList,</span><br><span class="line">    hasMoreData,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Action创建函数"><a href="#Action创建函数" class="headerlink" title="Action创建函数"></a>Action创建函数</h3><p>Action创建函数就是生成action的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。</p>
<p>Action创建函数举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function init(storeName) &#123;</span><br><span class="line">    return dispatch =&gt; &#123;</span><br><span class="line">        dispatch(&#123; type: Types.HOUSE_DETAIL_INIT, storeName &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>Store收到Action以后，必须给出一个新的State，这样View才会发生变化。<br>这种State的计算过程就叫做Reducer。Reducer是一个纯函数，它只接受Action和当前State作为参数，返回一个新的State。</p>
<p>由于Reducer是一个纯函数，所以我们不能在reducer里执行以下操作：</p>
<ul>
<li>修改传入的参数；</li>
<li>执行有副作用的操作；</li>
<li>调用非纯函数；</li>
<li>不要修改state；</li>
<li>遇到未知的action时，一定要返回旧的state；</li>
</ul>
<p>Reducer举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const defaultState = &#123;</span><br><span class="line">    locationCityName: &apos;&apos;,</span><br><span class="line">    visitedCities: [],</span><br><span class="line">    hotCities: [],</span><br><span class="line">    sectionCityData: [],</span><br><span class="line">    sectionTitles: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export function cityListReducer(state = defaultState, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case Types.CITY_LIST_LOAD_DATA:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                visitedCities: action.visitedCities,</span><br><span class="line">                hotCities: action.hotCities,</span><br><span class="line">                sectionCityData: action.sectionCityData,</span><br><span class="line">                sectionTitles: action.sectionTitles,</span><br><span class="line">            &#125;</span><br><span class="line">        case Types.CITY_LIST_START_LOCATION:</span><br><span class="line">        case Types.CITY_LIST_LOCATION_FINISHED:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                locationCityName: action.locationCityName</span><br><span class="line">            &#125;;</span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拆分与合并reducer"><a href="#拆分与合并reducer" class="headerlink" title="拆分与合并reducer"></a>拆分与合并reducer</h3><p>在开发过程中，由于有的功能是相互独立的，所以我们需要拆分reducer。一般情况下，针对一个页面可以设置一个reducer。但redux原则是只允许一个根reducer，接下来我们需要将每个页面的的reducer聚合到一个根reducer中。</p>
<p>合并reducer代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const appReducers = combineReducers(&#123;</span><br><span class="line">    nav: navReducer,</span><br><span class="line">    home: homeReducer,</span><br><span class="line">    cityList: cityListReducer,</span><br><span class="line">    apartments: apartmentReducer,</span><br><span class="line">    houseDetails: houseDetailReducer,</span><br><span class="line">    searchHouse: searchHouseReducer,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default (state, action) =&gt; &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case Types.APARTMENT_WILL_UNMOUNT:</span><br><span class="line">            delete state.apartments[action.storeName];</span><br><span class="line">            break;</span><br><span class="line">        case Types.HOUSE_DETAIL_WILL_UNMOUNT:</span><br><span class="line">            delete state.houseDetails[action.storeName];</span><br><span class="line">            break;</span><br><span class="line">        case Types.SEARCH_HOUSE_WILL_UNMOUNT:</span><br><span class="line">                delete state.searchHouse;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return appReducers(state, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SearchHousePage使用Redux"><a href="#SearchHousePage使用Redux" class="headerlink" title="SearchHousePage使用Redux"></a>SearchHousePage使用Redux</h2><h3 id="Action类型定义"><a href="#Action类型定义" class="headerlink" title="Action类型定义"></a>Action类型定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SEARCH_HOUSE_LOAD_DATA: &apos;SEARCH_HOUSE_LOAD_DATA&apos;,</span><br><span class="line">SEARCH_HOUSE_LOAD_MORE_DATA: &apos;SEARCH_HOUSE_LOAD_MORE_DATA&apos;,</span><br><span class="line">SEARCH_HOUSE_LOAD_DATA_SUCCESS: &apos;SEARCH_HOUSE_LOAD_DATA_SUCCESS&apos;,</span><br><span class="line">SEARCH_HOUSE_LOAD_DATA_FAIL: &apos;SEARCH_HOUSE_LOAD_DATA_FAIL&apos;,</span><br><span class="line">SEARCH_HOUSE_WILL_UNMOUNT: &apos;SEARCH_HOUSE_WILL_UNMOUNT&apos;,</span><br></pre></td></tr></table></figure>
<h3 id="Action创建函数-1"><a href="#Action创建函数-1" class="headerlink" title="Action创建函数"></a>Action创建函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function loadData(params, currentPage, errorCallBack) &#123;</span><br><span class="line">    return dispatch =&gt; &#123;</span><br><span class="line">        dispatch(&#123; type: currentPage == 1 ? Types.SEARCH_HOUSE_LOAD_DATA : Types.SEARCH_HOUSE_LOAD_MORE_DATA &#125;);</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            Network</span><br><span class="line">                .my_request(&#123;</span><br><span class="line">                    apiPath: ApiPath.SEARCH,</span><br><span class="line">                    apiMethod: &apos;searchByPage&apos;,</span><br><span class="line">                    apiVersion: &apos;1.0&apos;,</span><br><span class="line">                    params: &#123;</span><br><span class="line">                        ...params,</span><br><span class="line">                        pageNo: currentPage,</span><br><span class="line">                        pageSize: 10</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .then(response =&gt; &#123;</span><br><span class="line">                    const tmpResponse = AppUtil.makeSureObject(response);</span><br><span class="line">                    const hasMoreData = currentPage &lt; tmpResponse.totalPages;</span><br><span class="line">                    const houseList = AppUtil.makeSureArray(tmpResponse.resultList);</span><br><span class="line">                    dispatch(&#123;</span><br><span class="line">                        type: Types.SEARCH_HOUSE_LOAD_DATA_SUCCESS,</span><br><span class="line">                        currentPage: ++currentPage,</span><br><span class="line">                        houseList,</span><br><span class="line">                        hasMoreData,</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;)</span><br><span class="line">                .catch(error =&gt; &#123;</span><br><span class="line">                    if (errorCallBack) errorCallBack(error.message);</span><br><span class="line"></span><br><span class="line">                    const action = &#123; type: Types.SEARCH_HOUSE_LOAD_DATA_FAIL &#125;;</span><br><span class="line">                    if (currentPage == 1) &#123;</span><br><span class="line">                        action.houseList = []</span><br><span class="line">                        action.currentPage = 1;</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    dispatch(action);</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;, 300);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建reducer"><a href="#创建reducer" class="headerlink" title="创建reducer"></a>创建reducer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 默认的state</span><br><span class="line">const defaultState = &#123;</span><br><span class="line">    houseList: [],</span><br><span class="line">    headerIsRefreshing: false,</span><br><span class="line">    footerRefreshState: FooterRefreshState.Idle,</span><br><span class="line">    currentPage: 1,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function searchHouseReducer(state = defaultState, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case Types.SEARCH_HOUSE_LOAD_DATA: &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                headerIsRefreshing: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        case Types.SEARCH_HOUSE_LOAD_MORE_DATA: &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                footerRefreshState: FooterRefreshState.Refreshing,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        case Types.SEARCH_HOUSE_LOAD_DATA_FAIL: &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                headerIsRefreshing: false,</span><br><span class="line">                footerRefreshState: FooterRefreshState.Failure,</span><br><span class="line">                houseList: action.houseList ? action.houseList : state.houseList,</span><br><span class="line">                currentPage: action.currentPage,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        case Types.SEARCH_HOUSE_LOAD_DATA_SUCCESS: &#123;</span><br><span class="line">            const houseList = action.currentPage &lt;= 2 ? action.houseList : state.houseList.concat(action.houseList);</span><br><span class="line"></span><br><span class="line">            let footerRefreshState = FooterRefreshState.Idle;</span><br><span class="line">            if (AppUtil.isEmptyArray(houseList)) &#123;</span><br><span class="line">                footerRefreshState = FooterRefreshState.EmptyData;</span><br><span class="line">            &#125; else if (!action.hasMoreData) &#123;</span><br><span class="line">                footerRefreshState = FooterRefreshState.NoMoreData;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                houseList,</span><br><span class="line">                currentPage: action.currentPage,</span><br><span class="line">                headerIsRefreshing: false,</span><br><span class="line">                footerRefreshState,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包装组件"><a href="#包装组件" class="headerlink" title="包装组件"></a>包装组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SearchHousePage extends Component &#123;</span><br><span class="line"></span><br><span class="line">    // ...代码省略</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        this._loadData(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        NavigationUtil.dispatch(Types.SEARCH_HOUSE_WILL_UNMOUNT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _loadData(isRefresh) &#123;</span><br><span class="line">        const &#123; loadData, searchHouse &#125; = this.props;</span><br><span class="line">        const currentPage = isRefresh ? 1 : searchHouse.currentPage;</span><br><span class="line"></span><br><span class="line">        loadData(this.filterParams, currentPage, error =&gt; Toaster.autoDisapperShow(error));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; home, searchHouse &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;styles.container&#125; ref=&apos;container&apos;&gt;</span><br><span class="line">                &lt;RefreshFlatList</span><br><span class="line">                    ref=&apos;flatList&apos;</span><br><span class="line">                    style=&#123;&#123; marginTop: AppUtil.fullNavigationBarHeight + 44 &#125;&#125;</span><br><span class="line">                    showsHorizontalScrollIndicator=&#123;false&#125;</span><br><span class="line">                    data=&#123;searchHouse.houseList&#125;</span><br><span class="line">                    keyExtractor=&#123;item =&gt; `$&#123;item.id&#125;`&#125;</span><br><span class="line">                    renderItem=&#123;(&#123; item, index &#125;) =&gt; this._renderHouseCell(item, index)&#125;</span><br><span class="line">                    headerIsRefreshing=&#123;searchHouse.headerIsRefreshing&#125;</span><br><span class="line">                    footerRefreshState=&#123;searchHouse.footerRefreshState&#125;</span><br><span class="line">                    onHeaderRefresh=&#123;() =&gt; this._loadData(true)&#125;</span><br><span class="line">                    onFooterRefresh=&#123;() =&gt; this._loadData(false)&#125;</span><br><span class="line">                    footerRefreshComponent=&#123;footerRefreshState =&gt; this.footerRefreshComponent(footerRefreshState, searchHouse.houseList)&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;NavigationBar</span><br><span class="line">                    navBarStyle=&#123;&#123; position: &apos;absolute&apos; &#125;&#125;</span><br><span class="line">                    backOrCloseHandler=&#123;() =&gt; NavigationUtil.goBack()&#125;</span><br><span class="line">                    title=&apos;搜房&apos;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;SearchFilterMenu</span><br><span class="line">                    style=&#123;styles.filterMenu&#125;</span><br><span class="line">                    cityId=&#123;`$&#123;home.cityId&#125;`&#125;</span><br><span class="line">                    subwayData=&#123;home.subwayData&#125;</span><br><span class="line">                    containerRef=&#123;this.refs.container&#125;</span><br><span class="line">                    filterMenuType=&#123;this.params.filterMenuType&#125;</span><br><span class="line">                    onChangeParameters=&#123;() =&gt; this._loadData(true)&#125;</span><br><span class="line">                    onUpdateParameters=&#123;(&#123; nativeEvent: &#123; filterParams &#125; &#125;) =&gt; &#123;</span><br><span class="line">                        this.filterParams = &#123;</span><br><span class="line">                            ...this.filterParams,</span><br><span class="line">                            ...filterParams,</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapStateToProps = state =&gt; (&#123; home: state.home, searchHouse: state.searchHouse &#125;);</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps = dispatch =&gt; (&#123;</span><br><span class="line">    loadData: (params, currentPage, errorCallBack) =&gt;</span><br><span class="line">        dispatch(loadData(params, currentPage, errorCallBack)),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(SearchHousePage);</span><br></pre></td></tr></table></figure>
<p>从上面的代码使用了一个<code>connect</code>函数，<code>connect</code>连接React组件与Redux store，连接操作会返回一个新的与Redux store连接的组件类，并且连接操作不会改变原来的组件类。</p>
<p><code>mapStateToProps</code>中订阅了home节点和searchHouse节点，该页面主要使用searchHouse节点，那订阅home节点是用来方便组件间通信，这样页面进行网络请求所需的cityId，就不需要从前以页面传入，也不需要从缓存中读取。</p>
<p>列表的刷新状态由<code>headerIsRefreshing</code>和<code>footerRefreshState</code>进行管理。</p>
<h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><p>redux已经帮我们完成了页面的状态管理，再总结一下Redux需要注意的点：</p>
<ul>
<li>Redux应用只有一个单一的Store。当需要拆分数据处理逻辑时，你应该使用拆分与合并reducer而不是创建多个Store；</li>
<li>redux一个特点是：状态共享，所有的状态都放在一个Store中，任何组件都可以订阅Store中的数据，但是不建议组件订阅过多Store中的节点；</li>
<li>不要将所有的State都适合放在Store中，这样会让Store变得非常庞大；</li>
</ul>
<p>到这里，我们实现了列表的下拉刷新、加载更多以及如何使用redux，还差一个筛选栏和子菜单页面的开发，这里涉及到React Native与原生之间的通信，我会在<a href="https://www.neroxie.com/2019/06/06/React-Native%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B8%A6%E7%AD%9B%E9%80%89%E5%8A%9F%E8%83%BD%E7%9A%84%E6%90%9C%E6%88%BF%E5%88%97%E8%A1%A8%EF%BC%883%EF%BC%89/">React Native实现一个带筛选功能的搜房列表（3）</a>中分享下如何进行React Native与原生的桥接开发。</p>
<p>另外上面提供的代码均是从项目当中截取的，如果需要查看完整代码的话，在<a href="https://github.com/YiHuaXie/NNHybrid" target="_blank" rel="noopener">代码传送门–NNHybrid</a>中。</p>
<p>上述相关代码路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redux文件夹: /NNHybridRN/redux</span><br><span class="line"></span><br><span class="line">SearchHousePage: /NNHybridRN/sections/searchHouse/SearchHousePage.js</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<p><a href="https://www.redux.org.cn/" target="_blank" rel="noopener">Redux 中文文档</a></p>
]]></content>
      <categories>
        <category>NNHybrid</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native实现一个带筛选功能的搜房列表（3）</title>
    <url>/2019/06/06/React-Native%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B8%A6%E7%AD%9B%E9%80%89%E5%8A%9F%E8%83%BD%E7%9A%84%E6%90%9C%E6%88%BF%E5%88%97%E8%A1%A8%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<p>在前两篇文章中已经介绍了如何实现一个支持下拉刷新和上拉加载更多的列表以及如何使用Redux进行单向数据流，那这篇就会介绍下最后一个模块筛选功能的开发即React Native与原生iOS的通信。</p>
<p>开始之前，还是先看一下最终实现的效果<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/nnhybrid/searchHouse.gif" alt="search_house"></p>
<p><a href="https://github.com/YiHuaXie/NNHybrid" target="_blank" rel="noopener">代码传送门–NNHybrid</a></p>
<p>关于如何进行React Native与原生iOS的通信，在官网中有很明确的教程，这里我就不细说了。我分享的主要是如何利用那些接口实现这样的一个效果。</p>
<p>在项目中，筛选条和对应的子菜单都是使用原生代码实现的，而列表使用js代码实现的。我们要做的就是将这些原生页面通过桥接的方式添加到js页面上。</p>
<p>桥接实现在<code>FHTFilterMenuManager</code>这个类中，其实现如下：</p>
<ul>
<li>原生实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// .h</span><br><span class="line">#import &lt;React/RCTViewManager.h&gt;</span><br><span class="line">#import &quot;FHTFilterMenu.h&quot;</span><br><span class="line"></span><br><span class="line">@interface FHTFilterMenu (RNBridge)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) RCTBubblingEventBlock onUpdateParameters;</span><br><span class="line">@property (nonatomic, copy) RCTBubblingEventBlock onChangeParameters;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface RCTConvert (FHTFilterMenu)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface FHTFilterMenuManager : RCTViewManager &lt;RCTBridgeModule&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// .m</span><br><span class="line">#import &quot;FHTFilterMenuManager.h&quot;</span><br><span class="line">#import &lt;React/RCTUIManager.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">#import &quot;FilterMenuRentTypeController.h&quot;</span><br><span class="line">#import &quot;FilterMenuGeographicController.h&quot;</span><br><span class="line">#import &quot;FilterMenuOrderByController.h&quot;</span><br><span class="line">#import &quot;FilterMenuMoreController.h&quot;</span><br><span class="line">#import &quot;FilterMenuRentalController.h&quot;</span><br><span class="line"></span><br><span class="line">static ConstString kFilterParams = @&quot;filterParams&quot;;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, FilterMenuType) &#123;</span><br><span class="line">    FilterMenuTypeNone,</span><br><span class="line">    FilterMenuTypeEntireRent,    //整租</span><br><span class="line">    FilterMenuTypeSharedRent,    //合租</span><br><span class="line">    FilterMenuTypeApartment,     //独栋公寓</span><br><span class="line">    FilterMenuTypeBelowThousand, //千元房源</span><br><span class="line">    FilterMenuTypePayMonthly,    //月付</span><br><span class="line">    FilterMenuTypeVR,            //VR</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@implementation RCTConvert (FHTFilterMenu)</span><br><span class="line"></span><br><span class="line">RCT_ENUM_CONVERTER(FilterMenuType,</span><br><span class="line">                   (@&#123;@&quot;None&quot;: @(FilterMenuTypeNone),</span><br><span class="line">                      @&quot;EntireRent&quot;: @(FilterMenuTypeEntireRent),</span><br><span class="line">                      @&quot;SharedRent&quot;: @(FilterMenuTypeSharedRent),</span><br><span class="line">                      @&quot;Apartment&quot;: @(FilterMenuTypeApartment),</span><br><span class="line">                      @&quot;BelowThousand&quot;: @(FilterMenuTypeBelowThousand),</span><br><span class="line">                      @&quot;PayMonthly&quot;: @(FilterMenuTypePayMonthly),</span><br><span class="line">                      @&quot;VR&quot;:@(FilterMenuTypeVR)&#125;),</span><br><span class="line">                   FilterMenuTypeNone,</span><br><span class="line">                   integerValue);</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FHTFilterMenu (RNBridge)</span><br><span class="line"></span><br><span class="line">#pragma mark - Setter &amp; Getter</span><br><span class="line"></span><br><span class="line">- (void)setOnUpdateParameters:(RCTBubblingEventBlock)onUpdateParameters &#123;</span><br><span class="line">    objc_setAssociatedObject(self,</span><br><span class="line">                             @selector(onUpdateParameters),</span><br><span class="line">                             onUpdateParameters,</span><br><span class="line">                             OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RCTBubblingEventBlock)onUpdateParameters &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, @selector(onUpdateParameters));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setOnChangeParameters:(RCTBubblingEventBlock)onChangeParameters &#123;</span><br><span class="line">    objc_setAssociatedObject(self,</span><br><span class="line">                             @selector(onChangeParameters),</span><br><span class="line">                             onChangeParameters,</span><br><span class="line">                             OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RCTBubblingEventBlock)onChangeParameters &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, @selector(onChangeParameters));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFilterMenuType:(FilterMenuType)filterMenuType &#123;</span><br><span class="line">    switch (filterMenuType) &#123;</span><br><span class="line">        case FilterMenuTypeEntireRent: &#123;</span><br><span class="line">            UIViewController *vc = (UIViewController *)self.filterControllers[0];</span><br><span class="line">            [vc presetWithOptionTitles:@[@&quot;整租&quot;]];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case FilterMenuTypeSharedRent: &#123;</span><br><span class="line">            UIViewController *vc = (UIViewController *)self.filterControllers[0];</span><br><span class="line">            [vc presetWithOptionTitles:@[@&quot;合租&quot;]];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case FilterMenuTypeApartment: &#123;</span><br><span class="line">            UIViewController *vc = (UIViewController *)self.filterControllers[3];</span><br><span class="line">            [vc presetWithOptionTitles:@[@&quot;房源类型/独栋公寓&quot;]];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case FilterMenuTypeBelowThousand: &#123;</span><br><span class="line">            UIViewController *vc = (UIViewController *)self.filterControllers[2];</span><br><span class="line">            [vc presetWithOptionTitles:@[@&quot;1500以下&quot;]];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case FilterMenuTypePayMonthly: &#123;</span><br><span class="line">            UIViewController *vc = (UIViewController *)self.filterControllers[3];</span><br><span class="line">            [vc presetWithOptionTitles:@[@&quot;房源亮点/月付&quot;]];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case FilterMenuTypeVR: &#123;</span><br><span class="line">            UIViewController *vc = (UIViewController *)self.filterControllers[3];</span><br><span class="line">            [vc presetWithOptionTitles:@[@&quot;房源亮点/VR&quot;]];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FHTFilterMenuManager</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_MODULE();</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_VIEW_PROPERTY(onUpdateParameters, RCTBubblingEventBlock);</span><br><span class="line">RCT_EXPORT_VIEW_PROPERTY(onChangeParameters, RCTBubblingEventBlock);</span><br><span class="line">RCT_EXPORT_VIEW_PROPERTY(filterMenuType, FilterMenuType);</span><br><span class="line"></span><br><span class="line">RCT_CUSTOM_VIEW_PROPERTY(cityId, NSString, FHTFilterMenu) &#123;</span><br><span class="line">    FilterMenuGeographicController *vc = view.filterControllers[1];</span><br><span class="line">    vc.cityId = (NSString *)json;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RCT_CUSTOM_VIEW_PROPERTY(subwayData, NSArray, FHTFilterMenu) &#123;</span><br><span class="line">    FilterMenuGeographicController *vc = view.filterControllers[1];</span><br><span class="line">    vc.originalSubwayData = (NSArray *)json;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(showFilterMenuOnView:(nonnull NSNumber *)containerTag filterMenuTag:(nonnull NSNumber *)filterMenuTag) &#123;</span><br><span class="line">    RCTUIManager *uiManager = self.bridge.uiManager;</span><br><span class="line">    dispatch_async(uiManager.methodQueue, ^&#123;</span><br><span class="line">        [uiManager addUIBlock:^(RCTUIManager *uiManager, NSDictionary&lt;NSNumber *,UIView *&gt; *viewRegistry) &#123;</span><br><span class="line">            UIView *view = viewRegistry[containerTag];</span><br><span class="line">            FHTFilterMenu *filterMenu = (FHTFilterMenu *)viewRegistry[filterMenuTag];</span><br><span class="line">            [filterMenu showFilterMenuOnView:view];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (dispatch_queue_t)methodQueue &#123;</span><br><span class="line">    return dispatch_get_main_queue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)view &#123;</span><br><span class="line">    FilterMenuRentTypeController *rentTypeVC =</span><br><span class="line">    [[FilterMenuRentTypeController alloc] initWithStyle:UITableViewStylePlain];</span><br><span class="line">    FilterMenuGeographicController *geographicVC = [FilterMenuGeographicController new];</span><br><span class="line">    FilterMenuRentalController *rentalVC =</span><br><span class="line">    [[FilterMenuRentalController alloc] initWithStyle:UITableViewStylePlain];</span><br><span class="line">    FilterMenuMoreController *moreVC = [FilterMenuMoreController new];</span><br><span class="line">    FilterMenuOrderByController *orderByVC =</span><br><span class="line">    [[FilterMenuOrderByController alloc] initWithStyle:UITableViewStylePlain];</span><br><span class="line">    </span><br><span class="line">    CGRect frame = CGRectMake(0, FULL_NAVIGATION_BAR_HEIGHT, SCREEN_WIDTH, 44);</span><br><span class="line">    FHTFilterMenu *filterMenu = [[FHTFilterMenu alloc] initWithFrame:frame];</span><br><span class="line">    filterMenu.filterControllers = @[rentTypeVC, geographicVC, rentalVC, moreVC, orderByVC];</span><br><span class="line">    [filterMenu dismissSubmenu:NO];</span><br><span class="line">    [filterMenu resetFilter];</span><br><span class="line">    </span><br><span class="line">    [rentTypeVC presetWithOptionTitles:@[]];</span><br><span class="line">    __weak FHTFilterMenu *weakFilterMenu = filterMenu;</span><br><span class="line"></span><br><span class="line">    rentTypeVC.didSetFilterHandler = ^(NSDictionary * _Nonnull params) &#123;</span><br><span class="line">        BLOCK_EXEC(weakFilterMenu.onUpdateParameters, @&#123;kFilterParams: params&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    geographicVC.didSetFilterHandler = ^(NSDictionary * _Nonnull params) &#123;</span><br><span class="line">        NSMutableDictionary *tmpParams = [@&#123;@&quot;regionId&quot;: nn_makeSureString(params[@&quot;regionId&quot;]),</span><br><span class="line">                                            @&quot;zoneIds&quot;: nn_makeSureArray(params[@&quot;zoneIds&quot;]),</span><br><span class="line">                                            @&quot;subwayRouteId&quot;: nn_makeSureString(params[@&quot;subwayRouteId&quot;]),</span><br><span class="line">                                            @&quot;subwayStationCodes&quot;: nn_makeSureArray(params[@&quot;subwayStationCodes&quot;])&#125; mutableCopy];</span><br><span class="line">        </span><br><span class="line">        BLOCK_EXEC(weakFilterMenu.onUpdateParameters, @&#123;kFilterParams: [tmpParams copy]&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    rentalVC.didSetFilterHandler = ^(NSDictionary * _Nonnull params) &#123;</span><br><span class="line">        NSDictionary *tmpParams = @&#123;@&quot;minPrice&quot;: nn_makeSureString(params[@&quot;minPrice&quot;]),</span><br><span class="line">                                    @&quot;maxPrice&quot;: nn_makeSureString(params[@&quot;maxPrice&quot;])&#125;;</span><br><span class="line">        BLOCK_EXEC(weakFilterMenu.onUpdateParameters, @&#123;kFilterParams: tmpParams&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    moreVC.didSetFilterHandler = ^(NSDictionary * _Nonnull params) &#123;</span><br><span class="line">        NSArray *typeArray = params[@&quot;typeArray&quot;];</span><br><span class="line">        NSString *type = typeArray.count == 1 ? (typeArray.lastObject)[@&quot;type&quot;] : @&quot;&quot;;</span><br><span class="line">        </span><br><span class="line">        NSDictionary *tmpParams = @&#123;@&quot;roomAttributeTags&quot;: params[@&quot;highlightArray&quot;],</span><br><span class="line">                                    @&quot;chamberCounts&quot;: params[@&quot;chamberArray&quot;],</span><br><span class="line">                                    @&quot;type&quot;: type&#125;;</span><br><span class="line">        </span><br><span class="line">        BLOCK_EXEC(weakFilterMenu.onUpdateParameters, @&#123;kFilterParams: tmpParams&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    orderByVC.didSetFilterHandler = ^(NSDictionary * _Nonnull params) &#123;</span><br><span class="line">        BLOCK_EXEC(weakFilterMenu.onUpdateParameters, @&#123;kFilterParams: params&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    filterMenu.filterDidChangedHandler = ^(FHTFilterMenu * _Nonnull filterMenu, id&lt;FHTFilterController&gt;  _Nonnull filterController) &#123;</span><br><span class="line">        BLOCK_EXEC(weakFilterMenu.onChangeParameters, nil);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    return filterMenu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>JS实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; requireNativeComponent, NativeModules, findNodeHandle &#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">const FilterMenu = requireNativeComponent(&apos;FHTFilterMenu&apos;, SearchFilterMenu);</span><br><span class="line">const filterMenuManager = NativeModules.FHTFilterMenuManager;</span><br><span class="line"></span><br><span class="line">export const FilterMenuType = &#123;</span><br><span class="line">    NONE: &apos;None&apos;,</span><br><span class="line">    ENTIRERENT: &apos;EntireRent&apos;,</span><br><span class="line">    SHAREDRENT: &apos;SharedRent&apos;,</span><br><span class="line">    APARTMENT: &apos;Apartment&apos;,</span><br><span class="line">    BELOWTHOUSAND: &apos;BelowThousand&apos;,</span><br><span class="line">    PAYMONTHLY: &apos;PayMonthly&apos;,</span><br><span class="line">    VR: &apos;VR&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class SearchFilterMenu extends Component &#123;</span><br><span class="line"></span><br><span class="line">    componentDidUpdate() &#123;</span><br><span class="line">        const filterMenuTag = findNodeHandle(this.refs.filterMenu);</span><br><span class="line">        const containerTag = findNodeHandle(this.props.containerRef);</span><br><span class="line">        if (filterMenuTag &amp;&amp; containerTag) filterMenuManager.showFilterMenuOnView(containerTag, filterMenuTag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;FilterMenu ref=&apos;filterMenu&apos; &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JS调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;SearchFilterMenu</span><br><span class="line">    style=&#123;styles.filterMenu&#125;</span><br><span class="line">    cityId=&#123;`$&#123;home.cityId&#125;`&#125;</span><br><span class="line">    subwayData=&#123;home.subwayData&#125;</span><br><span class="line">    containerRef=&#123;this.refs.container&#125;</span><br><span class="line">    filterMenuType=&#123;this.params.filterMenuType&#125;</span><br><span class="line">    onChangeParameters=&#123;() =&gt; this._loadData(true)&#125;</span><br><span class="line">    onUpdateParameters=&#123;(&#123; nativeEvent: &#123; filterParams &#125; &#125;) =&gt; &#123;</span><br><span class="line">        this.filterParams = &#123;</span><br><span class="line">            ...this.filterParams,</span><br><span class="line">            ...filterParams,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="创建ViewManager"><a href="#创建ViewManager" class="headerlink" title="创建ViewManager"></a>创建ViewManager</h2><p><code>FHTFilterMenuManager</code>是继承自<code>RCTViewManager</code>，每一个原生UI都需要被一个<code>RCTViewManager</code>的子类来创建和管理。在程序运行过程中，<code>RCTViewManager</code>会创建原生UI并把视图提供给<code>RCTUIManager</code>，<code>RCTUIManager</code>则反过来委托<code>RCTViewManager</code>在需要的时候去设置和更新视图的属性。这里有一个注意点：<strong>ViewManager的命名格式是原生组件名字+Manager</strong>。</p>
<p>在ViewManager中最重要的是必须实现<code>- (UIView *)view</code>，用来返回你想要桥接的原生UI。</p>
<h2 id="从React-Native传递属性到原生组件"><a href="#从React-Native传递属性到原生组件" class="headerlink" title="从React Native传递属性到原生组件"></a>从React Native传递属性到原生组件</h2><p>我们知道属性是最简单的跨组件通信，如果RN组件接受到一个属性的时候，可以通过<code>RCT_EXPORT_VIEW_PROPERTY</code>和<code>RCT_CUSTOM_VIEW_PROPERTY</code>的方式传递给原生组件。</p>
<p><code>RCT_EXPORT_VIEW_PROPERTY</code>可以将原生组件自带的属性暴露给JS。所以在<code>FHTFilterMenuManager</code>中，我暴露三个自带的属性给JS，分别是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 点击确定按钮执行网络请求的block</span><br><span class="line">RCT_EXPORT_VIEW_PROPERTY(onUpdateParameters, RCTBubblingEventBlock);</span><br><span class="line">// 点击子菜单item，参数变更的block</span><br><span class="line">RCT_EXPORT_VIEW_PROPERTY(onChangeParameters, RCTBubblingEventBlock);</span><br><span class="line">// 筛选菜单的类型，</span><br><span class="line">RCT_EXPORT_VIEW_PROPERTY(filterMenuType, FilterMenuType);</span><br></pre></td></tr></table></figure>
<p>这里我使用了分类的方式对原生组件的属性进行拓展，因为在项目中，我并不希望原生组件有太多RN桥接相关的代码，所以使用分类拓展，这样也可以对代码进行解耦。</p>
<p>这里有一个注意点：<strong>如果自带的属性是block类型的话，属性名必须以on开头</strong>。</p>
<p><code>RCT_CUSTOM_VIEW_PROPERTY</code>可以让我们添加一些更为复杂的属性。由于<code>cityId</code>和<code>subwayData</code>是<code>FilterMenuGeographicController</code>这个子菜单才需要的，如果把它们设置为<code>FHTFilterMenu</code>的属性并不合适，而<code>FilterMenuGeographicController</code>我们并没有暴露给JS，所以我们可以使用<code>RCT_CUSTOM_VIEW_PROPERTY</code>对没有暴露给JS的对象进行属性传递。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RCT_CUSTOM_VIEW_PROPERTY(cityId, NSString, FHTFilterMenu) &#123;</span><br><span class="line">    FilterMenuGeographicController *vc = view.filterControllers[1];</span><br><span class="line">    vc.cityId = (NSString *)json;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RCT_CUSTOM_VIEW_PROPERTY(subwayData, NSArray, FHTFilterMenu) &#123;</span><br><span class="line">    FilterMenuGeographicController *vc = view.filterControllers[1];</span><br><span class="line">    vc.originalSubwayData = (NSArray *)json;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="React-Native调用原生组件的方法"><a href="#React-Native调用原生组件的方法" class="headerlink" title="React Native调用原生组件的方法"></a>React Native调用原生组件的方法</h2><p><code>RCT_EXPORT_METHOD</code>用来提供原生方法给JS调用。<code>RCT_EXPORT_METHOD(showFilterMenuOnView:(nonnull NSNumber *)containerTag filterMenuTag:(nonnull NSNumber *)filterMenuTag)</code>用来实现将子菜单添加到<code>SearchHousePage</code>，其实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RCT_EXPORT_METHOD(showFilterMenuOnView:(nonnull NSNumber *)containerTag filterMenuTag:(nonnull NSNumber *)filterMenuTag) &#123;</span><br><span class="line">    RCTUIManager *uiManager = self.bridge.uiManager;</span><br><span class="line">    dispatch_async(uiManager.methodQueue, ^&#123;</span><br><span class="line">        [uiManager addUIBlock:^(RCTUIManager *uiManager, NSDictionary&lt;NSNumber *,UIView *&gt; *viewRegistry) &#123;</span><br><span class="line">            UIView *view = viewRegistry[containerTag];</span><br><span class="line">            FHTFilterMenu *filterMenu = (FHTFilterMenu *)viewRegistry[filterMenuTag];</span><br><span class="line">            [filterMenu showFilterMenuOnView:view];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>containerTag</code>代码用来表示<code>SearchHousePage</code>，<code>filterMenuTag</code>则表示筛选条。这里有一个注意点：<strong>不能使用self.view的方式因为会创建出一个新的FHTFilterMenu对象，更不能在<code>- (UIView *)view</code>中使用一个指针对创建出来的View进行引用，如果你的组件在多个页面都用使用的话，是会出问题的</strong>。</p>
<p>另外，由于iOS的UI操作是要放在主线程完成的，所以最好<code>methodQueue</code>指定为主线程。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>到这里整个<code>SearchHousePage</code>页面的开发已经完成，如果需要查看完整代码的话，在<a href="https://github.com/YiHuaXie/NNHybrid" target="_blank" rel="noopener">代码传送门–NNHybrid</a>中。</p>
<p>参考：<br><a href="https://facebook.github.io/react-native/docs/native-modules-ios" target="_blank" rel="noopener">Native Modules</a><br><a href="https://facebook.github.io/react-native/docs/native-components-ios" target="_blank" rel="noopener">Native UI Components</a></p>
]]></content>
      <categories>
        <category>NNHybrid</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native项目--NNHybrid</title>
    <url>/2019/05/14/React-Native%E9%A1%B9%E7%9B%AE-NNHybrid/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从事iOS也有几年，一直就是做原生，没有使用RN这些跨平台的开发方案。也许是最近闲的慌吧，想学一下跨平台方案，在React Native和Flutter之间想了好久，最后贪图RN上手的时间成本可能更少吧，最终觉得还是学RN。</p>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>NNHybrid是基于React Native+Redux实现的一个混合开发App，目前只兼容iOS，后续会对功能再进行完善，并且兼容Andriod。</p>
<p>这个项目是用来学习RN的练手项目，我自己也是边看边写的，所以项目还是会有比较多的问题。</p>
<h2 id="项目效果图"><a href="#项目效果图" class="headerlink" title="项目效果图"></a>项目效果图</h2><p><img width="150" height="451.2" src="https://nnhybrid.oss-cn-hangzhou.aliyuncs.com/home.jpg"><img width="150" height="504.6" src="https://nnhybrid.oss-cn-hangzhou.aliyuncs.com/apartment.jpg"><img width="150" height="480" src="https://nnhybrid.oss-cn-hangzhou.aliyuncs.com/houseDetail.jpg"></p>
<p><img width="150" height="266.8" src="https://nnhybrid.oss-cn-hangzhou.aliyuncs.com/cityListPage.jpg"><img width="150" height="266.8" src="https://nnhybrid.oss-cn-hangzhou.aliyuncs.com/share.jpg"><img width="150" height="266.8" src="https://nnhybrid.oss-cn-hangzhou.aliyuncs.com/addressOnMap.jpg"></p>
<h2 id="项目依赖库"><a href="#项目依赖库" class="headerlink" title="项目依赖库"></a>项目依赖库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;@react-native-community/async-storage&quot;: &quot;^1.3.3&quot;,</span><br><span class="line">  &quot;pinyin&quot;: &quot;^2.8.3&quot;,</span><br><span class="line">  &quot;prop-types&quot;: &quot;^15.7.2&quot;,</span><br><span class="line">  &quot;react&quot;: &quot;16.6.3&quot;,</span><br><span class="line">  &quot;react-native&quot;: &quot;0.58.6&quot;,</span><br><span class="line">  &quot;react-native-device-info&quot;: &quot;^1.1.0&quot;,</span><br><span class="line">  &quot;react-native-gesture-handler&quot;: &quot;^1.1.0&quot;,</span><br><span class="line">  &quot;react-native-img-cache&quot;: &quot;^1.6.0&quot;,</span><br><span class="line">  &quot;react-native-linear-gradient&quot;: &quot;^2.5.4&quot;,</span><br><span class="line">  &quot;react-native-parallax-scroll-view&quot;: &quot;^0.21.3&quot;,</span><br><span class="line">  &quot;react-native-root-toast&quot;: &quot;^3.0.2&quot;,</span><br><span class="line">  &quot;react-native-storage&quot;: &quot;^1.0.1&quot;,</span><br><span class="line">  &quot;react-native-swiper&quot;: &quot;^1.5.14&quot;,</span><br><span class="line">  &quot;react-native-vector-icons&quot;: &quot;^6.4.2&quot;,</span><br><span class="line">  &quot;react-navigation&quot;: &quot;^3.3.2&quot;,</span><br><span class="line">  &quot;react-navigation-redux-helpers&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">  &quot;react-redux&quot;: &quot;^6.0.1&quot;,</span><br><span class="line">  &quot;redux&quot;: &quot;^4.0.1&quot;,</span><br><span class="line">  &quot;redux-devtools&quot;: &quot;^3.5.0&quot;,</span><br><span class="line">  &quot;redux-thunk&quot;: &quot;^2.3.0&quot;,</span><br><span class="line">  &quot;rn-fetch-blob&quot;: &quot;^0.10.15&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="项目心得"><a href="#项目心得" class="headerlink" title="项目心得"></a>项目心得</h2><p>个人觉得React Native项目开发中倒不是说UI有多难写，使用JS写UI即使再难写，也不会比OC的难写（比如说富文本）。反而是其他几个地方比较头痛或者说刚开始的很不习惯。这里我列举几个：</p>
<ul>
<li>导航（React-Navigation的使用)</li>
<li>React Native与原生通信（原生方面涉及到多线程，JS方面涉及async/await）</li>
<li>Redux（单向数据流）</li>
</ul>
<p><a href="https://github.com/YiHuaXie/NNHybrid" target="_blank" rel="noopener">代码传送门</a>最后还是希望这个项目对你学习RN有帮助！</p>
]]></content>
      <categories>
        <category>NNHybrid</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>RunLoop面试题分析</title>
    <url>/2019/07/26/RunLoop%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>更新于2019-07-29 完善AFNetworking常驻线程的作用</p>
<p>在<a href="https://www.neroxie.com/2019/04/24/%E9%87%8D%E6%8B%BERunLoop%E5%8E%9F%E7%90%86/">重拾RunLoop原理</a>中RunLoop的源码进行了分析，本该做一个总结方便以后查看，但是RunLoop中的知识点相对来说比较多，总结的东西就比较多。在面试中，又经常爱问一些RunLoop的知识点，接着就以我之前能回忆起来的面试题来对RunLoop做一个总结。</p>
<h3 id="RunLoop的作用"><a href="#RunLoop的作用" class="headerlink" title="RunLoop的作用"></a>RunLoop的作用</h3><p>RunLoop就是一种循环，它将运行的程序包裹起来。当没有事件时，RunLoop会进入休眠状态，有事件发生时，RunLoop会去找对应的Handler处理事件。RunLoop可以让线程在需要做事的时候忙起来，不需要的话就让线程休眠，一种让线程能随时处理事件但并不退出的机制。</p>
<h3 id="RunLoop与线程之间的关系"><a href="#RunLoop与线程之间的关系" class="headerlink" title="RunLoop与线程之间的关系"></a>RunLoop与线程之间的关系</h3><ul>
<li>RunLoop和线程之间是一一对应的，它们之间的关系保存在一个全局字典以及线程私有数据中；</li>
<li>在线程创建的时候，是没有对应的RunLoop，它的创建是在第一次获取的时候，它的销毁则发生在线程销毁的时候；</li>
</ul>
<h3 id="NSTimer在列表滑动时失效的原因和解决方法"><a href="#NSTimer在列表滑动时失效的原因和解决方法" class="headerlink" title="NSTimer在列表滑动时失效的原因和解决方法"></a>NSTimer在列表滑动时失效的原因和解决方法</h3><p>NSTimer默认运行在RunLoop的<code>kCFRunLoopDefaultMode</code>下，在列表滑动的时候，RunLoop会切换<code>UITrackingRunLoopMode</code>，因为RunLoop只能运行在一种模式下，所以NSTimer不会执行回调。</p>
<p>使用<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code>将timer添加到CommonModes中。它可以让<code>timer</code>运行在所有被标记为<code>Common</code>属性的Mode中，<code>kCFRunLoopDefaultMode</code>和<code>UITrackingRunLoopMode</code>默认都已经被标为”Common”属性的。</p>
<h3 id="NSTimer不精准的理由"><a href="#NSTimer不精准的理由" class="headerlink" title="NSTimer不精准的理由"></a>NSTimer不精准的理由</h3><p>NSTimer定时器的触发是基于RunLoop运行的，所以使用NSTimer之前必须注册到RunLoop，但是RunLoop为了节省资源并不会在非常准确的时间点调用定时器。当RunLoop在处理比较复杂的任务时，可能会错过一个时间点，那么定时器只能等到下一个时间点执行，并不会延后执行。</p>
<h3 id="NSTimer不精准的解决方法"><a href="#NSTimer不精准的解决方法" class="headerlink" title="NSTimer不精准的解决方法"></a>NSTimer不精准的解决方法</h3><ul>
<li>使用GCDTimer作为定时器，它是基于硬件时间的，相对来说更精准一点；</li>
<li>开辟子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果，这么做相对于将NSTimer添加在主线程RunLoop来说是会提高精确度，但是如果说子线程的RunLoop也比较繁忙的话，那一样会带来误差；</li>
</ul>
<h3 id="RunLoop的mode和Common-mode"><a href="#RunLoop的mode和Common-mode" class="headerlink" title="RunLoop的mode和Common mode"></a>RunLoop的mode和Common mode</h3><p>Mode是RunLoop的运行模式，每个RunLoop需要运行在一个特定的Mode中。如果需要切换Mode，只能退出Loop，再重新指定一个Mode进入。不同组的source0/source1/observer/timer可以相互隔离，互不影响，从而提高执行效率。</p>
<p>常用的RunLoop的Mode</p>
<ul>
<li><code>kCFRunLoopDefaultMode</code>：App的默认Mode，通常主线程是在这个Mode下运行；</li>
<li><code>UITrackingRunLoopMode</code>：界面跟踪Mode，用于滚动视图追踪触摸滑动，保证界面滑动时不受其他 Mode影响；</li>
<li><code>kCFRunLoopCommonModes</code>：这是一个占位用的Mode，并不是一种真正的Mode；</li>
</ul>
<p>Common mode并不是一个具体的Mode，它只是用来将Mode标记为<code>Common</code>属性。当source0/source1/observer/timer被添加到Common mode下的时候，意味着他们可以运行在所有被标记为<code>Common</code>属性的Mode中。</p>
<p><code>kCFRunLoopDefaultMode</code>和<code>UITrackingRunLoopMode</code>默认就被标记了<code>Common</code>属性。</p>
<h3 id="RunLoop中Source0和Source1的区别"><a href="#RunLoop中Source0和Source1的区别" class="headerlink" title="RunLoop中Source0和Source1的区别"></a>RunLoop中Source0和Source1的区别</h3><p><code>Source0</code>并不能主动触发事件。使用时，你需要先调用<code>CFRunLoopSourceSignal</code>，将这个Source标记为待处理，然后手动调用<code>CFRunLoopWakeUp</code>来唤醒RunLoop，让其处理这个事件。</p>
<p><code>Source1</code>能主动触发事件。其中它有一个<code>mach_port_t</code>，mach_port是用于内核向线程发送消息的。</p>
<p>使用<code>Source0</code>的情况：</p>
<ul>
<li>触摸事件处理；</li>
<li>调用<code>performSelector:onThread:withObject:waitUntilDone:</code>方法；</li>
</ul>
<p>使用<code>Source1</code>的情况：</p>
<ul>
<li>基于端口的线程间通信（A线程通过端口发送消息到B线程，这个消息是<code>Source1</code>的；</li>
<li>系统事件的捕捉，先触发是<code>Source1</code>，接着分发到<code>Source0</code>去处理。</li>
</ul>
<h3 id="RunLoop响应用户操作"><a href="#RunLoop响应用户操作" class="headerlink" title="RunLoop响应用户操作"></a>RunLoop响应用户操作</h3><p>以按钮点击触发事件为例，点击屏幕的时候，首先系统内部捕获到这个点击事件，这是在<code>Source1</code>中处理的，<code>Source1</code>会包装成事件丢到事件队列中，交给<code>Source0</code>处理。</p>
<h3 id="RunLoop与UI刷新"><a href="#RunLoop与UI刷新" class="headerlink" title="RunLoop与UI刷新"></a>RunLoop与UI刷新</h3><p>当UI需要更新的时候，比如改变了<code>frame</code>、更新了<code>UIView</code>/<code>CALayer</code>的层次时，或者手动调用了<code>setNeedsLayout</code>/<code>setNeedsDisplay</code>方法后，这个<code>UIView</code>/<code>CALayer</code>就被标记为待处理，并被提交到一个全局的容器去。 </p>
<p>苹果注册了一个<code>Observer</code>监听<code>BeforeWaiting</code>(即将进入休眠) 和 <code>Exit</code>(即将退出Loop) 事件，回调去执行一个很长的函数：<code>CA::Transaction::observer_callback(__CFRunLoopObserver*, unsigned long, void*)()</code> 这个函数里会遍历所有待处理的<code>UIView</code>/<code>CAlayer</code>以执行实际的绘制和调整，并更新界面。</p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/RunLoopUI%E5%88%B7%E6%96%B0.jpg" alt="RunLoop与UI刷新"></p>
<h3 id="RunLoop与AutoreleasePool"><a href="#RunLoop与AutoreleasePool" class="headerlink" title="RunLoop与AutoreleasePool"></a>RunLoop与AutoreleasePool</h3><p>在程序启动之后，主线程会创建一个Runloop，也会创建两个Observer，回调工作都是在<code>_wrapRunLoopWithAutoreleasePoolHandler</code>函数中。</p>
<p>第一个Observer监听的是Entry（即将进入Loop），回调是在<code>_objc_autoreleasePoolPush()</code>中创建自动释放池的，优先级是最高的，保证创建释放池是在所有回调之前。</p>
<p>第二个Observer监听有两个事件：BeforeWaiting（进入休眠）时调用<code>_objc_autoreleasePoolPop</code>和<code>_objc_autoreleasePoolPush</code>释放旧的释放池以及创建新的释放池；Exit（退出Loop）调用<code>_objc_autoreleasePoolPop</code>来释放自动释放池。这个优先级是最低的，保证释放池发生在所有回调之后调用。</p>
<h3 id="实现线程保活-控制线程生命周期"><a href="#实现线程保活-控制线程生命周期" class="headerlink" title="实现线程保活/控制线程生命周期"></a>实现线程保活/控制线程生命周期</h3><ol>
<li>首先需要知道线程一般执行完任务后，就会被销毁；</li>
<li>为什么说使用了Runloop就可以实现线程保活。添加runloop并运行起来，实际上是添加了一个循环，这样这个线程的程序一直卡在这个循环上，这样相当于线程的任务一直没有执行完，所以线程一直不会销毁；</li>
<li>如何销毁这个线程？ 停止runloop，可以使用<code>CFRunLoopStop</code>函数。</li>
</ol>
<p>在AFNetworking2.x中便是利用runloop实现线程保活的。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着自己控制线程的生命周期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface TestThreadViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) TestThread *thread;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestThreadViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.view.backgroundColor = UIColor.whiteColor;</span><br><span class="line">    </span><br><span class="line">    __weak __typeof(self) weakSelf = self;</span><br><span class="line">    </span><br><span class="line">    // 这里有个问题要注意: 线程内部会对target造成一个强引用</span><br><span class="line">    // 使用Block形式的API</span><br><span class="line">    self.thread = [[TestThread alloc] initWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%s -----beigin-----&quot;, __func__);</span><br><span class="line">        </span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        // 添加一个Source1</span><br><span class="line">        [runLoop addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        // 调用runloop run, 则runloop就不能被停止，其内部是在不断调用runMode:beforeDate:</span><br><span class="line">        // 不能调用[runLoop run];</span><br><span class="line">        </span><br><span class="line">        while (weakSelf) &#123;</span><br><span class="line">            [runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%s -----end-----&quot;, __func__);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [self.thread start];</span><br><span class="line">    </span><br><span class="line">    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">    button.frame = CGRectMake(100, 100, 30, 20);</span><br><span class="line">    button.backgroundColor = UIColor.redColor;</span><br><span class="line">    [self.view addSubview:button];</span><br><span class="line">    [button addTarget:self action:@selector(_didButtonPressed:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%@ dealloc&quot;, self.class);</span><br><span class="line">    </span><br><span class="line">    // 下面的代码就是说在子线程中执行threadStop方法</span><br><span class="line">    // 这里要注意waitUntilDone的用法</span><br><span class="line">    // 如果传入NO，该方法会直接返回执行后续的代码，这样会出现问题</span><br><span class="line">    // 如果传入YES，代表必须等到子线程执行完threadStop方法才能执行后面的代码</span><br><span class="line">    [self performSelector:@selector(threadStop)</span><br><span class="line">                 onThread:self.thread</span><br><span class="line">               withObject:nil</span><br><span class="line">            waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)_didButtonPressed:(id)sender &#123;</span><br><span class="line">    NSLog(@&quot;开始销毁页面&quot;);</span><br><span class="line">    [self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 线程保活</span><br><span class="line"></span><br><span class="line">- (void)threadPerformingTasks &#123;</span><br><span class="line">    NSLog(@&quot;%@ %s&quot;, [NSThread currentThread], __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)threadStop &#123;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;触发点击事件&quot;);</span><br><span class="line">    [self performSelector:@selector(threadPerformingTasks)</span><br><span class="line">                 onThread:self.thread</span><br><span class="line">               withObject:nil</span><br><span class="line">            waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/RunLoop%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="RunLoop控制线程生命周期"></p>
<h3 id="RunLoop与NSURLConnection"><a href="#RunLoop与NSURLConnection" class="headerlink" title="RunLoop与NSURLConnection"></a>RunLoop与NSURLConnection</h3><p><code>NSURLConnection</code>目前来说应该很少会被问到了，其底层会使用<code>CFSocket</code>去发送和接收请求，在发送和接收的一些事件发生后通知原来线程的<code>Runloop</code>去回调事件。</p>
<p>这道题可以说是在RunLoop的范畴，但是它更像是AFNetworking2.x为什么使用线程保活的解答，只是内部使用RunLoop技术去解决问题。</p>
<p>首先需要在子线程去开始连接，请求发送后，所在的子线程需要保活以保证正常接收到 NSURLConnectionDelegate回调方法。如果每来一个请求就开一条线程，并且保活线程，这样开销太大了。所以只需要保活一条固定的线程，在这个线程里发起请求、接收回调。</p>
<p>这里要注意一点：虽然使用了一条固定的线程，但是网络请求并不是单线程的，网络请求会放在一个并发队列里，是多线程的。请求返回后通知常驻线程，再通过常驻线程通知主线程。</p>
<h3 id="涉及到RunLoop的相关API"><a href="#涉及到RunLoop的相关API" class="headerlink" title="涉及到RunLoop的相关API"></a>涉及到RunLoop的相关API</h3><p><strong>以下代码的输出结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSInteger number = 1;</span><br><span class="line">    NSLog(@&quot;%zd&quot;, number);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        [self performSelector:@selector(printString) withObject:nil afterDelay:0];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    number = 3;</span><br><span class="line">    NSLog(@&quot;%zd&quot;, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printString &#123;</span><br><span class="line">    NSLog(@&quot;sdasdas&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：1 3</p>
<p>NSObject的<code>performSelecter:afterDelay:</code>或者<code>performSelector:onThread:</code>这样类似的方法被调用时，都依赖于RunLoop。子线程默认不启用RunLoop的，所以不会执行<code>Selector</code>中传入的方法。除非说API内部启用了RunLoop。比如调用<code>performSelector:onThread:withObject:waitUntilDone:</code>方法，<code>waitUntilDone:</code>传YES的时候，内部会自己启动RunLoop。</p>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [self performSelector:@selector(printString) withObject:nil afterDelay:0];</span><br><span class="line">    </span><br><span class="line">    NSRunLoop *runloop = [NSRunLoop currentRunLoop];</span><br><span class="line">    [runloop run];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="RunLoop的运行过程-内部实现"><a href="#RunLoop的运行过程-内部实现" class="headerlink" title="RunLoop的运行过程/内部实现"></a>RunLoop的运行过程/内部实现</h3><p>将下面这张图深深地刻在自己的骨子里<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/RunLoop_run.png" alt="RunLoop_run"></p>
<h3 id="RunLoop的休眠实现"><a href="#RunLoop的休眠实现" class="headerlink" title="RunLoop的休眠实现"></a>RunLoop的休眠实现</h3><p>当RunLoop一旦休眠意味着CPU不会分配任何资源，那线程也进入休眠。RunLoop休眠内部是调用了<code>mach_msg()</code>函数。操作系统中有内核层面的API和应用层面的API。<code>mach_msg()</code>可以理解为是应用层面的API，告诉内核休眠该线程休眠。一旦接受到系统事件，也会转化成内核API，告诉内核需要唤醒该线程，那么又可以执行应用层API了。所以RunLoop的休眠可以看成是用户状态到内核状态的切换，而唤醒RunLoop就是内核状态到用户状态的切换。</p>
]]></content>
      <categories>
        <category>RunLoop</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>WebViewJavascriptBridge源码分析</title>
    <url>/2021/01/26/WebViewJavascriptBridge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在APP的开发过程中，都会通过H5来实现部分功能，H5页面是内嵌在原生应用的WebView组件中。在有的场景下，当两端需要相互通信，但是JavaScript的权限受到限制，比如不能修改系统配置等，这个时候需要委托Native去实现某个功能，并在完成后将结果通知JavaScript。所以我们需要在Native和JavaScript之间就搭建一个通信的桥梁，这个桥梁就是我们所说的JavaScript Bridge，简称 JS Bridge。</p>
<p>通常实现Native与JS桥接的方式有两种：</p>
<ol>
<li>通过JavaScriptCore框架</li>
<li>通过Webview拦截请求的方式（WebViewJavascriptBridge使用的方式）</li>
</ol>
<p><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">marcuswestin的WebViewJavascriptBridge</a>是使用第2种方式实现在用于在WKWebView和UIWebView中，JS与Native相互发送消息。</p>
<p>与其他OC的三方库不同，WebViewJavascriptBridge的实现包括OC和JS两部分，因此只看OC部分的代码我们是无法理解这个bridge是如何实现两端通信的。</p>
<h2 id="WebViewJavascriptBridge中的类的作用"><a href="#WebViewJavascriptBridge中的类的作用" class="headerlink" title="WebViewJavascriptBridge中的类的作用"></a>WebViewJavascriptBridge中的类的作用</h2><ul>
<li><code>WebViewJavascriptBridgeBase</code>：OC端桥接基础服务类，维护OC端开放给JS端的方法以及OC回调方法，实现OC向JS发送数据的具体逻辑。</li>
<li><code>WebViewJavascriptBridge_JS</code>：维护了一份JS代码，用于JS环境的注入。同时维护JS端的bridge对象，管理JS端注册的方法集合以及回调方法集合，面向Web端提供注册JS方法、调用OC端方法的接口。</li>
<li><code>WKWebViewJavascriptBridge</code>：基于WKWebView的OC端交互逻辑处理类，面向OC业务层，提供了注册OC方法、调用JS方法等接口。</li>
<li><code>WebViewJavascriptBridge</code>：基于UIWebView的的OC端交互逻辑处理类，与<code>WKWebViewJavascriptBridge</code>的功能一致。</li>
</ul>
<h2 id="WebViewJavascriptBridge源码解析"><a href="#WebViewJavascriptBridge源码解析" class="headerlink" title="WebViewJavascriptBridge源码解析"></a>WebViewJavascriptBridge源码解析</h2><p><code>WebViewJavascriptBridge</code>的实现可以说是双向的过程，无论是JS端还是Native端都包含以下三部分内容：</p>
<ul>
<li>bridge初始化</li>
<li>本端注册函数共另一端调用</li>
<li>调用另一端函数</li>
</ul>
<p>目前App已经取消对UIWebView的支持，所以我们只需要看WKWebView相关部分的实现即可。</p>
<h3 id="bridge初始化"><a href="#bridge初始化" class="headerlink" title="bridge初始化"></a>bridge初始化</h3><p>bridge初始化分为Native初始化bridge和JS初始化bridge。在使用WebView的时候，都是从Native端打开页面开始，因此先分析Native初始化bridge。</p>
<h4 id="Native初始化bridge"><a href="#Native初始化bridge" class="headerlink" title="Native初始化bridge"></a>Native初始化bridge</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)bridgeForWebView:(<span class="built_in">WKWebView</span>*)webView &#123;</span><br><span class="line">    <span class="built_in">WKWebViewJavascriptBridge</span>* bridge = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    [bridge _setupInstance:webView];</span><br><span class="line">    [bridge reset];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bridge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_setupInstance:(<span class="built_in">WKWebView</span>*)webView &#123;</span><br><span class="line">    _webView = webView;</span><br><span class="line">    <span class="comment">// 将webView的navigationDelegate设为WKWebViewJavascriptBridge对象自身</span></span><br><span class="line">    _webView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    _base = [[WebViewJavascriptBridgeBase alloc] init];</span><br><span class="line">    <span class="comment">// WKWebViewJavascriptBridge对象需要实现_evaluateJavascript:代理方法</span></span><br><span class="line">    _base.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)reset &#123;</span><br><span class="line">    [_base reset];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WKWebViewJavascriptBridge</code>中<code>_evaluateJavascript:</code>方法的实现：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span>*)_evaluateJavascript:(<span class="built_in">NSString</span>*)javascriptCommand &#123;</span><br><span class="line">    [_webView evaluateJavaScript:javascriptCommand completionHandler:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于JS代码的注入，可以使用<code>WKUserContentController</code>，也可以使用<code>evaluateJavaScript:completionHandler:</code>这个函数，<code>WebViewJavascriptBridge</code>使用后者实现JS注入，因此需要将webView的<code>navigationDelegate</code>设为<code>WKWebViewJavascriptBridge</code>对象自身，并在代理方法中调用<code>evaluateJavaScript:completionHandler:</code>函数。</p>
<p>在Native初始化后，就要使用<code>load</code>之类的方法加载页面与JS代码，这进入到JS初始化bridge过程。</p>
<h4 id="JS初始化bridge"><a href="#JS初始化bridge" class="headerlink" title="JS初始化bridge"></a>JS初始化bridge</h4><p>相对于Native初始化bridge来说，JS初始化bridge就要显得难一些。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">	function setupWebViewJavascriptBridge(callback) &#123;</span><br><span class="line">		// window表示浏览器窗口</span><br><span class="line">		// WebViewJavascriptBridge就是bridge对象。</span><br><span class="line">		// 如果有bridge对象则直接调用callback并传入bridge对象。</span><br><span class="line">		if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">		// 如果有WVJBCallbacks则将回调函数push到数组里，后面初始化bridge时会统一遍历调用callback，并传入bridge。</span><br><span class="line">		if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">		window.WVJBCallbacks = [callback];</span><br><span class="line">		var WVJBIframe = document.createElement('iframe');</span><br><span class="line">		WVJBIframe.style.display = 'none';</span><br><span class="line">		// 网页会请求这个链接</span><br><span class="line">		WVJBIframe.src = 'https://__bridge_loaded__';</span><br><span class="line">		document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">		// setTimeout是Native端注入的一个函数</span><br><span class="line">		setTimeout(function () &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 执行调用setupWebViewJavascriptBridge函数，bridge就是对象。</span><br><span class="line">	// 在WebViewJavascriptBridge_JS.m文件中对bridge的定义</span><br><span class="line">	// window.WebViewJavascriptBridge = &#123;</span><br><span class="line">	// 		registerHandler: registerHandler,</span><br><span class="line">	// 		callHandler: callHandler,</span><br><span class="line">	// 		disableJavscriptAlertBoxSafetyTimeout: disableJavscriptAlertBoxSafetyTimeout,</span><br><span class="line">	// 		_fetchQueue: _fetchQueue,</span><br><span class="line">	// 		_handleMessageFromObjC: _handleMessageFromObjC</span><br><span class="line">	// &#125;;</span><br><span class="line">	setupWebViewJavascriptBridge(function (bridge) &#123;</span><br><span class="line">		// ...</span><br><span class="line">		// JS注册函数供Native调用</span><br><span class="line">		bridge.registerHandler('testJavascriptHandler', function (data, responseCallback) &#123;</span><br><span class="line">		   // ...</span><br><span class="line">		&#125;)</span><br><span class="line">		// ...</span><br><span class="line">	&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在JS初始化bridge过程中，会直接调用<code>setupWebViewJavascriptBridge(callback)</code>函数，callback相当于block/闭包。在这个过程中，<code>callHandler</code>、<code>registerHandler</code>等函数都是通过JS代码注入的，这些代码都在Native端，那它是如何成功执行这些函数的呢？关键在于<code>https://__bridge_loaded__</code>这个url。在使用了这个url后，WKWebView的NavigationDelegate会拦截这个请求，并注入JS代码。相关实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// isBridgeLoadedURL函数中的kBridgeLoaded即为__bridge_loaded__</span></span><br><span class="line">    <span class="keyword">if</span> ([_base isBridgeLoadedURL:url]) &#123;</span><br><span class="line">        [_base injectJavascriptFile];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用泳道图来描述初始化bridge的过程<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/WebViewJavascriptBridge%E5%88%9D%E5%A7%8B%E5%8C%96bridge.png" alt="WebViewJavascriptBridge初始化bridge"></p>
<h3 id="JS注册函数，Native调用JS"><a href="#JS注册函数，Native调用JS" class="headerlink" title="JS注册函数，Native调用JS"></a>JS注册函数，Native调用JS</h3><h4 id="JS注册函数"><a href="#JS注册函数" class="headerlink" title="JS注册函数"></a>JS注册函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JS注册函数给Native调用</span></span><br><span class="line">bridge.registerHandler(<span class="string">'testJavascriptHandler'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, responseCallback</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> responseData = &#123; <span class="string">'Javascript Says'</span>:<span class="string">'Right back atcha!'</span> &#125;</span><br><span class="line">	responseCallback(responseData)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WebViewJavascriptBridge_JS.m中的JS代码</span></span><br><span class="line"><span class="comment">// 保存JS函数与函数名的映射关系</span></span><br><span class="line"><span class="keyword">var</span> messageHandlers = &#123;&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerHandler</span>(<span class="params">handlerName, handler</span>) </span>&#123;</span><br><span class="line">    messageHandlers[handlerName] = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Native调用JS函数"><a href="#Native调用JS函数" class="headerlink" title="Native调用JS函数"></a>Native调用JS函数</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> data = @&#123; <span class="string">@"greetingFromObjC"</span>: <span class="string">@"Hi there, JS!"</span> &#125;;</span><br><span class="line">[_bridge callHandler:<span class="string">@"testJavascriptHandler"</span> data:data responseCallback:^(<span class="keyword">id</span> response) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testJavascriptHandler responded: %@"</span>, response);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>内部调用了<code>WebViewJavascriptBridgeBase</code>的<code>sendData:responseCallback:handlerName:</code>方法。<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendData:(<span class="keyword">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(<span class="built_in">NSString</span>*)handlerName &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span>* message = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">// JS函数所需的参数</span></span><br><span class="line">    <span class="keyword">if</span> (data) message[<span class="string">@"data"</span>] = data;</span><br><span class="line">    <span class="comment">// responseCallback：Native调用JS函数后的回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">        <span class="built_in">NSString</span>* callbackId = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"objc_cb_%ld"</span>, ++_uniqueId];</span><br><span class="line">        <span class="comment">// 保存Native回调</span></span><br><span class="line">        <span class="keyword">self</span>.responseCallbacks[callbackId] = [responseCallback <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">// 保存回调方法的id</span></span><br><span class="line">        message[<span class="string">@"callbackId"</span>] = callbackId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// JS函数名</span></span><br><span class="line">    <span class="keyword">if</span> (handlerName) &#123;</span><br><span class="line">        message[<span class="string">@"handlerName"</span>] = handlerName;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> _queueMessage:message];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Native调用JS的函数时，有时Native需要JS调用Native的回调函数返回一些数据，因此需要保存回调函数的一些信息，关于Native的回调函数是如何调用的，在后面会讲到。<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_queueMessage:(WVJBMessage*)message &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.startupMessageQueue) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.startupMessageQueue addObject:message];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> _dispatchMessage:message];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在开发过程中，有可能Native调用JS函数的时候，JS端还没有完成bridge准备工作。bridge是在<code>decidePolicyForNavigationAction:</code>的代理方法中执行<code>injectJavascriptFile</code>方法才完成的，但是<br><code>callHandler</code>可能在<code>viewWillAppear</code>的时候调用，此时没有完成JS端bridge的初始化，所以先存入<code>startupMessageQueue</code>中，等准备完成后， 再统一调用 <code>startupMessageQueue</code>中的Message到JS，并将<code>startupMessageQueue</code>置为空。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)injectJavascriptFile &#123;</span><br><span class="line">    <span class="comment">// 注入JS bridge的环境代码</span></span><br><span class="line">    <span class="built_in">NSString</span> *js = WebViewJavascriptBridge_js();</span><br><span class="line">    [<span class="keyword">self</span> _evaluateJavascript:js];</span><br><span class="line">    <span class="comment">// 对于一些提前调用的callHandler，在注入JS初始化代码后，会统一发送，并清空startupMessageQueue</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.startupMessageQueue) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span>* queue = <span class="keyword">self</span>.startupMessageQueue;</span><br><span class="line">        <span class="keyword">self</span>.startupMessageQueue = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> queuedMessage <span class="keyword">in</span> queue) &#123;</span><br><span class="line">            [<span class="keyword">self</span> _dispatchMessage:queuedMessage];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_dispatchMessage:(WVJBMessage*)message &#123;</span><br><span class="line">    <span class="comment">// 序列化message</span></span><br><span class="line">    <span class="built_in">NSString</span> *messageJSON = [<span class="keyword">self</span> _serializeMessage:message pretty:<span class="literal">NO</span>];</span><br><span class="line">    <span class="comment">// 省略对messageJSON的处理</span></span><br><span class="line">    <span class="built_in">NSString</span>* javascriptCommand = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"WebViewJavascriptBridge._handleMessageFromObjC('%@');"</span>, messageJSON];</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSThread</span> currentThread] isMainThread]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _evaluateJavascript:javascriptCommand];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> _evaluateJavascript:javascriptCommand];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dispatchMessage</code>将之前拼装好的message传给JS，用JS bridge的 <code>_handleMessageFromObjC</code>函数处理Native的调用请求，<code>_handleMessageFromObjC</code>函数是在JS bridge初始化的时候注入的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_handleMessageFromObjC</span>(<span class="params">messageJSON</span>) </span>&#123;</span><br><span class="line">    _dispatchMessageFromObjC(messageJSON);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_dispatchMessageFromObjC</span>(<span class="params">messageJSON</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略dispatchMessagesWithTimeoutSafety部分</span></span><br><span class="line">    _doDispatchMessageFromObjC();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_doDispatchMessageFromObjC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> message = <span class="built_in">JSON</span>.parse(messageJSON);</span><br><span class="line">        <span class="keyword">var</span> messageHandler;</span><br><span class="line">        <span class="keyword">var</span> responseCallback;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否有responseId，对于Native调用JS函数所传过来的message来说是没有该字段的</span></span><br><span class="line">        <span class="comment">// if (message.responseId) &#123;</span></span><br><span class="line">        <span class="comment">// // ...</span></span><br><span class="line">        <span class="comment">// &#125; </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理Native调用JS函数的message</span></span><br><span class="line">        <span class="keyword">if</span> (message.callbackId) &#123;</span><br><span class="line">            <span class="comment">// 是否含有Native回调</span></span><br><span class="line">            <span class="keyword">var</span> callbackResponseId = message.callbackId;</span><br><span class="line">            responseCallback = <span class="function"><span class="keyword">function</span> (<span class="params">responseData</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// _doSend函数只传了message，另外没有responseCallback参数</span></span><br><span class="line">                _doSend(&#123;</span><br><span class="line">                    handlerName: message.handlerName,</span><br><span class="line">                    <span class="comment">// 如果Native传过来的message有回调，那么JS端需要传入一个responseId，这样Native端才能通过responseId这个key</span></span><br><span class="line">                    <span class="comment">// 在responseCallbacks字典中找到对应的Native回调</span></span><br><span class="line">                    responseId: callbackResponseId,</span><br><span class="line">                    responseData: responseData</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过handlerName获取到对应的JS函数，并调用。</span></span><br><span class="line">        <span class="comment">// messageHandlers保存了JS bridge的函数名和回调函数</span></span><br><span class="line">        <span class="keyword">var</span> handler = messageHandlers[message.handlerName];</span><br><span class="line">        <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"WebViewJavascriptBridge: WARNING: no handler for message from ObjC:"</span>, message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handler(message.data, responseCallback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个_doSend是精简之后的实现，_doDispatchMessageFromObjC中的_doSend函数没有传递responseCallback参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_doSend</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// sendMessageQueue保存message信息，这个message信息是给Native回调时候用的</span></span><br><span class="line">    sendMessageQueue.push(message);</span><br><span class="line">    <span class="comment">// src = https://__wvjb_queue_message__，WKWebView的代理方法优惠拦截这个url，从而调用WKWebViewJavascriptBridge的KFlushMessageQueue方法</span></span><br><span class="line">    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="string">'://'</span> + QUEUE_HAS_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当WKWebView的代理方法拦截到<code>https://__wvjb_queue_message__</code>这个url的时候，就会调用<code>WKFlushMessageQueue</code>方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([_base isQueueMessageURL:url]) &#123;</span><br><span class="line">    [<span class="keyword">self</span> <span class="built_in">WKFlushMessageQueue</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="built_in">WKFlushMessageQueue</span> &#123;</span><br><span class="line">    [_webView evaluateJavaScript:<span class="string">@"WebViewJavascriptBridge._fetchQueue();"</span> completionHandler:^(<span class="built_in">NSString</span>* result, <span class="built_in">NSError</span>* error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, result);</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"WebViewJavascriptBridge: WARNING: Error when trying to fetch data from WKWebView: %@"</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">        [_base flushMessageQueue:result];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>_fetchQueue()</code>这个JS函数，并在<code>completionHandler</code>这个block内返回JS中<code>sendMessageQueue</code>的信息，从而获取带<code>responseId</code>的message。接着执行Native的<code>flushMessageQueue</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在flushMessageQueue方法中完成了Native调用JS函数后的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)flushMessageQueue:(<span class="built_in">NSString</span> *)messageQueueString&#123;</span><br><span class="line">    <span class="comment">// 省略messageQueueString的有效性判断</span></span><br><span class="line">    <span class="keyword">id</span> messages = [<span class="keyword">self</span> _deserializeMessageJSON:messageQueueString];</span><br><span class="line">    <span class="keyword">for</span> (WVJBMessage* message <span class="keyword">in</span> messages) &#123;</span><br><span class="line">        <span class="comment">// 省略对Message类型的校验</span></span><br><span class="line">        <span class="built_in">NSString</span>* responseId = message[<span class="string">@"responseId"</span>];</span><br><span class="line">        <span class="keyword">if</span> (responseId) &#123;</span><br><span class="line">            WVJBResponseCallback responseCallback = _responseCallbacks[responseId];</span><br><span class="line">            responseCallback(message[<span class="string">@"responseData"</span>]);</span><br><span class="line">            [<span class="keyword">self</span>.responseCallbacks removeObjectForKey:responseId];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用泳道图来描述Native调用JS的过程<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/WebViewJavascriptBridgeNative%E8%B0%83%E7%94%A8JS.png" alt="WebViewJavascriptBridgeNative调用JS"></p>
<h3 id="Native注册函数，JS调用Native"><a href="#Native注册函数，JS调用Native" class="headerlink" title="Native注册函数，JS调用Native"></a>Native注册函数，JS调用Native</h3><h4 id="Native注册函数"><a href="#Native注册函数" class="headerlink" title="Native注册函数"></a>Native注册函数</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[_bridge registerHandler:<span class="string">@"testObjcCallback"</span> handler:^(<span class="keyword">id</span> data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testObjcCallback called: %@"</span>, data);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    responseCallback(<span class="string">@"Response from testObjcCallback"</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerHandler:(<span class="built_in">NSString</span> *)handlerName handler:(WVJBHandler)handler &#123;</span><br><span class="line">    <span class="comment">// messageHandlers用来保存OC函数与函数名的映射关系</span></span><br><span class="line">    _base.messageHandlers[handlerName] = [handler <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JS调用Native函数"><a href="#JS调用Native函数" class="headerlink" title="JS调用Native函数"></a>JS调用Native函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bridge.callHandler(<span class="string">'testObjcCallback'</span>, &#123; <span class="string">'foo'</span>: <span class="string">'bar'</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">'JS got response'</span>, response)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// JS端callHandler的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">'function'</span>) &#123;</span><br><span class="line">        responseCallback = data;</span><br><span class="line">        data = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _doSend(&#123; <span class="attr">handlerName</span>:handlerName, <span class="attr">data</span>:data &#125;, responseCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Native调用JS的过程也使用了<code>_doSend</code>函数，它的作用是为了能调用Native调用JS函数之后的回调函数。在JS调用Native的过程中，<code>_doSend</code>函数是为了调用OC函数（与函数名对应的block），responseCallback则是代表JS调用OC函数后的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_doSend</span>(<span class="params">message, responseCallback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有JS回调，则使用responseCallbacks保存JS回调</span></span><br><span class="line">    <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">        <span class="keyword">var</span> callbackId = <span class="string">'cb_'</span>+(uniqueId++)+<span class="string">'_'</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">        message[<span class="string">'callbackId'</span>] = callbackId;</span><br><span class="line">    &#125;</span><br><span class="line">    sendMessageQueue.push(message);</span><br><span class="line">    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="string">'://'</span> + QUEUE_HAS_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后的逻辑在OC调用JS中已经描述过了，直到执行<code>flushMessageQueue:</code>方法前都是一样的<br>这里就不再重复。接着看一下<code>flushMessageQueue:</code>方法在JS调用Native过程中的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)flushMessageQueue:(<span class="built_in">NSString</span> *)messageQueueString&#123;</span><br><span class="line">    <span class="comment">// 省略messageQueueString的有效性判断</span></span><br><span class="line">    <span class="keyword">id</span> messages = [<span class="keyword">self</span> _deserializeMessageJSON:messageQueueString];</span><br><span class="line">    <span class="keyword">for</span> (WVJBMessage* message <span class="keyword">in</span> messages) &#123;</span><br><span class="line">        <span class="comment">// 省略对Message类型的校验</span></span><br><span class="line">        <span class="comment">// 忽略关于responseId的实现</span></span><br><span class="line">        <span class="comment">// 对于JS调用Native所传过来的message来说是没有responseId字段的</span></span><br><span class="line">        WVJBResponseCallback responseCallback = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">NSString</span>* callbackId = message[<span class="string">@"callbackId"</span>];</span><br><span class="line">        <span class="comment">// 判断是否有JS回调</span></span><br><span class="line">        <span class="keyword">if</span> (callbackId) &#123;</span><br><span class="line">            responseCallback = ^(<span class="keyword">id</span> responseData) &#123;</span><br><span class="line">                <span class="keyword">if</span> (responseData == <span class="literal">nil</span>) &#123;</span><br><span class="line">                    responseData = [<span class="built_in">NSNull</span> null];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                WVJBMessage* msg = @&#123; <span class="string">@"responseId"</span>:callbackId, <span class="string">@"responseData"</span>:responseData &#125;;</span><br><span class="line">                <span class="comment">// _queueMessage: -&gt; _dispatchMessage: -&gt; JS: _handleMessageFromObjC -&gt; JS: _dispatchMessageFromObjC</span></span><br><span class="line">                [<span class="keyword">self</span> _queueMessage:msg];</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseCallback = ^(<span class="keyword">id</span> ignoreResponseData) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过handlerName获取到对应的Native函数，并调用。</span></span><br><span class="line">        <span class="comment">// messageHandlers保存了Native bridge的函数名和回调函数</span></span><br><span class="line">        WVJBHandler handler = <span class="keyword">self</span>.messageHandlers[message[<span class="string">@"handlerName"</span>]];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"WVJBNoHandlerException, No handler for message from JS: %@"</span>, message);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行Native函数</span></span><br><span class="line">        handler(message[<span class="string">@"data"</span>], responseCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于<code>_queueMessage:</code>方法前面已经分析过，这里就不再重复，接着看一下<code>_dispatchMessageFromObjC</code>函数在JS调用Native过程中的实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 精简了_doDispatchMessageFromObjC，只保留调用JS回调的部分</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_doDispatchMessageFromObjC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">JSON</span>.parse(messageJSON);</span><br><span class="line">    <span class="keyword">var</span> responseCallback;</span><br><span class="line">    <span class="comment">// 如果有JS回调，那么OC传过来的message必然存在responseId字段</span></span><br><span class="line">    <span class="keyword">if</span> (message.responseId) &#123;</span><br><span class="line">        responseCallback = responseCallbacks[message.responseId];</span><br><span class="line">        <span class="keyword">if</span> (!responseCallback) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用JS回调</span></span><br><span class="line">        responseCallback(message.responseData);</span><br><span class="line">        <span class="keyword">delete</span> responseCallbacks[message.responseId];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着用泳道图来描述下JS调用Native的过程<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/WebViewJavascriptBridgeJS%E8%B0%83%E7%94%A8Native.png" alt="WebViewJavascriptBridgeJS调用Native"></p>
<h2 id="NNWKWebViewJSBridge"><a href="#NNWKWebViewJSBridge" class="headerlink" title="NNWKWebViewJSBridge"></a>NNWKWebViewJSBridge</h2><p>NNWKWebViewJSBridge是我在了解WebViewJavascriptBridge的实现过程后，基于这个项目，实现一个轻量级Swift版本JSBridge，并且它仅需要支持WKWebView即可。<br>相对于WebViewJavascriptBridge，我使用了<code>WKUserContentController</code>简化了初始化和消息传递的实现过程，相对来说会更好理解，消息传递性能也要比拦截Requests的方式要高。</p>
<p>项目地址：<a href="https://github.com/YiHuaXie/NNWKWebViewJSBridge" target="_blank" rel="noopener">NNWKWebViewJSBridge</a><br>项目截图：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/WKWebViewJSBridge_demo.jpg" alt="WKWebViewJSBridge_demo"></p>
]]></content>
      <categories>
        <category>Hybrid</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Swift</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitHub Pages+Mweb搭建博客</title>
    <url>/2018/12/01/hexo+GitHub%20Pages+Mweb%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>更新于2020-01-25 添加Hexo的Git管理</p>
<p>花了两三个小时终于将自己的博客搭建好了，下面就分享一下整个过程。<br>由于我自己本来Mac上就装了Homebrew，所以就省略了安装Homebrew的过程了。直接从安装nvm开始。</p>
<h2 id="nvm-and-node"><a href="#nvm-and-node" class="headerlink" title="nvm and node"></a>nvm and node</h2><h3 id="使用nvm安装node"><a href="#使用nvm安装node" class="headerlink" title="使用nvm安装node"></a>使用nvm安装node</h3><p><strong>安装nvm</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure>
<p>如果安装成功，使用<code>nvm</code>命令会出现如下的提示：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/nvm_success.png" alt="nvm_success"></p>
<p><strong>配置nvm</strong></p>
<p>修改<code>~/.bash_profile</code>文件，如果不存在，新建<code>.bash_profile</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">vim .bash_profile</span><br></pre></td></tr></table></figure>
<p>当然你也可以使用<code>open .bash_profile</code>进行修改。接着在<code>.bash_profile</code>添加下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export NVM_DIR=~/.nvm</span><br><span class="line">source $(brew --prefix nvm)/nvm.sh</span><br></pre></td></tr></table></figure>
<p>重新source</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure>
<p><code>open .zshrc</code>打开文件后，在最后添加一句<code>source ~/.bash_profile</code>。不然每次打开窗口都要重新source一下。</p>
<p><strong>安装node</strong></p>
<p>node安装命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm ls-remote 查看所有版本</span><br><span class="line">nvm install xxx 下载你想要的版本</span><br><span class="line">nvm use xxx 使用指定版本的node</span><br><span class="line">nvm alias default xxx 每次启动终端都使用该版本</span><br></pre></td></tr></table></figure>
<p>这里我安装了<code>v11.3.0</code>版本<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/node_install.png" alt="node_install"></p>
<p>查看node是否安装命令：<code>node -v</code>和<code>npm -v</code>。<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/node_success.png" alt="node_success"></p>
<h2 id="Hexo-and-GitHub-Pages"><a href="#Hexo-and-GitHub-Pages" class="headerlink" title="Hexo and GitHub Pages"></a>Hexo and GitHub Pages</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p><strong>全局安装Hexo</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<p><strong>初始化Hexo</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init NeroBlog</span><br></pre></td></tr></table></figure>
<p><strong>npm install</strong></p>
<p>初始化成功，在<code>NeroBlog</code>目录下，使用<br><code>npm install</code></p>
<p><strong>查看安装成功</strong></p>
<p>使用<code>hexo s</code>，在浏览器中打开<code>localhost:4000</code>能看到<code>Hexo</code>页面表示安装成功。<code>Ctrl+C</code>关闭<code>hexo server</code>。</p>
<h3 id="关联GitHub"><a href="#关联GitHub" class="headerlink" title="关联GitHub"></a>关联GitHub</h3><p>登录你的GitHub帐号，新建仓库并命名：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/create_repository.png" alt="create_repository"><br>这里这么写也是可以的，但是这么最好不要这么写，后面我们会更换域名，还是要使用<code>用户名.github.io</code>的写法。（我自己的博客就是使用<code>YiHuaXie.github.io</code>）</p>
<p><strong>修改_config.yml文件</strong></p>
<p>cd到写博客的文件夹下（我这里就是NeroBlog），编辑<code>_config.yml</code>文件，在编辑<code>_config.yml</code>文件的时候要注意冒号后面要空一格。</p>
<p>修改<code>deploy</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:YiHuaXie/YiHuaXie.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p><strong>生成静态页面</strong></p>
<p>使用<code>hexo g</code>生成静态页面，这里可能会出现错误，但是我安装的时候没有。</p>
<p><strong>上传</strong></p>
<p>使用<code>hexo d</code>就会将你的页面上传到GitHub上的对应仓库里。执行<code>hexo d</code>报错的话使用<code>npm install hexo-deployer-git --save</code>应该就能解决。</p>
<p>如果你没有关联GitHub，则执行<code>hexo d</code>时终端会提示你输入GitHub的用户名和密码。</p>
<p>成功结果如下：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/hexo_deploy_success.jpg" alt="hexo_deploy_success"></p>
<p><strong>返回GitHub仓库</strong></p>
<p>返回GitHub仓库，点击<code>Settings</code>。在<code>GitHub Pages</code>那一栏的<code>source</code>选择对应分支并保存。<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/github_page_source.jpg" alt="github_page_source"><br>保存后要稍微等一会会出现：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/github_pages_success.jpg" alt="github_pages_success"><br>这就是我们最终生成的博客地址。</p>
<p>打开后发现有内容但是没有样式，这里就是一个巨坑，害得我仓库重建了好几次。</p>
<p><strong>填坑</strong></p>
<p>打开<code>_config.yml</code>文件，找到<code>root</code>修改为<code>root: /blogtest</code>并保存。</p>
<p>接着使用（每次博客修改后都要执行下面的命令）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>再次打开上面的链接就和<code>localhost:4000h</code>看到的页面效果一样了。</p>
<h2 id="使用Mweb"><a href="#使用Mweb" class="headerlink" title="使用Mweb"></a>使用Mweb</h2><h3 id="图片上传问题"><a href="#图片上传问题" class="headerlink" title="图片上传问题"></a>图片上传问题</h3><p>可以直接使用本地图片，这里我是上传到阿里云上面的。七牛云作为图床比较麻烦，主要是默认给你的前缀是测试的只有一个月有效期。不然就要备案什么的巨麻烦。</p>
<h3 id="Mweb关联Hexo"><a href="#Mweb关联Hexo" class="headerlink" title="Mweb关联Hexo"></a>Mweb关联Hexo</h3><p>现在我们只需要关联一下<code>source</code>文件夹即可。具体做法如下：</p>
<ol>
<li><code>CMD + E</code>或者选择<code>文件</code>-&gt;<code>打开外部模式</code>；</li>
<li>点击左下角的<code>➕</code>，选择<code>引入文件夹</code>，将博客目录下的<code>source</code>文件引进来；</li>
<li>右键该文件夹选择<code>编辑</code>；</li>
<li>可以修改<code>显示名称</code>，不会影响真实的文件夹名；<code>保存拖入的图片的文件夹名称</code>这里我将文件夹名称去掉了；</li>
</ol>
<p>这样就可以大功告成了。</p>
<h2 id="Hexo的Git管理"><a href="#Hexo的Git管理" class="headerlink" title="Hexo的Git管理"></a>Hexo的Git管理</h2><p>在很长的一段时间，我都使用一台电脑来管理这个博客项目。这是很麻烦的，所以还是需要Git的帮助让我可以在多台设备上管理。</p>
<h3 id="创建新的Git仓库"><a href="#创建新的Git仓库" class="headerlink" title="创建新的Git仓库"></a>创建新的Git仓库</h3><p>在<code>yourname.github.io</code>的<code>master</code>分支上的都是Hexo发布后的产物即编译之后的静态页面，里面并没有我们的项目文件，所以需要额外创建一个Git仓库或者在<code>yourname.github.io</code>下新建一个分支，专门管理Hexo项目。</p>
<p><strong>注意点1</strong>：如果你是用<code>yourname.github.io</code>下新建一个分支的方式，在拉取分支（该分支肯定是基于Master分支拉的分支，并且Master分支上已经有产物）后，需要将除了.git文件夹以外的所有文件全部删除，这个分支与master是完全独立的。</p>
<p>这里我使用了新建仓库的方式，该仓库就叫做<code>Blog</code>，这么做也是为了方面GitHub Actions的自动部署。</p>
<h3 id="资源拷贝"><a href="#资源拷贝" class="headerlink" title="资源拷贝"></a>资源拷贝</h3><p>将以下几个文件/文件夹拷贝到新仓库或者新分支中</p>
<ul>
<li>package.json</li>
<li>.gitignore</li>
<li>themes</li>
<li>source </li>
<li>scaffolds</li>
<li>_config.yml</li>
</ul>
<p><strong>注意点2</strong>：如果你的主题是从GitHub上克隆下来的比如Next主题，那么该文件夹下就会存在<code>.git</code>文件夹，需要将它移除，否则这个主题就不会进入我们Blog的Git管理内容中。其他文件夹下也找一下，如有必要，删除<code>.git</code>文件夹。</p>
<p>到这里我们重新编译一下这个项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装依赖</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>这样我们就可以在本地看到我们的项目，和之前肯定是一样的。</p>
<h3 id="提交分支和新设备管理"><a href="#提交分支和新设备管理" class="headerlink" title="提交分支和新设备管理"></a>提交分支和新设备管理</h3><p>关于提交分支就按着正常的流程来走，这里就不再说了。如果是新设备需要管理该项目的话只要将管理项目的仓库或者分支克隆下来，使用上面的命令就可以。</p>
<p><strong>注意点3</strong>：使用hexo指令后产生的产物一般都是git忽略的，另外使用<code>hexo d</code>进行发布的时候只要确保<code>_cofig.yml</code>的deploy配置还是<code>yourname.github.io</code>的master分支就可以。</p>
<h2 id="使用GitHub-Actions-自动部署-Hexo-博客"><a href="#使用GitHub-Actions-自动部署-Hexo-博客" class="headerlink" title="使用GitHub Actions 自动部署 Hexo 博客"></a>使用GitHub Actions 自动部署 Hexo 博客</h2><p>通过GitHub Actions的配置我们不再需要手动执行<code>hexo clean</code>、<code>hexo d</code>等操作，只需要将修改内容push至远程仓库即可完成网页的更新。</p>
<h3 id="准备仓库"><a href="#准备仓库" class="headerlink" title="准备仓库"></a>准备仓库</h3><ul>
<li><code>yourname.github.io</code>作为公有仓库存放编译之后的静态页面</li>
<li>私有仓库用来存储Hexo项目源代码</li>
</ul>
<h3 id="秘钥配置"><a href="#秘钥配置" class="headerlink" title="秘钥配置"></a>秘钥配置</h3><p>通过<code>ssh-keygen -t rsa -C &quot;Blog Deploy Key&quot;</code>生成一对秘钥。</p>
<h4 id="私有仓库配置私钥"><a href="#私有仓库配置私钥" class="headerlink" title="私有仓库配置私钥"></a>私有仓库配置私钥</h4><p>在 GitHub 上打开私有仓库即保存 Hexo 项目代码的仓库，访问 Settings -&gt; Secrets -&gt; Actions，选择 New repository secret 开始创建 Actions secrets。</p>
<ul>
<li>Name：可以随意填写，但是会在 GitHub Actions Workflow 用到，一定不能写错。</li>
<li>Value：私钥对应的内容</li>
</ul>
<h4 id="公有仓库配置公钥"><a href="#公有仓库配置公钥" class="headerlink" title="公有仓库配置公钥"></a>公有仓库配置公钥</h4><p>在 GitHub 上打开公有仓库即<code>yourname.github.io</code>所在的仓库，访问 Settings -&gt; Deploy keys，选择 Add deploy key 开始创建 Deploy keys。</p>
<ul>
<li>Title：可以随意填写</li>
<li>Key：公钥对应的内容</li>
<li>勾选 Allow write access选项</li>
</ul>
<h3 id="添加Actions配置文件"><a href="#添加Actions配置文件" class="headerlink" title="添加Actions配置文件"></a>添加Actions配置文件</h3><ol>
<li>在你的 Hexo 项目根目录下创建 .github 文件夹。</li>
<li>在 .github 文件夹下创建 workflows 文件夹。</li>
<li>在 workflows 文件夹下创建 xxx.yml 文件。</li>
</ol>
<p>上述三个流程也可以通过Actions下的 New workflow 来完成配置。</p>
<p><code>xxx.yml</code>的内容配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">HEXO</span> <span class="string">DEPLOY</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span>              </span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node</span>        </span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">"13"</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Config</span> <span class="string">Key</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">"$ACTION_DEPLOY_KEY"</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">        <span class="string">chmod</span> <span class="number">700</span> <span class="string">~/.ssh</span></span><br><span class="line">        <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">        <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">"xyh30902@163.com"</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">"NeroXie"</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NPM</span> <span class="string">install</span>       </span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span>           </span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure>
<p>至此，GitHub Actions 自动部署的准备工作已经完成。</p>
<h3 id="触发自动部署"><a href="#触发自动部署" class="headerlink" title="触发自动部署"></a>触发自动部署</h3><ol>
<li>修改你的博客源代码；</li>
<li>将修改的代码push到私有仓库的master分支上（配置项指定了master分支才会触发自动构建）；</li>
<li>GitHub Actions 检测到 master 分支有内容更新，会自动执行配置文件的命令，将 Hexo 项目编译成静态页面，然后部署到公有仓库中。</li>
</ol>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/hexo_deploy_actions.jpg" alt="私有仓库的 Actions"></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2018/12/02/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h2><ol>
<li>静态查找 不需要进行插入删除操作，使用二分查找即可</li>
<li>动态查找 需要执行插入删除操作，使用二分查找树</li>
</ol>
<p><strong>前提是都是有序的</strong>。</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树(BST，Binary Search Tree)， 也称<strong>二叉排序树</strong>或<strong>二叉查找树</strong>。</p>
<p>BST可以为空，非空BST如果不为空，满足以下性质：</p>
<ol>
<li>非空左子树的所有键值小于其根结点的键值。 </li>
<li>非空右子树的所有键值大于其根结点的键值。 </li>
<li>左、右子树都是二叉搜索树。</li>
</ol>
<p>BST操作的特殊函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查找元素x</span><br><span class="line">def Find(root, taregt)</span><br><span class="line"># 查找最大元素</span><br><span class="line">def FindMax(root)</span><br><span class="line"># 查找最小元素</span><br><span class="line">def FindMin(root)</span><br><span class="line"># 插入</span><br><span class="line">def Insert(x, root)</span><br><span class="line"># 删除</span><br><span class="line">def Delete(x, root)</span><br></pre></td></tr></table></figure>
<h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><h3 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Find递归实现</span><br><span class="line">def BSTFindRecursion(self, node, targrt):</span><br><span class="line">    if node is None:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">    if target &gt; node.val:</span><br><span class="line">        return self.BSTFindRecursion(node.right)</span><br><span class="line"></span><br><span class="line">    elif targrt &lt; node.val:</span><br><span class="line">        return self.BSTFindRecursion(node.left)</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        return node</span><br><span class="line"></span><br><span class="line"># 上面的递归是一种伪递归，伪递归可以用迭代实现即循环</span><br><span class="line"># Find非递归实现</span><br><span class="line">def BSTFindNoRecursion(self, node, target):</span><br><span class="line">    while node:</span><br><span class="line">        if target &gt; node.val:</span><br><span class="line">            node = node.right</span><br><span class="line">        elif targrt &lt; node.val:</span><br><span class="line">            node = node.left</span><br><span class="line">        else:</span><br><span class="line">            return node</span><br><span class="line"></span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>
<h3 id="FindMax和FindMin"><a href="#FindMax和FindMin" class="headerlink" title="FindMax和FindMin"></a>FindMax和FindMin</h3><p>BST查找最大元素或者最小元素，只需记住：</p>
<ul>
<li><strong>最大元素一定是在树的最右分枝的端结点上</strong></li>
<li><strong>最小元素一定是在树的最左分枝的端结点上</strong></li>
</ul>
<p>如图所示：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/15398427126604.jpg" alt></p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查找最大元素</span><br><span class="line">def BSTFindMax(self, node):</span><br><span class="line">    if node is None:</span><br><span class="line">        return None</span><br><span class="line">    elif node.right:</span><br><span class="line">        return self.BSTFindMax(node.right)</span><br><span class="line">    else:</span><br><span class="line">        return node</span><br><span class="line"></span><br><span class="line"># 查找最大元素非递归</span><br><span class="line">def BSTFindMaxNoRecursion(self, node):</span><br><span class="line">    if node:</span><br><span class="line">        while node.right:</span><br><span class="line">            node = node.right</span><br><span class="line"></span><br><span class="line">    return node</span><br><span class="line"></span><br><span class="line"># 查找最小元素</span><br><span class="line">def BSTFindMin(self, node):</span><br><span class="line">    if node is None:</span><br><span class="line">        return None</span><br><span class="line">    elif node.left:</span><br><span class="line">        return self.BSTFindMin(node.left)</span><br><span class="line">    else:</span><br><span class="line">        return node</span><br><span class="line"></span><br><span class="line"># 查找最小元素非递归</span><br><span class="line">def BSTFindMinNoRecursion(self, node):</span><br><span class="line">    if node:</span><br><span class="line">        while node.left:</span><br><span class="line">            node = node.left</span><br><span class="line"></span><br><span class="line">    return node</span><br></pre></td></tr></table></figure>
<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>主要是插入位置的选择，这里类似于Find，代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 插入操作递归</span><br><span class="line">def BSTInsert(self, node, x):</span><br><span class="line">    if node is None:</span><br><span class="line">        node = TreeNode(x)</span><br><span class="line"></span><br><span class="line">        return node</span><br><span class="line"></span><br><span class="line">    if node.val &gt; x:</span><br><span class="line">        # 插入的位置位于结点的左边，所以使用node.left</span><br><span class="line">        node.left = self.BSTInsert(node.left, x)</span><br><span class="line">    elif node.val &lt; x:</span><br><span class="line">        # 插入的位置位于结点的左边，所以使用node.right</span><br><span class="line">        node.right = self.BSTInsert(node.right, x)</span><br><span class="line"></span><br><span class="line">    return node</span><br><span class="line"></span><br><span class="line"># 插入操作非递归</span><br><span class="line">def BSTInsertNoRecursion(self, node, x):</span><br><span class="line">    if node is None:</span><br><span class="line">        node = TreeNode(x)</span><br><span class="line"></span><br><span class="line">        return node</span><br><span class="line"></span><br><span class="line">    tmp = node</span><br><span class="line"></span><br><span class="line">    while tmp:</span><br><span class="line">        if tmp.val &gt; x:</span><br><span class="line">            # node = node.left</span><br><span class="line">            if tmp.left:</span><br><span class="line">                tmp = tmp.left</span><br><span class="line">            else:</span><br><span class="line">                tmp.left = TreeNode(x)</span><br><span class="line">                break</span><br><span class="line">        elif tmp.val &lt; x:</span><br><span class="line">            if tmp.right:</span><br><span class="line">                tmp = tmp.right</span><br><span class="line">            else:</span><br><span class="line">                tmp.right = TreeNode(x)</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    return node</span><br></pre></td></tr></table></figure>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>删除操作相对来说复杂一点，需要考虑三种情况：</p>
<ol>
<li>如果是叶子节点的话直接删除，其父节点对应的指针置为空</li>
<li>只有一个子结点，将其父结点对应的指针指向其子结点</li>
<li>如果有两个子结点，寻找一个合适的结点去替代这个被删除的结点<ol>
<li>使用右子树的最小值</li>
<li>使用左子树的最大值</li>
</ol>
</li>
</ol>
<p>为什么第三种情况要这么做？这么做的好处——<strong>左子树的最大值或者右子树的最小值一定不是有两个儿子的结点</strong>。左子树的最大值肯定位于左子树的最右边，右子树的最小值肯定位于右子树的最左边。</p>
<p>举个例子：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/15398595543503.jpg" alt><br>上面树的Delete代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def BSTDelete(self, node, x):</span><br><span class="line">    if node is None:</span><br><span class="line">        return node</span><br><span class="line"></span><br><span class="line">    if node.val &gt; x:</span><br><span class="line">        node.left = self.BSTDelete(node.left, x)</span><br><span class="line">    elif node.val &lt; x:</span><br><span class="line">        node.right = self.BSTDelete(node.right, x)</span><br><span class="line">    else:</span><br><span class="line">        # 说明已经找到这个结点，开始做删除操作</span><br><span class="line">        if node.left and node.right:</span><br><span class="line">            # 这里使用右子树的最小值进行替换</span><br><span class="line">            # 找到对应的值先替换，接着删除原来这个值对应的结点</span><br><span class="line">            tmp = self.BSTFindMin(node.right)</span><br><span class="line">            node.val = tmp.val</span><br><span class="line">            node.right = self.BSTDelete(node.right, node.val)</span><br><span class="line">        else:</span><br><span class="line">            # 有右孩子或者无子结点</span><br><span class="line">            if node.left is None:</span><br><span class="line">                node = node.right</span><br><span class="line">            # 有左孩子或者无子结点</span><br><span class="line">            elif node.right is None:</span><br><span class="line">                node = node.left</span><br><span class="line"></span><br><span class="line">    return node</span><br><span class="line"></span><br><span class="line">def BSTDeleteNoRecursion(self, node, x):</span><br><span class="line">    if node is None:</span><br><span class="line">        return node</span><br><span class="line"></span><br><span class="line">    tmp = node</span><br><span class="line">    while tmp:</span><br><span class="line">        if tmp.val &gt; x:</span><br><span class="line">            tmp = tmp.left</span><br><span class="line">        elif tmp.val &lt; x:</span><br><span class="line">            tmp = tmp.right</span><br><span class="line">        else:</span><br><span class="line">            if tmp.left and tmp.right:</span><br><span class="line">                tmp.val = self.BSTFindMinNoRecursion(tmp.right).val</span><br><span class="line">                tmp.right = tmp.right.right</span><br><span class="line">                x = tmp.val</span><br><span class="line">            else:</span><br><span class="line">                if tmp.left is None:</span><br><span class="line">                    tmp = tmp.right</span><br><span class="line">                elif tmp.right is None:</span><br><span class="line">                    tmp = tmp.left</span><br><span class="line"></span><br><span class="line">    return node</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网通信模型介绍</title>
    <url>/2018/12/02/%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>主流地将互联网络通信分成两种模型：<strong>OSI参考模型</strong>和<strong>TCP/IP模型</strong>。<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" alt></p>
<h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p>OSI参考模型是一个概念模型，由国际标准化组织定义的。一共分成七层，这七层从下到上分别是：</p>
<h4 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a>1.物理层</h4><p>物理层负责管理计算机通信设备之间的互通。它涉及到电压、线缆规范、数据传输速率、接口（这里的接口指的是硬件接口比如RJ45）等的定义。数据在这一层中以比特流的形式存在。</p>
<h4 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a>2.数据链路层</h4><p>数据链路层的主要作用是提供对物理层的控制，检测并纠正可能出现的错误，并且进行流量控制。数据在这一层中以数据帧的形式存在。</p>
<p>在数据链路层工作的协议：以太网、Wi-Fi、PPPoE(早前电话拨号上网)等</p>
<h4 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h4><p>网络层决定传输包的最佳路由，我们使用的路由器就是工作在这一层。至于如何选择路由，网络层通过路由选择协议来计算路由。数据在这一层中以数据包的形式存在。</p>
<h4 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h4><p>传输层的功能就是为会话层提供无差错的传送链路，保证两台设备之间的信息传输。数据在这一层中以数据段的形式存在。</p>
<p>传输层的工作：</p>
<ol>
<li><p>传输层从会话层接受数据，并传递给网络层，如果会话层的数据过大，会将其切成较小的段进行传输。</p>
</li>
<li><p>传输层负责创建端到端的通信连接，通过这一层，通信双方上的应用程序通过对方的地址信息直接进行对话，而不需要考虑网络层经过了多少个节点。</p>
</li>
<li><p>传输层既可以为每个会话层建立一个单独的连接，也可以根据连接的使用情况为多个会话层建立一个单独的连接即多路复用。</p>
</li>
<li><p>传输层更重要的作用是差错校验和重传。包在网络传输可能出现错误或者乱序丢失等情况，传输层必须能检测并更正这些错误。一个数据包在网络中传递的路径可能不一样导致到达的顺序改变。接收方的传输层需要识别出数据包的顺序，并在传递给上层之前将它们恢复成发送时候的顺序。不光需要排序，还需要验证是不是所有的包都被收到，如果出现丢失，则需要重传。</p>
</li>
<li><p>当发送速度超出网络或者接受者的处理能力的时候，传输层还需要负责执行流量控制。</p>
</li>
</ol>
<h4 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5.会话层"></a>5.会话层</h4><p>会话层利用传输层提供的端到端服务，向表示层或者会话用户提供会话服务，说白了就是主机间的通信。会话也处理差错恢复。</p>
<p>如果传输在低层偶尔中断，会话层将努力重新建立连接。</p>
<h4 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6.表示层"></a>6.表示层</h4><p>表示层负责将应用层的信息表示成一种格式，让对端设备能识别，例如将图片表示png的形式；另外表示层还负责加密与压缩。</p>
<h4 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7.应用层"></a>7.应用层</h4><p>应用层直接面对用户或者应用程序，负责对软件提供接口使得程序使用网络服务，包括文件传输、文件管理、电子邮件等。</p>
<h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><p>真正在互联网使用的是TCP/IP模型，它可以看做是OSI参考模型的一个简化。这里穿插一个历史原因，在OSI参考模型提出来的时候，TCP/IP差不多已经是在市场处于主导地位。TCP/IP模型分为四层，分别是：</p>
<h4 id="1-网络接口层"><a href="#1-网络接口层" class="headerlink" title="1. 网络接口层"></a>1. 网络接口层</h4><p>将OSI的第一层和第二层进行合并。</p>
<h4 id="2-网络层"><a href="#2-网络层" class="headerlink" title="2.网络层"></a>2.网络层</h4><p>网络层是TCP/IP体系中的关键部分，作用和OSI参考模型的网络层极其相似。</p>
<p>在网络层中工作的协议：ARP（用来进行IP地址和MAC地址映射，更精确地说它定义在TCP/IP的网络层）、IP协议、ICMP协议、RIP协议、OSPF协议等</p>
<p>这里对ICMP做个简单的介绍：ICMP用来报告IP数据包传输过程中发生的错误、失败等信息，提供网络诊断。为什么这个协议会存在？IP是尽力传输的网络协议，其传输是不可靠、无连接的，如果传输失败了，就需要有种机制进行报错，ICMP的设计就是基于这个问题。ICMP也不是可靠的，也会再传输过程中丢失。ICMP是基于IP运行的，IP数据包中会包含ICMP的数据段，另外ping和traceroute的实现就是基于ICMP的。</p>
<h4 id="3-传输层"><a href="#3-传输层" class="headerlink" title="3.传输层"></a>3.传输层</h4><p>传输层的协议：TCP、UDP、DCCP等</p>
<h4 id="4-应用层"><a href="#4-应用层" class="headerlink" title="4.应用层"></a>4.应用层</h4><p>TCP/IP模型中没有单独的会话层和表示层，会话层和表示层的功能便融合在TCP/IP模型的应用层中。</p>
<p>在应用层工作的协议：FTP、HTTP、DNS、TLS、DHCP等。</p>
<p>这里需要注意的是HTTPS，HTTPS称为（HTTP over TLS，HTTP over SSL或HTTP Secure）。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包，在RFC中并未对HTTPS定义一个新的报文格式，也可以说HTTPS并不是一种协议。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>从源码理解Category、load和initialize</title>
    <url>/2019/07/23/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3Category%E3%80%81load%E5%92%8Cinitialize/</url>
    <content><![CDATA[<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><p>Objective-C中的Category就是对装饰模式的一种具体实现。它的主要作用是在不改变原有类的前提下，动态地给这个类添加一些方法。</p>
<p>先看一段代码，后面的关于Category的分析都是基于以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// CategoryTestModel.h </span><br><span class="line">@interface CategoryTestModel : NSObject</span><br><span class="line"></span><br><span class="line">- (void)ins_method1;</span><br><span class="line">+ (void)cls_method1;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface CategoryTestModel(NN)</span><br><span class="line"></span><br><span class="line">- (void)ins_method2;</span><br><span class="line">- (void)ins_method22;</span><br><span class="line">+ (void)cls_method2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface CategoryTestModel(Nero)</span><br><span class="line"></span><br><span class="line">- (void)ins_method3;</span><br><span class="line">+ (void)cls_method3;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// CategoryTestModel.m</span><br><span class="line">@implementation CategoryTestModel</span><br><span class="line"></span><br><span class="line">- (void)ins_method1 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)cls_method1 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation CategoryTestModel(NN)</span><br><span class="line"></span><br><span class="line">- (void)ins_method2 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)ins_method22 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)cls_method2 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation CategoryTestModel(Nero)</span><br><span class="line"></span><br><span class="line">- (void)ins_method3 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)cls_method3 &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>上面的代码声明了一个<code>CategoryTestModel</code>的类以及<code>NN</code>和<code>Nero</code>两个分类，接着我们使用如下命令将这些代码转化成C++代码：<br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc CategoryTestModel.m</code></p>
<h3 id="Category的底层结构"><a href="#Category的底层结构" class="headerlink" title="Category的底层结构"></a>Category的底层结构</h3><p>在C++代码中，我们会发现有以下关键代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// NN分类</span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_CategoryTestModel_$_NN __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = </span><br><span class="line">&#123;</span><br><span class="line">	&quot;CategoryTestModel&quot;,</span><br><span class="line">	0, // &amp;OBJC_CLASS_$_CategoryTestModel,</span><br><span class="line">	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_CategoryTestModel_$_NN,</span><br><span class="line">	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_CategoryTestModel_$_NN,</span><br><span class="line">	0,</span><br><span class="line">	0,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Nero分类</span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_CategoryTestModel_$_Nero __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = </span><br><span class="line">&#123;</span><br><span class="line">	&quot;CategoryTestModel&quot;,</span><br><span class="line">	0, // &amp;OBJC_CLASS_$_CategoryTestModel,</span><br><span class="line">	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_CategoryTestModel_$_Nero,</span><br><span class="line">	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_CategoryTestModel_$_Nero,</span><br><span class="line">	0,</span><br><span class="line">	0,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从源码中可以知道，分类转化成了<code>_category_t</code>类型的结构体，并且有几个分类，就会对应生成几个这样的结构体。这里有一点要说明一下，在objc的代码中也可以找到关于分类的结构体介绍，结构体名叫<code>category_t</code>，并成员变量稍微有点差异，但是不影响对底层实现的学习。</p>
<p><code>_category_t</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">	const char *name;</span><br><span class="line">	struct _class_t *cls;</span><br><span class="line">	const struct _method_list_t *instance_methods;</span><br><span class="line">	const struct _method_list_t *class_methods;</span><br><span class="line">	const struct _protocol_list_t *protocols;</span><br><span class="line">	const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以看出<code>_category_t</code>结构体中存放着类名，主类名，对象方法列表，类方法列表，协议列表，以及属性列表。</p>
<p>在我们声明的分类中，只有对象方法和类方法，所以我们看一下<code>_method_list_t</code>。<br><code>_method_list_t</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 对象方法存储</span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">	unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">	unsigned int method_count;</span><br><span class="line">	struct _objc_method method_list[2];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_CategoryTestModel_$_NN __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">	sizeof(_objc_method),</span><br><span class="line">	2,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)&quot;ins_method2&quot;, &quot;v16@0:8&quot;, (void *)_I_CategoryTestModel_NN_ins_method2&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)&quot;ins_method22&quot;, &quot;v16@0:8&quot;, (void *)_I_CategoryTestModel_NN_ins_method22&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 类方法存储</span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">	unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">	unsigned int method_count;</span><br><span class="line">	struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_CLASS_METHODS_CategoryTestModel_$_NN __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">	sizeof(_objc_method),</span><br><span class="line">	1,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)&quot;cls_method2&quot;, &quot;v16@0:8&quot;, (void *)_C_CategoryTestModel_NN_cls_method2&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过上面的一系列源码，我们知道了如下几点：</p>
<ul>
<li>Category的底层结构是一个<code>_category_t</code>的结构体，我们在分类中声明的方法、属性等都会存在对应的字段中；</li>
<li>有多少个分类就会有多少的<code>_category_t</code>结构体。</li>
</ul>
<p>到这里就不免会出现一个疑问：<br>在我们将代码转化成C++代码后，一个类有其主类<code>_class_t</code>还有N个<code>_category_t</code>的分类。主类方法存在主类的结构中，分类方法存在分类的结构体中。我们打印其方法列表的时候，分类方法也会打印出来，另外我们在日常开发中，有时也会使用分类去覆盖掉主类实现的方法，那这又是为什么？上面所讲的只是编译期的过程，Category的实现还依赖于Runtime。</p>
<p>这里插一个题外话，在日常开发的时候，在一些比较麻烦的时候我们可能会使用方法交叉，我们也知道方法交叉是比较危险的手段，还是少用为妙。而上面提到的使用分类去覆盖掉主类实现的方法也是能减少方法交叉的使用。</p>
<h3 id="Category在运行时中"><a href="#Category在运行时中" class="headerlink" title="Category在运行时中"></a>Category在运行时中</h3><p>这里使用<code>objc4-750.1</code>的源代码，你可以通过<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">这里</a>下载。在<code>objc-runtime-new.m</code>中找到一个<code>_read_images</code>的函数，由于代码很长，这里只贴出关于分类的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    // 这里只显示category的实现</span><br><span class="line">        // Discover categories. </span><br><span class="line">    for (EACH_HEADER) &#123;</span><br><span class="line">        // 二维数组存在分类结构体变量</span><br><span class="line">        category_t **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        // 判断是否有类属性</span><br><span class="line">        bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            // 获取分类的主类</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">            // 主类不存在进行下一次循环</span><br><span class="line">            if (!cls) &#123;</span><br><span class="line">                // Category&apos;s target class is missing (probably weak-linked).</span><br><span class="line">                // Disavow any knowledge of this category.</span><br><span class="line">                catlist[i] = nil;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br><span class="line">                                 &quot;missing weak-linked target class&quot;, </span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Process this category. </span><br><span class="line">            // First, register the category with its target class. </span><br><span class="line">            // Then, rebuild the class&apos;s method lists (etc) if </span><br><span class="line">            // the class is realized. </span><br><span class="line">            bool classExists = NO;</span><br><span class="line">            // 分类中存在对象方法，协议或者属性，</span><br><span class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                // 给主类添加独立的分类</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                // 类是否实现</span><br><span class="line">                if (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    // 对类进行方法化</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 分类中存在类方法，协议或者类属性</span><br><span class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                // 给主类的元类添加独立的分类</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                // 主类的元类是否实现</span><br><span class="line">                if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    // 对元类进行方法化</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(&quot;IMAGE TIMES: discover categories&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过<code>_getObjc2CategoryList</code>函数获取到分类列表；</li>
<li>遍历分类列表获取其中的方法，协议，属性等；</li>
<li>调用<code>remethodizeClass(cls)</code>函数对类对象（分类的主类）重新方法化；</li>
<li>调用<code>remethodizeClass(cls-&gt;ISA());</code>对类对象的元类重新方法化；</li>
</ol>
<p>可以看到最终都调用了<code>remethodizeClass</code>函数，接着我们看一下<code>remethodizeClass</code>的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 附加分类</span><br><span class="line">        attachCategories(cls, cats, true /*flush caches*/);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>remethodizeClass</code>的实现主要依赖于<code>attachCategories</code>，从函数名我们可以知道这个函数，就是用来给类或者元类添加分类中存放的数据。<code>attachCategories</code>的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void </span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">    // 方法列表 [[方法],[方法，方法],[方法]]</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    // 属性列表</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    // 协议列表</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    // 分类列表的个数代表有多少个分类</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        // 根据是否是元类返回分类结构体中的类方法列表或者对象方法列表</span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 根据是否是元类返回分类结构体中的类属性列表或者属性列表</span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // rw代表类对象，里面有一个方法列表和属性列表的字段</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    // 将上面合并后的分类方法合并到类对象的方法列表中，并释放mlists</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    // 是否刷新缓存</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    // 将所有分类属性合并到类对象的属性列表中</span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    // 协议也是如此</span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看到，方法、属性、协议的合并都使用了<code>attachLists</code>方法，其实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">    if (addedCount == 0) return;</span><br><span class="line">    </span><br><span class="line">    if (hasArray()) &#123;</span><br><span class="line">        // many lists -&gt; many lists</span><br><span class="line">        uint32_t oldCount = array()-&gt;count;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        // 重新分配内存，数组扩容</span><br><span class="line">        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        // array()-&gt;lists是原来的数组</span><br><span class="line">        // memmove的作用就是内存移动，将原来的数组向后拖动oldCount * sizeof(array()-&gt;lists[0])个位置</span><br><span class="line">        memmove(array()-&gt;lists + addedCount, array()-&gt;lists,</span><br><span class="line">                oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">        // memcpy的作用是内存拷贝，将新数组拷贝到前面空出的位置</span><br><span class="line">        memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">               addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!list  &amp;&amp;  addedCount == 1) &#123;</span><br><span class="line">        // 0 lists -&gt; 1 list</span><br><span class="line">        list = addedLists[0];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // 1 list -&gt; many lists</span><br><span class="line">        List* oldList = list;</span><br><span class="line">        uint32_t oldCount = oldList ? 1 : 0;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        if (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">               addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于上述关于合并的实现分成了三种情况，但是思想都接近，简单的说就是数组合并。分析这段代码是为了解释为什么我们可以在分类中重写方法来覆盖主类的实现。</p>
<p>这里我们就以分类方法在<code>many lists -&gt; many lists</code>的情况下来分析一下这个流程。</p>
<ol>
<li>首页分配一块内存用来数组扩容，扩容后的长度就是类对象的方法列表的长度加上分类方法列表的长度；</li>
<li>调用<code>memmove</code>，将原来的方法列表向后拖动oldCount * sizeof(array()-&gt;lists[0])个位置；</li>
<li>调用<code>memcpy</code>，将分类方法列表拷贝在前面空出的位置。</li>
</ol>
<p>用一张图表示下上面的情况：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/category_attachList.jpg" alt="category_attachList"></p>
<h2 id="Categoty总结"><a href="#Categoty总结" class="headerlink" title="Categoty总结"></a>Categoty总结</h2><p>这里再总结一下Categoty的一些知识点：</p>
<ol>
<li>Category在编译时期会转化成<code>_category_t</code>的结构体，我们在分类中声明的方法、属性等都会存在对应的字段中；</li>
<li>在程序运行时，runtime会将Category的数据合并到类对象或者元类对象中； </li>
<li>分类方法列表在主类方法列表的前面，所以<strong>分类的同名方法会被优先被调用</strong>或者<strong>分类中重写方法能覆盖主类的实现</strong>。</li>
<li>分类列表中越后面的分类即越后面参与编译的分类，其方法列表中的方法会越优先被调用。</li>
<li><strong>分类中的属性也是在运行时的时候完成的</strong>，这要区别于Extension。Extension可以理解为将.h文件中的共有属性声明在.m中变成私有的，那这些属性也是在编译期完成的。所以Category和Extension的区别就是<strong>Extension在编译时期，它的数据就包含在类信息中，Category中的数据是在运行时才合并到类中</strong>。</li>
</ol>
<p>但是有两个方法比较特殊，分别是<code>load</code>和<code>initialize</code>，它们的执行结果和一般方法有区别，所以单独拿出来分析。</p>
<h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><p>首先看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// FatherA</span><br><span class="line">@implementation FatherA</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FatherA(NN)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FatherA(Nero)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// SonA</span><br><span class="line">@implementation SonA</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SonA(NN)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SonA(Nero)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// FatherB</span><br><span class="line">@implementation FatherB</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SonB</span><br><span class="line">@implementation SonB</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译顺序如下：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/category%E7%BC%96%E8%AF%91%E9%A1%BA%E5%BA%8F.jpg" alt="load编译顺序"></p>
<p>执行结果如下：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/category_load%E9%A1%BA%E5%BA%8F.jpg" alt="load执行顺序"></p>
<p>以<code>FatherA</code>为例，我们知道<code>load</code>方法会在runtime加载类、分类的时候进行调用，根据上面提到的分类会覆盖主类的同名方法（这里并不是真的覆盖，而是优先于主类先调用），<code>load</code>函数应该只是被调用一次，但是通过上面的代码我们看到<code>load</code>方法被调用了三次，这是为什么呢？</p>
<p><code>load</code>方法的实现在<code>objc-runtime-new.m</code>中找到一个<code>load_images</code>的函数，其实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// load_images</span><br><span class="line">void</span><br><span class="line">load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    // Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    // Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的实现主要依赖于<code>prepare_load_methods</code>和<code>call_load_methods</code>。<code>prepare_load_methods</code>用来查找<code>load</code>方法并确定其调用顺序，<code>call_load_methods</code>用来调用<code>load</code>方法。</p>
<h3 id="prepare-load-methods"><a href="#prepare-load-methods" class="headerlink" title="prepare_load_methods"></a>prepare_load_methods</h3><p>我们先看一下<code>prepare_load_methods</code>的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // 获取所有的类，classlist中类的顺序按照谁先编译，谁就在数组的前面</span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        // 规划类的加载，即确定+load方法的调用顺序</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取所有的分类</span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        if (!cls) continue;  // category for ignored weak-linked class</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        // 将实现了+load方法的分类添加到loadable_categories数组的最后面</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>prepare_load_methods</code>的实现可以分为两个步骤：</p>
<ol>
<li>获取所有的类，调用<code>schedule_class_load</code>；</li>
<li>获取所有的分类，调用<code>add_category_to_loadable_list</code>， <code>add_category_to_loadable_list</code> 将实现了<code>+load</code>方法的分类添加到<code>loadable_categories</code>数组的最后面，<code>loadable_categories</code>用来在<code>call_load_methods</code>进行分类<code>+load</code>方法的调用。</li>
</ol>
<p>上面代码中，关于<code>classlist</code>和<code>categorylist</code>这两个数组中的元素的顺序是根据类或者分类被编译的顺序分别进入对应数组中的。</p>
<h4 id="类load方法的调用顺序"><a href="#类load方法的调用顺序" class="headerlink" title="类load方法的调用顺序"></a>类load方法的调用顺序</h4><p>确定类<code>load</code>方法的调用顺序，依赖于<code>schedule_class_load</code>，其实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// schedule_class_load是一个递归函数</span><br><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());  // _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    // Ensure superclass-first ordering</span><br><span class="line">    // 沿着cls的父类一直往上查找知道NSObject</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    // 将实现了+load的cls添加到loadable_classes的最后面</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>schedule_class_load</code>是一个递归函数，它会沿着cls的父类一直往上查找知道NSObject，接着调用<code>add_class_to_loadable_list</code>将实现了<code>+load</code>方法的cls添加到<code>loadable_classes</code>的最后面。这也就解释了为什么父类的<code>load</code>方法为什么会优先于子类的<code>load</code>方法被调用。</p>
<p>接着再看一下<code>add_class_to_loadable_list</code>的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这个结构体中的method专门存放类中的+load方法</span><br><span class="line">struct loadable_class &#123;</span><br><span class="line">    Class cls;  // may be nil</span><br><span class="line">    IMP method;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void add_class_to_loadable_list(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    if (!method) return;  // Don&apos;t bother if cls has no +load method</span><br><span class="line">    </span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(&quot;LOAD: class &apos;%s&apos; scheduled for +load&quot;, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*2 + 16;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              sizeof(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码的作用就是通过传入的<code>cls</code>生成一个对应的<code>loadable_class</code>结构体，并将这个结构体加在<code>loadable_classes</code>的最后面，<code>loadable_class</code>这个结构体中的<code>method</code>专门存放类中的<code>+load</code>方法。</p>
<h4 id="分类load方法的调用顺序"><a href="#分类load方法的调用顺序" class="headerlink" title="分类load方法的调用顺序"></a>分类load方法的调用顺序</h4><p>分类load方法的调用顺序就是遍历获取到的分类列表，通过<code>add_category_to_loadable_list</code> 将实现了<code>+load</code>方法的分类添加到<code>loadable_categories</code>数组的最后面。<code>add_category_to_loadable_list</code>的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这个结构体中的method专门存放分类中的+load方法</span><br><span class="line">struct loadable_category &#123;</span><br><span class="line">    Category cat;  // may be nil</span><br><span class="line">    IMP method;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void add_category_to_loadable_list(Category cat)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = _category_getLoadMethod(cat);</span><br><span class="line"></span><br><span class="line">    // Don&apos;t bother if cat has no +load method</span><br><span class="line">    if (!method) return;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(&quot;LOAD: category &apos;%s(%s)&apos; scheduled for +load&quot;, </span><br><span class="line">                     _category_getClassName(cat), _category_getName(cat));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (loadable_categories_used == loadable_categories_allocated) &#123;</span><br><span class="line">        loadable_categories_allocated = loadable_categories_allocated*2 + 16;</span><br><span class="line">        loadable_categories = (struct loadable_category *)</span><br><span class="line">            realloc(loadable_categories,</span><br><span class="line">                              loadable_categories_allocated *</span><br><span class="line">                              sizeof(struct loadable_category));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">    loadable_categories[loadable_categories_used].method = method;</span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>add_category_to_loadable_list</code>函数和<code>add_class_to_loadable_list</code>函数的实现逻辑很相似，这个就不做说明了。</p>
<p>这里总结一下<code>load</code>方法的调用顺序：</p>
<ul>
<li>对于重写了<code>+load</code>方法的类来说，其<code>load</code>方法的调用顺序是<strong>先编译的类的父类 &gt; 先编译的类 &gt; 后编译的类的父类 &gt; 后编译的类</strong>；</li>
<li>对于重写了<code>+load</code>方法的类来说，其<code>load</code>方法的调用顺序是谁先被编译，谁就优先被调用。</li>
</ul>
<p>当确定好了<code>load</code>的调用顺序了以后，就需要调用<code>load</code>方法。</p>
<h3 id="call-load-methods"><a href="#call-load-methods" class="headerlink" title="call_load_methods"></a>call_load_methods</h3><p>接着我们看一下<code>call_load_methods</code>的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading = NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    void *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        // 1. Repeatedly call class +loads until there aren&apos;t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            // 调用类的load方法</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. Call category +loads ONCE</span><br><span class="line">        // 调用分类的load方法</span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        // 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>call_load_methods</code>函数也是分为两个步骤：</p>
<ol>
<li>使用<code>call_class_loads</code>调用类的<code>load</code>方法；</li>
<li>使用<code>call_category_loads</code>调用分类的<code>load</code>方法。</li>
</ol>
<h4 id="call-class-loads"><a href="#call-class-loads" class="headerlink" title="call_class_loads"></a>call_class_loads</h4><p><code>call_class_loads</code>的实现如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    // Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes = loadable_classes;</span><br><span class="line">    int used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = 0;</span><br><span class="line">    loadable_classes_used = 0;</span><br><span class="line">    </span><br><span class="line">    // Call all +loads for the detached list.</span><br><span class="line">    // 遍历loadable_classes列表调用+load方法，数组中越前面的元素越先被调用</span><br><span class="line">    // 根据schedule_class_load的递归查找还可以知道，父类的load方法要先于子类进行调用</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        // 取出类中的load方法</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        // 使用指针进行调用</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Destroy the detached list.</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>call_class_loads</code>函数通过遍历<code>遍历loadable_classes</code>列表调用<code>+load</code>方法，数组中越前面的元素越先被调用。通过<code>load_method_t</code>可以获取类的<code>load</code>方法，<code>load_method_t</code>的定义为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef void(*load_method_t)(id, SEL);</span><br></pre></td></tr></table></figure>
<p><code>load_method_t</code>是指向函数的指针，相当于返回的是一个函数地址。获取到函数指针后，使用<code>(*load_method)(cls, SEL_load);</code>调用<code>load</code>方法。所以说，<strong>load方法的调用并不是使用消息发送机制，而是直接使用函数指针调用</strong>。</p>
<h4 id="call-category-loads"><a href="#call-category-loads" class="headerlink" title="call_category_loads"></a>call_category_loads</h4><p><code>call_category_loads</code>用来调用分类的<code>load</code>方法，其实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static bool call_category_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, shift;</span><br><span class="line">    bool new_categories_added = NO;</span><br><span class="line">    </span><br><span class="line">    // Detach current loadable list.</span><br><span class="line">    struct loadable_category *cats = loadable_categories;</span><br><span class="line">    int used = loadable_categories_used;</span><br><span class="line">    int allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = nil;</span><br><span class="line">    loadable_categories_allocated = 0;</span><br><span class="line">    loadable_categories_used = 0;</span><br><span class="line"></span><br><span class="line">    // Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        // 取出分类中的load方法，返回值是一个函数地址</span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        if (!cat) continue;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        if (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">            if (PrintLoading) &#123;</span><br><span class="line">                _objc_inform(&quot;LOAD: +[%s(%s) load]\n&quot;, </span><br><span class="line">                             cls-&gt;nameForLogging(), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            &#125;</span><br><span class="line">            // 使用指针进行调用</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Compact detached list (order-preserving)</span><br><span class="line">    shift = 0;</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        if (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift;</span><br><span class="line"></span><br><span class="line">    // Copy any new +load candidates from the new list to the detached list.</span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; 0);</span><br><span class="line">    for (i = 0; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        if (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*2 + 16;</span><br><span class="line">            cats = (struct loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  sizeof(struct loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以下代码是一些释放代码，可以忽略</span><br><span class="line">    // Destroy the new list.</span><br><span class="line">    if (loadable_categories) free(loadable_categories);</span><br><span class="line"></span><br><span class="line">    // Reattach the (now augmented) detached list. </span><br><span class="line">    // But if there&apos;s nothing left to load, destroy the list.</span><br><span class="line">    if (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (cats) free(cats);</span><br><span class="line">        loadable_categories = nil;</span><br><span class="line">        loadable_categories_used = 0;</span><br><span class="line">        loadable_categories_allocated = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        if (loadable_categories_used != 0) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: %d categories still waiting for +load\n&quot;,</span><br><span class="line">                         loadable_categories_used);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="load总结"><a href="#load总结" class="headerlink" title="load总结"></a>load总结</h2><p>这里再总结一下load方法的一些知识点：</p>
<ol>
<li>load方法会在runtime加载类、分类的时候进行调用，不需要引入，只要被加载进内存就会被调用；</li>
<li>每一个类、分类的load，在程序运行过程中只会被调用一次；</li>
<li>先调用类的load方法，调用顺序：先编译的类的父类 &gt; 先编译的类 &gt; 后编译的类的父类 &gt; 后编译的类；</li>
<li>再调用分类的load方法，调用顺序：谁先被编译，谁就优先被调用；</li>
<li>load方法的调用本质是使用函数地址直接进行调用，而不是使用<code>objc_msgSend</code>的方式。</li>
</ol>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h2><p><code>initialize</code>的测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// FatherA</span><br><span class="line">@implementation FatherA</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FatherA(NN)</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FatherA(Nero)</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// SonA</span><br><span class="line">@implementation SonA</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SonA(NN)</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SonA(Nero)</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// FatherB</span><br><span class="line">@implementation FatherB</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SonB</span><br><span class="line">@implementation SonB</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道<code>initialize</code>方法会在类第一次接收到消息的时候被调用，所以我们使用如下代码进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 测试代码</span><br><span class="line">[SonA alloc];</span><br><span class="line">[SonA alloc];</span><br><span class="line">[SonA alloc];</span><br><span class="line">    </span><br><span class="line">[FatherB alloc];</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/category_initialize%E9%A1%BA%E5%BA%8F.jpg" alt="initialize执行顺序"></p>
<p>通过上面的代码可以知道：</p>
<ol>
<li>initialize方法会在类第一次接收到消息的时候被调用，所以类的initialize可能永远不会被调用；</li>
<li>父类的initialize会优先于子类被调用；</li>
<li>分类的initialize会覆盖掉主类的initialize（这也符合之前分类的方法调用顺序）；</li>
</ol>
<h3 id="initialize的实现"><a href="#initialize的实现" class="headerlink" title="initialize的实现"></a>initialize的实现</h3><p><code>initialize</code>方法的实现在<code>objc-runtime-new.m</code>中找到一个<code>lookUpImpOrForward</code>的函数，其中有如下关键代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    // If sel == initialize, _class_initialize will send +initialize and</span><br><span class="line">    // then the messenger will send +initialize again after this</span><br><span class="line">    // procedure finishes. Of course, if this is not being called</span><br><span class="line">    // from the messenger then it won&apos;t happen. 2778172</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法调用过程中，如果类没有被初始化的时候，会调用<code>_class_initialize</code>对类进行初始化，其中有两块关键代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* class_initialize.  Send the &apos;+initialize&apos; message on demand to any</span><br><span class="line">* uninitialized class. Force initialization of superclasses first.</span><br><span class="line">**********************************************************************/</span><br><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    // See note about deadlock above.</span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        // 沿着cls的父类一直往上查找知道NSObject</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">            //  使用objc_msgSend调用initialize方法</span><br><span class="line">            callInitialize(cls);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_class_initialize</code>方法会进行递归调用，由此可以确保父类优先于子类初始化。接着调用<code>callInitialize</code>函数，其实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以<code>initialize</code>的调用方式是<code>objc_msgSend</code>，它和普通方法一样是由Runtime通过发消息的形式。</p>
<h2 id="initialize总结"><a href="#initialize总结" class="headerlink" title="initialize总结"></a>initialize总结</h2><p>这里再总结一下initialize方法的一些知识点：</p>
<ol>
<li>initialize方法会在类第一次接收到消息的时候被调用，所以类的initialize可能永远不会被调用；</li>
<li>initialize调用顺序： 父类的initialize会优先于子类被调用，且分类的initialize会覆盖主类的initialize，那么就会对这个类中的实现造成覆盖；</li>
<li>如果子类没有实现initialize方法，那么继承自父类的实现会被调用即父类的initialize可能被调用多次；</li>
<li>如果我们想确保自己的<code>initialize</code>方法只执行一次，避免多次执行可能带来的副作用时，我们可以使用下面的代码来实现：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">  if (self == [ClassName self]) &#123;</span><br><span class="line">    // ... do the initialization ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后总结一下load和initialize区别</p>
<table>
<thead>
<tr>
<th>/</th>
<th>load</th>
<th>initialize</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用时机</td>
<td>加载到runtime时</td>
<td>收到第一条消息时，可能永远不调用</td>
</tr>
<tr>
<td>调用本质</td>
<td>函数地址调用</td>
<td>objc_msgSend发送消息</td>
</tr>
<tr>
<td>调用顺序</td>
<td>父类 &gt; 类 &gt; 分类</td>
<td>父类 &gt; 类</td>
</tr>
<tr>
<td>调用次数</td>
<td>一次</td>
<td>一次或者多次</td>
</tr>
<tr>
<td>分类的中实现</td>
<td>类和分类都执行</td>
<td>“覆盖”主类中的实现</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>从源码理解关联对象</title>
    <url>/2019/07/23/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3%E5%85%B3%E8%81%94%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>在类中，我们使用<code>@property (nonatomic, copy) NSString *name</code>生成一个属性。它干了三件事情：</p>
<ol>
<li>声明一个<code>_name</code>的变量；</li>
<li>声明<code>setName:</code>和<code>getName</code>方法；</li>
<li>setter和getter方法的默认实现；</li>
</ol>
<p>但是在分类中写上述这样一个属性的，它只有setter和getter方法的声明，并不会生成成员变量和实现setter和getter方法，因此如果想要在分类中实现属性的话得使用关联对象的方式。</p>
<h2 id="关联对象的使用"><a href="#关联对象的使用" class="headerlink" title="关联对象的使用"></a>关联对象的使用</h2><p>首先我们要明白<strong>为什么要使用关联对象</strong>？<br>在分类中<code>@property</code>并不会自动生成实例变量以及存取方法，另外在分类是不能声明成员变量的。从源码的角度去看，Category在编译时期生成的结构体中根本没有存放成员变量的数组。基于上面的原因，如果我们要实现类中属性那样的效果，就要使用关联对象。</p>
<p>关联对象的应用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// .h</span><br><span class="line">@interface FatherA : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .m</span><br><span class="line">@implementation FatherA</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(self,</span><br><span class="line">                             @selector(name),</span><br><span class="line">                             name,</span><br><span class="line">                             OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="关联对象的实现"><a href="#关联对象的实现" class="headerlink" title="关联对象的实现"></a>关联对象的实现</h2><p>这里使用<code>objc4-750.1</code>的源代码，你可以通过<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">这里</a>下载。我们常用的关于关联对象的API主要有以下几个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);</span><br><span class="line">id objc_getAssociatedObject(id object, const void *key);</span><br><span class="line">void objc_removeAssociatedObjects(id object);</span><br></pre></td></tr></table></figure>
<p>这三个方法的作用分别是：</p>
<ul>
<li>以键值对形式添加关联对象</li>
<li>根据key获取关联对象</li>
<li>移除所有关联对象</li>
</ul>
<h3 id="关联对象的核心对象"><a href="#关联对象的核心对象" class="headerlink" title="关联对象的核心对象"></a>关联对象的核心对象</h3><p>在分析关联对象的API实现之前，先看一下关联对象的核心对象。</p>
<h4 id="AssociationsManager"><a href="#AssociationsManager" class="headerlink" title="AssociationsManager"></a>AssociationsManager</h4><p><code>AssociationsManager</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spinlock_t AssociationsManagerLock;</span><br><span class="line"></span><br><span class="line">class AssociationsManager &#123;</span><br><span class="line">    // associative references: object pointer -&gt; PtrPtrHashMap.</span><br><span class="line">    static AssociationsHashMap *_map;</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; AssociationsManagerLock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; AssociationsManagerLock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        if (_map == NULL)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AssociationsHashMap *AssociationsManager::_map = NULL;</span><br></pre></td></tr></table></figure>
<p><code>AssociationsManager</code>会维护一个<code>AssociationsHashMap</code>，在初始化的时候，调用<code>AssociationsManagerLock.lock()</code>，在析构时会调用<code>AssociationsManagerLock.unlock()</code>，而<code>associations</code>用于取得一个全局的<code>AssociationsHashMap</code>。</p>
<p>另外<code>AssociationsManager</code>通过一个自旋锁<code>spinlock_t AssociationsManagerLock</code>来确保对<code>AssociationsHashMap</code>的操作是线程安全的。</p>
<h4 id="AssociationsHashMap"><a href="#AssociationsHashMap" class="headerlink" title="AssociationsHashMap"></a>AssociationsHashMap</h4><p><code>HashMap</code>相当于OC中的<code>NSDictionary</code>。<code>AssociationsHashMap</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void *operator new(size_t n) &#123; return ::malloc(n); &#125;</span><br><span class="line">    void operator delete(void *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>AssociationsHashMap</code>继承自<code>unordered_map</code>，使用的是C++语法。它的作用就是保存从对象的<code>disguised_ptr_t</code>到<code>ObjectAssociationMap</code>的映射。 我们可以理解为<strong>AssociationsHashMap以key-value的形式存着若干个ObjectAssociationMap</strong>。</p>
<h4 id="ObjectAssociationMap"><a href="#ObjectAssociationMap" class="headerlink" title="ObjectAssociationMap"></a>ObjectAssociationMap</h4><p><code>ObjectAssociationMap</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void *operator new(size_t n) &#123; return ::malloc(n); &#125;</span><br><span class="line">    void operator delete(void *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ObjectAssociationMap</code>保存了从<code>key</code>到<code>ObjcAssociation</code>的映射，我们可以理解为<strong>ObjectAssociationMap以key-value的形式存着若干个ObjcAssociation对象</strong>。这个数据结构保存了当前对象对应的所有关联对象：</p>
<h4 id="ObjcAssociation"><a href="#ObjcAssociation" class="headerlink" title="ObjcAssociation"></a>ObjcAssociation</h4><p><code>ObjcAssociation</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ObjcAssociation &#123;</span><br><span class="line">    uintptr_t _policy;</span><br><span class="line">    id _value;</span><br><span class="line">public:</span><br><span class="line">    ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">    ObjcAssociation() : _policy(0), _value(nil) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    uintptr_t policy() const &#123; return _policy; &#125;</span><br><span class="line">    id value() const &#123; return _value; &#125;</span><br><span class="line">    </span><br><span class="line">    bool hasValue() &#123; return _value != nil; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ObjcAssociation</code>对象保存了对象对应的关联对象，其中的<code>_policy</code>和<code>_value</code>字段存的便是我们使用<code>objc_setAssociatedObject</code>方法时传入的<code>policy</code>和<code>value</code>。</p>
<h3 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a>objc_setAssociatedObject</h3><p>通过<code>objc_setAssociatedObject</code>函数，我们添加一个关联对象，其实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (void *)key, value, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看一下<code>_object_set_associative_reference</code>的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    // retain the new value (if any) outside the lock.</span><br><span class="line">    // 创建一个ObjcAssociation局部变量，持有原有的关联对象和最后的释放</span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">    // 调用acquireValue对new_value进行retain或者copy</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        // 初始化一个AssociationsManager，并获取AssociationsHashMap</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        // disguised_ptr_t是AssociationsHashMap中的key，通过传入的object得到</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        </span><br><span class="line">        // new_value有值代表设置或者更新关联对象的值，否则表示删除一个关联对象</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            // break any existing association.</span><br><span class="line">            // 查找ObjectAssociationMap</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i != associations.end()) &#123;</span><br><span class="line">                // secondary table exists</span><br><span class="line">                // ObjectAssociationMap存在</span><br><span class="line">                // 判断key是否存在，key存在更新原有的关联对象，key不存在，则新增，并且新增的位置需要结合end()</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // create the new association (first time).</span><br><span class="line">                // ObjectAssociationMap不存在</span><br><span class="line">                // 初始化一个ObjectAssociationMap，再实例化ObjcAssociation对象添加到Map中，并调用 setHasAssociatedObjects函数</span><br><span class="line">                // setHasAssociatedObjects标明当前类具有关联类 </span><br><span class="line">                // 它会将isa结构体中的has_assoc标记为true</span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // setting the association to nil breaks the association.</span><br><span class="line">            // 查找ObjectAssociationMap</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                // ObjectAssociationMap存在</span><br><span class="line">                // 判断key是否存在，key存在则调用erase函数来删除ObjectAssociationMap中key对应的节点</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // release the old value (outside of the lock).</span><br><span class="line">    // 原来的关联对象有值，调用ReleaseValue函数释放关联对象的值</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的源码以及注释可以知道<code>objc_setAssociatedObject</code>的流程，接着我们用一张图片来说明关联对象的原理：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E5%8E%9F%E7%90%86.png" alt="关联对象原理"></p>
<h3 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h3><p>在理解了<code>objc_setAssociatedObject</code>的实现之后，<code>objc_getAssociatedObject</code>就变得容易理解了，其实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key) &#123;</span><br><span class="line">    return _object_get_associative_reference(object, (void *)key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看一下<code>_object_get_associative_reference</code>的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, void *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        // 初始化一个AssociationsManager，并获取AssociationsHashMap</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        // 通过object获得disguised_ptr_t，用作在AssociationsHashMap的key</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        // 查找ObjectAssociationMap的位置</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        if (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            // 查找ObjcAssociation对象</span><br><span class="line">            if (j != refs-&gt;end()) &#123;</span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value();</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                // 说明是强类型，retain操作</span><br><span class="line">                if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</span><br><span class="line">                    objc_retain(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        // autorelease</span><br><span class="line">        objc_autorelease(value);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h3><p><code>objc_removeAssociatedObjects</code>用来删除所有的关联对象，其实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object) </span><br><span class="line">&#123;</span><br><span class="line">    if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>hasAssociatedObjects</code>函数判断是否含有关联对象，如果有则调用<code>_object_remove_assocations</code>。</p>
<p>在<code>objc_setAssociatedObject</code>的实现中有提到在添加关联对象的时候如果<code>ObjectAssociationMap</code>不存在，则会初始化一个<code>ObjectAssociationMap</code>，再实例化<code>ObjcAssociation</code>对象添加到Map中，并调用 <code>setHasAssociatedObjects</code>函数。<code>setHasAssociatedObjects</code>函数用来将isa结构体中的<code>has_assoc</code>标记为<code>true</code>，而<code>hasAssociatedObjects</code>函数则用来获取该该标志位的结果。</p>
<p>接着看一下<code>_object_remove_assocations</code>，其实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _object_remove_assocations(id object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        if (associations.size() == 0) return;</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        if (i != associations.end()) &#123;</span><br><span class="line">            // copy all of the associations that need to be removed.</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            // remove the secondary table.</span><br><span class="line">            delete refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // the calls to releaseValue() happen outside of the lock.</span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_object_remove_assocations</code>会将对象包含的所有关联对象加入到一个<code>vector</code>中，删除<code>AssociationsHashMap</code>中对应的节点，然后对所有的 <code>ObjcAssociation</code>对象调用 <code>ReleaseValue()</code>，释放不再被需要的值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>关联对象的实现</strong></p>
<ul>
<li>关联对象的本质就是<code>ObjcAssociation</code>对象；</li>
<li><code>ObjectAssociationMap</code>以<code>key</code>为健存储关联对象的数据结构（<code>ObjcAssociation</code>对象）；</li>
<li>每一个对象都对应着一个<code>ObjectAssociationMap</code>，对象中的<code>has_assoc</code>用来确定是否含有关联对象，而对象与<code>ObjectAssociationMap</code>之间的映射关系则存储在<code>AssociationsHashMap</code>中；</li>
<li><code>AssociationsHashMap</code>是全局唯一的，有<code>AssociationsManager</code>管理。</li>
</ul>
<p><strong>分类中能否实现属性</strong></p>
<p>如果将属性看成是实例变量，那答案是不能，如果将属性看成是存取方法以及存储值的集合，那么分类是可以实现属性的，个人更倾向于前者。</p>
<p><strong>weak类型的关联对象</strong></p>
<p>关联对象里是没有weak类型的策略，而在开发过程中，真的几乎没有说要用弱类型的关联对象，除非是为了用而用。我是这么理解的，既然叫做关联对象，那肯定需要和自身生命周期有联系才谈得上关联，使用weak则代表对象和自身生命周期是没有联系，自身的释放不会影响关联对象。综上我认为weak类型的关联对象是没有意义的。 </p>
<p>但是如果非要实现一个weak类型的关联对象也不是不可以，拿个中间对象包装一下即可。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma mark - Weak Associated Object</span><br><span class="line"></span><br><span class="line">@interface _NNWeakAssociatedWrapper : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id associatedObject;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation _NNWeakAssociatedWrapper</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">void nn_objc_setWeakAssociatedObject(id object, const void * key, id value) &#123;</span><br><span class="line">    _NNWeakAssociatedWrapper *wrapper = objc_getAssociatedObject(object, key);</span><br><span class="line">    if (!wrapper) &#123;</span><br><span class="line">        wrapper = [_NNWeakAssociatedWrapper new];</span><br><span class="line">        objc_setAssociatedObject(object, key, wrapper, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.associatedObject = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id nn_objc_getWeakAssociatedObject(id object, const void * key) &#123;</span><br><span class="line">    id wrapper = objc_getAssociatedObject(object, key);</span><br><span class="line">    </span><br><span class="line">    id objc = wrapper &amp;&amp; [wrapper isKindOfClass:_NNWeakAssociatedWrapper.class] ?</span><br><span class="line">    [(_NNWeakAssociatedWrapper *)wrapper associatedObject] :</span><br><span class="line">    nil;</span><br><span class="line">    </span><br><span class="line">    return objc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解GCD之dispatch_group</title>
    <url>/2019/01/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GCD%E4%B9%8Bdispatch-group/</url>
    <content><![CDATA[<p>之前已经介绍了<code>dispatch_semaphore</code>的底层实现，<code>dispatch_group</code>的实现是基于前者的。在看源码之前，我们先看一下我们是如何应用的。假设有这么场景：有一个A耗时操作，B和C两个网络请求和一个耗时操作C当ABC都执行完成后，刷新页面。我们可以用<code>dispatch_group</code>实现。关键如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">        __block NSInteger number = 0;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    //A耗时操作</span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        sleep(3);</span><br><span class="line">        number += 2222;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //B网络请求</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    [self sendRequestWithCompletion:^(id response) &#123;</span><br><span class="line">        number += [response integerValue];</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //C网络请求</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    [self sendRequestWithCompletion:^(id response) &#123;</span><br><span class="line">        number += [response integerValue];</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;%zd&quot;, number);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendRequestWithCompletion:(void (^)(id response))completion &#123;</span><br><span class="line">    //模拟一个网络请求</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (completion) completion(@1111);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们根据上面的流程来看一下dispatch_group的相关API</p>
<h2 id="dispatch-group-create"><a href="#dispatch-group-create" class="headerlink" title="dispatch_group_create"></a>dispatch_group_create</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_group_t</span><br><span class="line">dispatch_group_create(void)</span><br><span class="line">&#123;</span><br><span class="line">	return (dispatch_group_t)dispatch_semaphore_create(LONG_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_group_create</code>其实就是创建了一个<code>value</code>为<code>LONG_MAX</code>的<code>dispatch_semaphore</code>信号量</p>
<h2 id="dispatch-group-async"><a href="#dispatch-group-async" class="headerlink" title="dispatch_group_async"></a>dispatch_group_async</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">dispatch_group_async(dispatch_group_t dg, dispatch_queue_t dq,</span><br><span class="line">		dispatch_block_t db)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_group_async_f(dg, dq, _dispatch_Block_copy(db),</span><br><span class="line">			_dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_group_async</code>只是<code>dispatch_group_async_f</code>的封装</p>
<h3 id="dispatch-group-async-f"><a href="#dispatch-group-async-f" class="headerlink" title="dispatch_group_async_f"></a>dispatch_group_async_f</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">dispatch_group_async_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt,</span><br><span class="line">		dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_continuation_t dc;</span><br><span class="line"></span><br><span class="line">	_dispatch_retain(dg);</span><br><span class="line">	dispatch_group_enter(dg);</span><br><span class="line"></span><br><span class="line">	dc = fastpath(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">	if (!dc) &#123;</span><br><span class="line">		dc = _dispatch_continuation_alloc_from_heap();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dc-&gt;do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_GROUP_BIT);</span><br><span class="line">	dc-&gt;dc_func = func;</span><br><span class="line">	dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">	dc-&gt;dc_group = dg;</span><br><span class="line"></span><br><span class="line">	// No fastpath/slowpath hint because we simply don&apos;t know</span><br><span class="line">	if (dq-&gt;dq_width != 1 &amp;&amp; dq-&gt;do_targetq) &#123;</span><br><span class="line">		return _dispatch_async_f2(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们可以看出<code>dispatch_group_async_f</code>和<code>dispatch_async_f</code>相似。<code>dispatch_group_async_f</code>多了<code>dispatch_group_enter(dg);</code>，另外在<code>do_vtable</code>的赋值中<code>dispatch_group_async_f</code>多了一个<code>DISPATCH_OBJ_GROUP_BIT</code>的标记符。既然添加了<code>dispatch_group_enter</code>必定会存在<code>dispatch_group_leave</code>。在之前《深入理解GCD之dispatch_queue》介绍<code>_dispatch_continuation_pop</code>函数的源码中有一段代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">if (dg) &#123;</span><br><span class="line">	//group需要进行调用dispatch_group_leave并释放信号</span><br><span class="line">	dispatch_group_leave(dg);</span><br><span class="line">	_dispatch_release(dg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以<code>dispatch_group_async_f</code>函数中的<code>dispatch_group_leave</code>是在<code>_dispatch_continuation_pop</code>函数中调用的。</p>
<p>这里概括一下<code>dispatch_group_async_f</code>的工作流程：</p>
<ol>
<li>调用<code>dispatch_group_enter</code>；</li>
<li>将block和queue等信息记录到<code>dispatch_continuation_t</code>结构体中，并将它加入到group的链表中；</li>
<li><code>_dispatch_continuation_pop</code>执行时会判断任务是否为group，是的话执行完任务再调用<code>dispatch_group_leave</code>以达到信号量的平衡。</li>
</ol>
<h2 id="dispatch-group-enter"><a href="#dispatch-group-enter" class="headerlink" title="dispatch_group_enter"></a>dispatch_group_enter</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">dispatch_group_enter(dispatch_group_t dg)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;</span><br><span class="line"></span><br><span class="line">	(void)dispatch_semaphore_wait(dsema, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_group_enter</code>将<code>dispatch_group_t</code>转换成<code>dispatch_semaphore_t</code>，并调用<code>dispatch_semaphore_wait</code>，原子性减1后，进入等待状态直到有信号唤醒。所以说<strong>dispatch_group_enter就是对dispatch_semaphore_wait的封装</strong>。</p>
<h2 id="dispatch-group-leave"><a href="#dispatch-group-leave" class="headerlink" title="dispatch_group_leave"></a>dispatch_group_leave</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">dispatch_group_leave(dispatch_group_t dg)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;</span><br><span class="line">	dispatch_atomic_release_barrier();</span><br><span class="line">	long value = dispatch_atomic_inc2o(dsema, dsema_value);//dsema_value原子性加1</span><br><span class="line">	if (slowpath(value == LONG_MIN)) &#123;//内存溢出，由于dispatch_group_leave在dispatch_group_enter之前调用</span><br><span class="line">		DISPATCH_CLIENT_CRASH(&quot;Unbalanced call to dispatch_group_leave()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (slowpath(value == dsema-&gt;dsema_orig)) &#123;//表示所有任务已经完成，唤醒group</span><br><span class="line">		(void)_dispatch_group_wake(dsema);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源代码中我们看到<code>dispatch_group_leave</code>将<code>dispatch_group_t</code>转换成<code>dispatch_semaphore_t</code>后将<code>dsema_value</code>的值原子性加1。如果<code>value</code>为<code>LONG_MIN</code>程序crash；如果<code>value</code>等于<code>dsema_orig</code>表示所有任务已完成，调用<code>_dispatch_group_wake</code>唤醒group（<code>_dispatch_group_wake</code>的用于和notify有关，我们会在后面介绍）。因为在<code>enter</code>的时候进行了原子性减1操作。所以在<code>leave</code>的时候需要原子性加1。</p>
<p>这里先说明一下<code>enter</code>和<code>leave</code>之间的关系：</p>
<ol>
<li><p><strong>dispatch_group_leave与dispatch_group_enter配对使用</strong>。当调用了<code>dispatch_group_enter</code>而没有调用<code>dispatch_group_leave</code>时，由于<code>value</code>不等于<code>dsema_orig</code>不会走到唤醒逻辑，<code>dispatch_group_notify</code>中的任务无法执行或者<code>dispatch_group_wait</code>收不到信号而卡住线程。</p>
</li>
<li><p><strong>dispatch_group_enter必须在dispatch_group_leave之前出现</strong>。当<code>dispatch_group_leave</code>比<code>dispatch_group_enter</code>多调用了一次或者说在<code>dispatch_group_enter</code>之前被调用的时候，<code>dispatch_group_leave</code>进行原子性加1操作，相当于<code>value</code>为<code>LONGMAX+1</code>，发生数据长度溢出，变成<code>LONG_MIN</code>，由于<code>value == LONG_MIN</code>成立，程序发生crash。</p>
</li>
</ol>
<h2 id="dispatch-group-notify"><a href="#dispatch-group-notify" class="headerlink" title="dispatch_group_notify"></a>dispatch_group_notify</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">dispatch_group_notify(dispatch_group_t dg, dispatch_queue_t dq,</span><br><span class="line">		dispatch_block_t db)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_group_notify_f(dg, dq, _dispatch_Block_copy(db),</span><br><span class="line">			_dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_group_notify</code>是<code>dispatch_group_notify_f</code>的封装，具体实现在后者。</p>
<h3 id="dispatch-group-notify-f"><a href="#dispatch-group-notify-f" class="headerlink" title="dispatch_group_notify_f"></a>dispatch_group_notify_f</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">dispatch_group_notify_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt,</span><br><span class="line">		void (*func)(void *))</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;</span><br><span class="line">	struct dispatch_sema_notify_s *dsn, *prev;</span><br><span class="line"></span><br><span class="line">	//封装dispatch_continuation_t结构体</span><br><span class="line">	// FIXME -- this should be updated to use the continuation cache</span><br><span class="line">	while (!(dsn = calloc(1, sizeof(*dsn)))) &#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dsn-&gt;dsn_queue = dq;</span><br><span class="line">	dsn-&gt;dsn_ctxt = ctxt;</span><br><span class="line">	dsn-&gt;dsn_func = func;</span><br><span class="line">	_dispatch_retain(dq);</span><br><span class="line">	dispatch_atomic_store_barrier();</span><br><span class="line">	//将结构体放到链表尾部，如果链表为空同时设置链表头部节点并唤醒group</span><br><span class="line">	prev = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, dsn);</span><br><span class="line">	if (fastpath(prev)) &#123;</span><br><span class="line">		prev-&gt;dsn_next = dsn;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		_dispatch_retain(dg);</span><br><span class="line">		(void)dispatch_atomic_xchg2o(dsema, dsema_notify_head, dsn);</span><br><span class="line">		if (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) &#123;//任务已经完成，唤醒group</span><br><span class="line">			_dispatch_group_wake(dsema);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以<code>dispatch_group_notify</code>函数只是用链表把所有回调通知保存起来，等待调用。</p>
<h2 id="dispatch-group-wake"><a href="#dispatch-group-wake" class="headerlink" title="_dispatch_group_wake"></a><strong>_dispatch_group_wake</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static long</span><br><span class="line">_dispatch_group_wake(dispatch_semaphore_t dsema)</span><br><span class="line">&#123;</span><br><span class="line">	struct dispatch_sema_notify_s *next, *head, *tail = NULL;</span><br><span class="line">	long rval;</span><br><span class="line">	//将dsema的dsema_notify_head赋值为NULL，同时将之前的内容赋给head</span><br><span class="line">	head = dispatch_atomic_xchg2o(dsema, dsema_notify_head, NULL);</span><br><span class="line">	if (head) &#123;</span><br><span class="line">		// snapshot before anything is notified/woken &lt;rdar://problem/8554546&gt;</span><br><span class="line">		//将dsema的dsema_notify_tail赋值为NULL，同时将之前的内容赋给tail</span><br><span class="line">		tail = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, NULL);</span><br><span class="line">	&#125;</span><br><span class="line">	//将dsema的dsema_group_waiters设置为0，并返回原来的值</span><br><span class="line">	rval = dispatch_atomic_xchg2o(dsema, dsema_group_waiters, 0);</span><br><span class="line">	if (rval) &#123;</span><br><span class="line">		//循环调用semaphore_signal唤醒当初等待group的信号量，使得dispatch_group_wait函数返回。</span><br><span class="line">		// wake group waiters</span><br><span class="line">#if USE_MACH_SEM</span><br><span class="line">		_dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_waiter_port);</span><br><span class="line">		do &#123;</span><br><span class="line">			kern_return_t kr = semaphore_signal(dsema-&gt;dsema_waiter_port);</span><br><span class="line">			DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">		&#125; while (--rval);</span><br><span class="line">#elif USE_POSIX_SEM</span><br><span class="line">		do &#123;</span><br><span class="line">			int ret = sem_post(&amp;dsema-&gt;dsema_sem);</span><br><span class="line">			DISPATCH_SEMAPHORE_VERIFY_RET(ret);</span><br><span class="line">		&#125; while (--rval);</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">	if (head) &#123;</span><br><span class="line">		//获取链表，依次调用dispatch_async_f异步执行在notify函数中的任务即Block。</span><br><span class="line">		// async group notify blocks</span><br><span class="line">		do &#123;</span><br><span class="line">			dispatch_async_f(head-&gt;dsn_queue, head-&gt;dsn_ctxt, head-&gt;dsn_func);</span><br><span class="line">			_dispatch_release(head-&gt;dsn_queue);</span><br><span class="line">			next = fastpath(head-&gt;dsn_next);</span><br><span class="line">			if (!next &amp;&amp; head != tail) &#123;</span><br><span class="line">				while (!(next = fastpath(head-&gt;dsn_next))) &#123;</span><br><span class="line">					_dispatch_hardware_pause();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			free(head);</span><br><span class="line">		&#125; while ((head = next));</span><br><span class="line">		_dispatch_release(dsema);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dispatch_group_wake</code>主要的作用有两个：</p>
<ol>
<li><p>调用semaphore_signal唤醒当初等待group的信号量，使得dispatch_group_wait函数返回。</p>
</li>
<li><p>获取链表，依次调用dispatch_async_f异步执行在notify函数中的任务即Block。</p>
</li>
</ol>
<p>到这里我们已经差不多知道了<code>dispatch_group</code>工作过程，我们用一张图表示：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/dispatch_group.png" alt="dispatch_group"></p>
<h2 id="dispatch-group-wait"><a href="#dispatch-group-wait" class="headerlink" title="dispatch_group_wait"></a>dispatch_group_wait</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long</span><br><span class="line">dispatch_group_wait(dispatch_group_t dg, dispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;</span><br><span class="line"></span><br><span class="line">	if (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) &#123;//没有需要执行的任务</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if (timeout == 0) &#123;//返回超时</span><br><span class="line">#if USE_MACH_SEM</span><br><span class="line">		return KERN_OPERATION_TIMED_OUT;</span><br><span class="line">#elif USE_POSIX_SEM</span><br><span class="line">		errno = ETIMEDOUT;</span><br><span class="line">		return (-1);</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">	return _dispatch_group_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_group_wait</code>用于等待group中的任务完成。</p>
<h3 id="dispatch-group-wait-slow"><a href="#dispatch-group-wait-slow" class="headerlink" title="_dispatch_group_wait_slow"></a><strong>_dispatch_group_wait_slow</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static long</span><br><span class="line">_dispatch_group_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	long orig;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	// check before we cause another signal to be sent by incrementing</span><br><span class="line">	// dsema-&gt;dsema_group_waiters</span><br><span class="line">	if (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) &#123;</span><br><span class="line">		return _dispatch_group_wake(dsema);</span><br><span class="line">	&#125;</span><br><span class="line">	// Mach semaphores appear to sometimes spuriously wake up. Therefore,</span><br><span class="line">	// we keep a parallel count of the number of times a Mach semaphore is</span><br><span class="line">	// signaled (6880961).</span><br><span class="line">	(void)dispatch_atomic_inc2o(dsema, dsema_group_waiters);</span><br><span class="line">	// check the values again in case we need to wake any threads</span><br><span class="line">	if (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) &#123;</span><br><span class="line">		return _dispatch_group_wake(dsema);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#if USE_MACH_SEM</span><br><span class="line">	mach_timespec_t _timeout;</span><br><span class="line">	kern_return_t kr;</span><br><span class="line"></span><br><span class="line">	_dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_waiter_port);</span><br><span class="line"></span><br><span class="line">	// From xnu/osfmk/kern/sync_sema.c:</span><br><span class="line">	// wait_semaphore-&gt;count = -1; /* we don&apos;t keep an actual count */</span><br><span class="line">	//</span><br><span class="line">	// The code above does not match the documentation, and that fact is</span><br><span class="line">	// not surprising. The documented semantics are clumsy to use in any</span><br><span class="line">	// practical way. The above hack effectively tricks the rest of the</span><br><span class="line">	// Mach semaphore logic to behave like the libdispatch algorithm.</span><br><span class="line"></span><br><span class="line">	switch (timeout) &#123;</span><br><span class="line">	default:</span><br><span class="line">		do &#123;</span><br><span class="line">			uint64_t nsec = _dispatch_timeout(timeout);</span><br><span class="line">			_timeout.tv_sec = (typeof(_timeout.tv_sec))(nsec / NSEC_PER_SEC);</span><br><span class="line">			_timeout.tv_nsec = (typeof(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);</span><br><span class="line">			kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_waiter_port,</span><br><span class="line">					_timeout));</span><br><span class="line">		&#125; while (kr == KERN_ABORTED);</span><br><span class="line"></span><br><span class="line">		if (kr != KERN_OPERATION_TIMED_OUT) &#123;</span><br><span class="line">			DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		// Fall through and try to undo the earlier change to</span><br><span class="line">		// dsema-&gt;dsema_group_waiters</span><br><span class="line">	case DISPATCH_TIME_NOW:</span><br><span class="line">		while ((orig = dsema-&gt;dsema_group_waiters)) &#123;</span><br><span class="line">			if (dispatch_atomic_cmpxchg2o(dsema, dsema_group_waiters, orig,</span><br><span class="line">					orig - 1)) &#123;</span><br><span class="line">				return KERN_OPERATION_TIMED_OUT;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// Another thread called semaphore_signal().</span><br><span class="line">		// Fall through and drain the wakeup.</span><br><span class="line">	case DISPATCH_TIME_FOREVER:</span><br><span class="line">		do &#123;</span><br><span class="line">			kr = semaphore_wait(dsema-&gt;dsema_waiter_port);</span><br><span class="line">		&#125; while (kr == KERN_ABORTED);</span><br><span class="line">		DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">#elif USE_POSIX_SEM</span><br><span class="line">//这部分代码省略</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	goto again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码我们发现<code>_dispatch_group_wait_slow</code>和<code>_dispatch_semaphore_wait_slow</code>的逻辑很接近。都利用mach内核的semaphore进行信号的发送。区别在于<code>_dispatch_semaphore_wait_slow</code>在等待结束后是return，而<code>_dispatch_group_wait_slow</code>在等待结束是调用<code>_dispatch_group_wake</code>去唤醒这个group。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p><code>dispatch_group</code>是一个初始值为<code>LONG_MAX</code>的信号量，group中的任务完成是判断其<code>value</code>是否恢复成初始值。</p>
</li>
<li><p><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>必须成对使用并且支持嵌套。</p>
</li>
<li><p>如果<code>dispatch_group_enter</code>比<code>dispatch_group_leave</code>多，由于<code>value</code>不等于<code>dsema_orig</code>不会走到唤醒逻辑，<code>dispatch_group_notify</code>中的任务无法执行或者<code>dispatch_group_wait</code>收不到信号而卡住线程。如果是<code>dispatch_group_leave</code>多，则会引起崩溃。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>GCD</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解GCD之dispatch_queue</title>
    <url>/2019/01/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GCD%E4%B9%8Bdispatch-queue/</url>
    <content><![CDATA[<p>更新于2020-12-13 更新异步执行任务的源码分析</p>
<p>GCD队列是我们在使用GCD中经常接触的技术点，分析dispatch_queue部分的源码能更好得理解多线程时的处理。但是libdispatch的源码相对来说比较复杂，综合考虑下，使用了<a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">libdispatch-187.9</a>进行分析。</p>
<h2 id="队列和线程的关系"><a href="#队列和线程的关系" class="headerlink" title="队列和线程的关系"></a>队列和线程的关系</h2><p><a href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/" target="_blank" rel="noopener">Concurrent Programming: APIs and Challenges</a>中的一张图片可以很直观地描述GCD与线程之间的关系：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/GCDandThread%402x.png" alt="GCDandThread@2x"></p>
<p>线程和队列并不是一对一的关系，一个线程内可能有多个队列，这些队列可能是串行的或者是并行的，按照同步或者异步的方式工作。</p>
<p>对于主线程和主队列来说，主队列是主线程上的一个串行队列，是系统自动为我们创建的，换言之，主线程是可以执行除主队列之外其他队列的任务。我们可以用下面一段代码进行测试：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> sQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"sQueue"</span>)</span><br><span class="line">    <span class="comment">// 串行队列同步不会产生新线程，任务在当前线程下执行，因此Thread.current必然是主线程</span></span><br><span class="line">    sQueue.sync &#123; <span class="built_in">print</span>(<span class="type">Thread</span>.current) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><h3 id="dispatch-queue-s"><a href="#dispatch-queue-s" class="headerlink" title="dispatch_queue_s"></a>dispatch_queue_s</h3><p><code>dispatch_queue_s</code>是队列的结构体，可以说我们在GCD中接触最多的结构体了。GCD中使用了很多的宏，不利于我们理解代码，我们用对应的结构替换掉定义的宏。</p>
<p>为了方便后续的分析，先列出一些函数方便后面的理解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">    <span class="comment">// 第一部分：DISPATCH_STRUCT_HEADER(dispatch_queue_s, dispatch_queue_vtable_s)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_vtable_s</span> *<span class="title">do_vtable</span>;</span> <span class="comment">// 该类型的结构体包含了对dispatch_queue_s的操作函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> <span class="comment">//链表的next</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> do_ref_cnt; <span class="comment">// 引用计数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> do_xref_cnt; <span class="comment">// 外部引用计数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> do_suspend_cnt; <span class="comment">// 暂停标志，比如延时处理中，在任务到时后，计时器处理将会将该标志位修改，然后唤醒队列调度</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> <span class="comment">// 目标队列，GCD允许我们将一个队列放在另一个队列里执行任务</span></span><br><span class="line">	<span class="keyword">void</span> *do_ctxt; <span class="comment">// 上下文，用来存储线程池相关数据，比如用于线程挂起和唤醒的信号量、线程池尺寸等</span></span><br><span class="line">	<span class="keyword">void</span> *do_finalizer;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 第二部分：DISPATCH_QUEUE_HEADER</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">volatile</span> dq_running; <span class="comment">// 队列运行的任务数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dq_width; <span class="comment">// 最大并发数：主队列/串行队列的最大并发数为1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_tail</span>;</span> <span class="comment">// 队列尾结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_head</span>;</span> <span class="comment">// 队列头结点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dq_serialnum; <span class="comment">// 队列序列号</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq_specific_q; <span class="comment">// specific队列</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">char</span> dq_label[DISPATCH_QUEUE_MIN_LABEL_SIZE]; <span class="comment">// 队列名，队列名要少于64个字符    </span></span><br><span class="line">    <span class="keyword">char</span> _dq_pad[DISPATCH_QUEUE_CACHELINE_PAD]; <span class="comment">// for static queues only</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-queue-vtable-s"><a href="#dispatch-queue-vtable-s" class="headerlink" title="dispatch_queue_vtable_s"></a>dispatch_queue_vtable_s</h3><p>在GCD队列中，<code>dispatch_queue_vtable_s</code>这个结构体内包含了<code>dispatch_object_s</code>的操作函数，而且针对这些操作函数，定义了相对简短的宏，方便调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dispatch_queue_vtable_s结构体，声明了一些函数用于操作dispatch_queue_s结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_vtable_s</span> &#123;</span></span><br><span class="line">	<span class="comment">// DISPATCH_VTABLE_HEADER(dispatch_queue_s);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> do_type;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> do_kind;</span><br><span class="line">	<span class="keyword">size_t</span> (*<span class="keyword">const</span> do_debug)(struct dispatch_queue_s *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">	<span class="comment">// 唤醒队列的方法，全局队列和主队列此项为NULL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *(*<span class="title">const</span> <span class="title">do_invoke</span>)(<span class="title">struct</span> <span class="title">dispatch_queue_s</span>);</span> </span><br><span class="line">	<span class="comment">// 用于检测传入对象中的一些值是否满足条件</span></span><br><span class="line">	<span class="keyword">bool</span> (*<span class="keyword">const</span> do_probe)(struct dispatch_queue_s *);</span><br><span class="line">	<span class="comment">// 销毁队列的方法，通常内部会调用这个对象的finalizer函数</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="keyword">const</span> do_dispose)(struct dispatch_queue_s *)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在queue.c中定义三个关于<code>dispatch_queue_vtable_s</code>的静态常量，分别是<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于主队列和自定义队列</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_vtable_s</span> _<span class="title">dispatch_queue_vtable</span> = &#123;</span></span><br><span class="line">	.do_type = DISPATCH_QUEUE_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"queue"</span>,</span><br><span class="line">	.do_dispose = _dispatch_queue_dispose,</span><br><span class="line">	.do_invoke = <span class="literal">NULL</span>,</span><br><span class="line">	.do_probe = (<span class="keyword">void</span> *)dummy_function_r0,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于全局队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_vtable_s</span> _<span class="title">dispatch_queue_root_vtable</span> = &#123;</span></span><br><span class="line">	.do_type = DISPATCH_QUEUE_GLOBAL_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"global-queue"</span>,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">	.do_probe = _dispatch_queue_wakeup_global,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于管理队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_vtable_s</span> _<span class="title">dispatch_queue_mgr_vtable</span> = &#123;</span></span><br><span class="line">	.do_type = DISPATCH_QUEUE_MGR_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"mgr-queue"</span>,</span><br><span class="line">	.do_invoke = _dispatch_mgr_thread,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">	.do_probe = _dispatch_mgr_wakeup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="队列的类型"><a href="#队列的类型" class="headerlink" title="队列的类型"></a>队列的类型</h2><p>队列的类型可以分为<strong>主队列</strong>、<strong>管理队列</strong>、<strong>自定义队列</strong>、<strong>全局队列</strong>4种类型。</p>
<h3 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h3><p>使用<code>dispatch_get_main_queue()</code>可获取主队列，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_get_main_queue() (&amp;_dispatch_main_q)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> _<span class="title">dispatch_main_q</span> = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DISPATCH_USE_RESOLVERS</span></span><br><span class="line">	.do_vtable = &amp;_dispatch_queue_vtable,</span><br><span class="line">	.do_targetq = &amp;_dispatch_root_queues[</span><br><span class="line">			DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY], <span class="comment">// root queue中的其中一个</span></span><br><span class="line">#endif</span><br><span class="line">	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">	.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">	.dq_label = <span class="string">"com.apple.main-thread"</span>,</span><br><span class="line">	.dq_running = <span class="number">1</span>,</span><br><span class="line">	.dq_width = <span class="number">1</span>, <span class="comment">// 说明主队列是一个串行队列</span></span><br><span class="line">	.dq_serialnum = <span class="number">1</span>, <span class="comment">// 主队列序列号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="do-vtable"><a href="#do-vtable" class="headerlink" title="do_vtable"></a>do_vtable</h4><p>主队列的<code>do_vtable</code>为<code>_dispatch_queue_vtable</code>。</p>
<h4 id="do-targetq"><a href="#do-targetq" class="headerlink" title="do_targetq"></a>do_targetq</h4><p><code>do_targetq</code>即目标队列，关于目标队列的意义，在分析全局队列的do_targetq中会给一个比较具体的总结。</p>
<p>主队列的目标队列定义：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = &#123;</span><br><span class="line">		.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],</span><br><span class="line">		.dq_label = <span class="string">"com.apple.root.default-overcommit-priority"</span>,</span><br><span class="line">		.dq_running = <span class="number">2</span>,</span><br><span class="line">		.dq_width = UINT32_MAX,</span><br><span class="line">		.dq_serialnum = <span class="number">7</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="do-ref-cnt、do-xref-cnt"><a href="#do-ref-cnt、do-xref-cnt" class="headerlink" title="do_ref_cnt、do_xref_cnt"></a>do_ref_cnt、do_xref_cnt</h4><p><code>do_ref_cnt</code>和<code>do_xref_cnt</code>是引用计数，它们和GCD对象的内存管理相关。主队列的这两个值为<code>DISPATCH_OBJECT_GLOBAL_REFCNT</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_retain</span><span class="params">(<span class="keyword">dispatch_object_t</span> dou)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (slowpath(dou._do-&gt;do_xref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// global object</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_retain(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">	<span class="keyword">if</span> (slowpath(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// global object</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_release</span><span class="params">(<span class="keyword">dispatch_object_t</span> dou)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (slowpath(dou._do-&gt;do_xref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用_dispatch_release函数;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_release(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">	<span class="keyword">if</span> (slowpath(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// global object</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用dx_dispose宏即调用do_dispose</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面这几个函数可以看出：</p>
<ul>
<li>主队列的生命周期是伴随着应用的，不会受retain和release的影响。</li>
<li>当<code>do_ref_cnt</code>、<code>do_xref_cnt</code>这两个值同时为0的时候，对象才会被释放。</li>
</ul>
<h3 id="管理队列"><a href="#管理队列" class="headerlink" title="管理队列"></a>管理队列</h3><p>管理队列是GCD的内部队列，不对外公开，这个队列应该是用来扮演管理的角色，GCD定时器就用到了管理队列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct dispatch_queue_s _dispatch_mgr_q = &#123;</span><br><span class="line">	.do_vtable = &amp;_dispatch_queue_mgr_vtable,</span><br><span class="line">	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">	.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">	.do_targetq = &amp;_dispatch_root_queues[</span><br><span class="line">			DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],</span><br><span class="line">	.dq_label = &quot;com.apple.libdispatch-manager&quot;,</span><br><span class="line">	.dq_width = 1,</span><br><span class="line">	.dq_serialnum = 2, // 管理队列序列号</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="do-vtable-1"><a href="#do-vtable-1" class="headerlink" title="do_vtable"></a>do_vtable</h4><p>管理队列的<code>do_vtable</code>为<code>_dispatch_queue_mgr_vtable</code>。</p>
<h4 id="do-targetq-1"><a href="#do-targetq-1" class="headerlink" title="do_targetq"></a>do_targetq</h4><p>管理队列的目标队列：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY] = &#123;</span><br><span class="line">		.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],</span><br><span class="line">		.dq_label = <span class="string">"com.apple.root.high-overcommit-priority"</span>,</span><br><span class="line">		.dq_running = <span class="number">2</span>,</span><br><span class="line">		.dq_width = UINT32_MAX,</span><br><span class="line">		.dq_serialnum = <span class="number">9</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="do-ref-cnt、do-xref-cnt-1"><a href="#do-ref-cnt、do-xref-cnt-1" class="headerlink" title="do_ref_cnt、do_xref_cnt"></a>do_ref_cnt、do_xref_cnt</h4><p>管理队列的这两个值为<code>DISPATCH_OBJECT_GLOBAL_REFCNT</code>，所以和主队列的生命周期应该是一样的。</p>
<h3 id="自定义队列"><a href="#自定义队列" class="headerlink" title="自定义队列"></a>自定义队列</h3><p>使用<code>dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)</code>创建一个自定义的队列。它的源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_queue_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq;</span><br><span class="line">	<span class="keyword">size_t</span> label_len;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!label) &#123;</span><br><span class="line">		label = <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	label_len = <span class="built_in">strlen</span>(label);</span><br><span class="line">	<span class="keyword">if</span> (label_len &lt; (DISPATCH_QUEUE_MIN_LABEL_SIZE - <span class="number">1</span>)) &#123;</span><br><span class="line">		label_len = (DISPATCH_QUEUE_MIN_LABEL_SIZE - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// XXX switch to malloc()</span></span><br><span class="line">	dq = <span class="built_in">calloc</span>(<span class="number">1u</span>l, <span class="keyword">sizeof</span>(struct dispatch_queue_s) -</span><br><span class="line">				DISPATCH_QUEUE_MIN_LABEL_SIZE - DISPATCH_QUEUE_CACHELINE_PAD +</span><br><span class="line">				label_len + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (slowpath(!dq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> dq;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// _dispatch_queue_init(dq);</span></span><br><span class="line">	<span class="comment">// 队列初始化展开如下</span></span><br><span class="line">	dq-&gt;do_vtable = &amp;_dispatch_queue_vtable;</span><br><span class="line">	dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dq-&gt;do_ref_cnt = <span class="number">1</span>;</span><br><span class="line">	dq-&gt;do_xref_cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// Default target queue is overcommit!</span></span><br><span class="line">	<span class="comment">// 使用的目标队列：_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY]</span></span><br><span class="line">	dq-&gt;do_targetq = _dispatch_get_root_queue(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">	dq-&gt;dq_running = <span class="number">0</span>;</span><br><span class="line">	dq-&gt;dq_width = <span class="number">1</span>;</span><br><span class="line">	dq-&gt;dq_serialnum = dispatch_atomic_inc(&amp;_dispatch_queue_serial_numbers) - <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">strcpy</span>(dq-&gt;dq_label, label);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (fastpath(!attr)) &#123;</span><br><span class="line">		<span class="keyword">return</span> dq;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果是并发队列，设置最大并发数，UINT32_MAX可以看成不限制最大并发数</span></span><br><span class="line">	<span class="keyword">if</span> (fastpath(attr == DISPATCH_QUEUE_CONCURRENT)) &#123;</span><br><span class="line">		dq-&gt;dq_width = UINT32_MAX;</span><br><span class="line">		<span class="comment">// 设置目标队列，对于并发队列_dispatch_get_root_queue函数中的overcommit传的是false，获取的值： _dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY]</span></span><br><span class="line">		dq-&gt;do_targetq = _dispatch_get_root_queue(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dispatch_debug_assert(!attr, <span class="string">"Invalid attribute"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="slowpath-x-、fastpath-x"><a href="#slowpath-x-、fastpath-x" class="headerlink" title="slowpath(x)、fastpath(x)"></a>slowpath(x)、fastpath(x)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastpath(x) ((typeof(x))__builtin_expect((long)(x), ~0l)) <span class="comment">// ~0l就是1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> slowpath(x) ((typeof(x))__builtin_expect((long)(x), 0l))</span></span><br></pre></td></tr></table></figure>
<p><code>fastpath(x)</code>表示x的值极大概率为1，即多数情况下会发生。<code>slowpath(x)</code>表示x的值极大概率为0，即多数情况下不会发生。<br><code>__builtin_expect</code>来帮助程序员处理分支预测，优化程序，这个函数的语义是：我期望表达式的值等于常量C，编译器应当根据我提供的期望值进行优化。</p>
<h4 id="do-vtable-2"><a href="#do-vtable-2" class="headerlink" title="do_vtable"></a>do_vtable</h4><p>与主队列一样，自定义队列的<code>do_vtable</code>也是<code>_dispatch_queue_vtable</code>。</p>
<h4 id="do-targetq-2"><a href="#do-targetq-2" class="headerlink" title="do_targetq"></a>do_targetq</h4><p>自定义队列的目标队列有两种：</p>
<ol>
<li>如果是串行队列，则使用<code>_dispatch_get_root_queue(0, true)</code>函数获取目标队列，获取到的目标队列是<code>_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY]</code>。</li>
<li>如果是并发队列，则使用<code>_dispatch_get_root_queue(0, false)</code>函数获取目标队列，获取到的目标队列是<code>_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY]</code>。</li>
</ol>
<p><code>_dispatch_get_root_queue(long priority, bool overcommit)</code>函数的<code>overcommit</code>参数代表队列在执行block时，无论系统多忙都会新开一个线程，这样做的目的是不会造成某个线程过载。</p>
<!--看起来自定义队列更像是全局队列的一个代理。在自定义队列创建的时候默认其目标队列为`_dispatch_get_root_queue(0, true)`。其中`0`代表优先级`DISPATCH_QUEUE_PRIORITY_DEFAULT`，`true`代表是否是`overcommit`。`overcommit`参数表示该队列在执行block时，无论系统多忙都会新开一个线程，这样做的目的是不会造成某个线程过载。如果是自定义并发队列的话，`do_targetq`会被设置为`_dispatch_get_root_queue(0, false)`。

值得注意的是，主队列的目标队列也是一个全局队列，全局队列的底层就是普通的线程池（这个会在全局队列中讲到）。-->
<h4 id="dq-serialnum"><a href="#dq-serialnum" class="headerlink" title="dq_serialnum"></a>dq_serialnum</h4><p><code>dq_serialnum</code>是在<code>_dispatch_queue_serial_numbers</code>基础上进行原子操作加1，即从12开始累加。1到11被保留的序列号定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// skip zero</span><br><span class="line">// 1 - main_q</span><br><span class="line">// 2 - mgr_q</span><br><span class="line">// 3 - _unused_</span><br><span class="line">// 4,5,6,7,8,9,10,11 - global queues</span><br><span class="line">// we use &apos;xadd&apos; on Intel, so the initial value == next assigned</span><br></pre></td></tr></table></figure>
<p>其中1用于主队列，2用于管理队列，3暂时没有被使用，4~11是用于全局队列的。由于看的源码版本比较老了，后面苹果有新增了几个队列。</p>
<h3 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h3><p>上面说了很多全局队列，现在我们来看一下全局队列是如何定义的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_get_global_queue</span><span class="params">(<span class="keyword">long</span> priority, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~DISPATCH_QUEUE_OVERCOMMIT) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_get_root_queue(priority, flags &amp; DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_t</span> _dispatch_get_root_queue(<span class="keyword">long</span> priority, <span class="keyword">bool</span> overcommit) &#123;</span><br><span class="line">	<span class="keyword">if</span> (overcommit) <span class="keyword">switch</span> (priority) &#123;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line">		<span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY];</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line">		<span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY];</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line">		<span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY];</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:</span><br><span class="line">		<span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (priority) &#123;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line">		<span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY];</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line">		<span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY];</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line">		<span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY];</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:</span><br><span class="line">		<span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY];</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> _<span class="title">dispatch_root_queues</span>[] = &#123;</span></span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY] = &#123;</span><br><span class="line">		.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY],</span><br><span class="line"></span><br><span class="line">		.dq_label = <span class="string">"com.apple.root.low-priority"</span>,</span><br><span class="line">		.dq_running = <span class="number">2</span>,</span><br><span class="line">		.dq_width = UINT32_MAX,</span><br><span class="line">		.dq_serialnum = <span class="number">4</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY] = &#123;</span><br><span class="line">		.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY],</span><br><span class="line"></span><br><span class="line">		.dq_label = <span class="string">"com.apple.root.low-overcommit-priority"</span>,</span><br><span class="line">		.dq_running = <span class="number">2</span>,</span><br><span class="line">		.dq_width = UINT32_MAX,</span><br><span class="line">		.dq_serialnum = <span class="number">5</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY] = &#123;</span><br><span class="line">		.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY],</span><br><span class="line"></span><br><span class="line">		.dq_label = <span class="string">"com.apple.root.default-priority"</span>,</span><br><span class="line">		.dq_running = <span class="number">2</span>,</span><br><span class="line">		.dq_width = UINT32_MAX,</span><br><span class="line">		.dq_serialnum = <span class="number">6</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = &#123;</span><br><span class="line">		.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],</span><br><span class="line"></span><br><span class="line">		.dq_label = <span class="string">"com.apple.root.default-overcommit-priority"</span>,</span><br><span class="line">		.dq_running = <span class="number">2</span>,</span><br><span class="line">		.dq_width = UINT32_MAX,</span><br><span class="line">		.dq_serialnum = <span class="number">7</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY] = &#123;</span><br><span class="line">		.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY],</span><br><span class="line"></span><br><span class="line">		.dq_label = <span class="string">"com.apple.root.high-priority"</span>,</span><br><span class="line">		.dq_running = <span class="number">2</span>,</span><br><span class="line">		.dq_width = UINT32_MAX,</span><br><span class="line">		.dq_serialnum = <span class="number">8</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY] = &#123;</span><br><span class="line">		.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],</span><br><span class="line"></span><br><span class="line">		.dq_label = <span class="string">"com.apple.root.high-overcommit-priority"</span>,</span><br><span class="line">		.dq_running = <span class="number">2</span>,</span><br><span class="line">		.dq_width = UINT32_MAX,</span><br><span class="line">		.dq_serialnum = <span class="number">9</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY] = &#123;</span><br><span class="line">		.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY],</span><br><span class="line"></span><br><span class="line">		.dq_label = <span class="string">"com.apple.root.background-priority"</span>,</span><br><span class="line">		.dq_running = <span class="number">2</span>,</span><br><span class="line">		.dq_width = UINT32_MAX,</span><br><span class="line">		.dq_serialnum = <span class="number">10</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY] = &#123;</span><br><span class="line">		.do_vtable = &amp;_dispatch_queue_root_vtable,</span><br><span class="line">		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,</span><br><span class="line">		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">		.do_ctxt = &amp;_dispatch_root_queue_contexts[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY],</span><br><span class="line"></span><br><span class="line">		.dq_label = <span class="string">"com.apple.root.background-overcommit-priority"</span>,</span><br><span class="line">		.dq_running = <span class="number">2</span>,</span><br><span class="line">		.dq_width = UINT32_MAX,</span><br><span class="line">		.dq_serialnum = <span class="number">11</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="do-vtable-3"><a href="#do-vtable-3" class="headerlink" title="do_vtable"></a>do_vtable</h4><p>全局队列的<code>do_vtable</code>为<code>_dispatch_queue_root_vtable</code>。前面提到<code>_dispatch_queue_root_vtable</code>的检测函数（<code>do_probe</code>）为<code>_dispatch_queue_wakeup_global</code>，这个函数用来唤醒全局队列，具体的后面分析队列唤醒的时候再讲。</p>
<h4 id="do-targetq-3"><a href="#do-targetq-3" class="headerlink" title="do_targetq"></a>do_targetq</h4><p>无论是主队列、管理队列还是自定义队列，它们都使用了全局队列（就是从root queue中获取的）作为目标队列，但是全局队列并没有设置<code>do_targetq</code>。</p>
<p>在<a href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/" target="_blank" rel="noopener">Concurrent Programming: APIs and Challenges</a>提到：</p>
<blockquote>
<p>While custom queues are a powerful abstraction, all blocks you schedule on them will ultimately trickle down to one of the system’s global queues and its thread pool(s).</p>
</blockquote>
<p>虽然自定义队列是一个强大的抽象，但你在队列上安排的所有Block最终都会落到系统的某一个全局队列及其线程池中。那也就是说GCD用到的queue，无论是自定义队列，或是获取系统的主队列、全局队列、管理队列，其最终都是落脚于GCD root queue中。GCD管理的也不过这些root queue。</p>
<h4 id="do-ref-cnt、do-xref-cnt-2"><a href="#do-ref-cnt、do-xref-cnt-2" class="headerlink" title="do_ref_cnt、do_xref_cnt"></a>do_ref_cnt、do_xref_cnt</h4><p>管理队列的这两个值为<code>DISPATCH_OBJECT_GLOBAL_REFCNT</code>，所以和主队列的生命周期应该是一样的。</p>
<h4 id="do-ctxt"><a href="#do-ctxt" class="headerlink" title="do_ctxt"></a>do_ctxt</h4><p>全局队列中有一个上下文的属性，用来存储线程池相关数据，比如用于线程挂起和唤醒的信号量、线程池尺寸等。它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_root_queue_context_s</span> _<span class="title">dispatch_root_queue_contexts</span>[] = &#123;</span></span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY] = &#123;</span><br><span class="line">#<span class="keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br><span class="line">		.dgq_thread_mediator = &amp;_dispatch_thread_mediator[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY],</span><br><span class="line">		.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">#endif</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY] = &#123;</span><br><span class="line">#<span class="keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br><span class="line">		.dgq_thread_mediator = &amp;_dispatch_thread_mediator[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY],</span><br><span class="line">		.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">#endif</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY] = &#123;</span><br><span class="line">#<span class="keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br><span class="line">		.dgq_thread_mediator = &amp;_dispatch_thread_mediator[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY],</span><br><span class="line">		.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">#endif</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = &#123;</span><br><span class="line">#<span class="keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br><span class="line">		.dgq_thread_mediator = &amp;_dispatch_thread_mediator[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],</span><br><span class="line">		.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">#endif</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY] = &#123;</span><br><span class="line">#<span class="keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br><span class="line">		.dgq_thread_mediator = &amp;_dispatch_thread_mediator[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY],</span><br><span class="line">		.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">#endif</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY] = &#123;</span><br><span class="line">#<span class="keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br><span class="line">		.dgq_thread_mediator = &amp;_dispatch_thread_mediator[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],</span><br><span class="line">		.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">#endif</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY] = &#123;</span><br><span class="line">#<span class="keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br><span class="line">		.dgq_thread_mediator = &amp;_dispatch_thread_mediator[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY],</span><br><span class="line">		.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">#endif</span><br><span class="line">	&#125;,</span><br><span class="line">	[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY] = &#123;</span><br><span class="line">#<span class="keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br><span class="line">		.dgq_thread_mediator = &amp;_dispatch_thread_mediator[</span><br><span class="line">				DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY],</span><br><span class="line">		.dgq_thread_pool_size = MAX_THREAD_COUNT,</span><br><span class="line">#endif</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="队列的同步：dispatch-sync分析"><a href="#队列的同步：dispatch-sync分析" class="headerlink" title="队列的同步：dispatch_sync分析"></a>队列的同步：dispatch_sync分析</h2><p>测试代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串行队列</span></span><br><span class="line"><span class="keyword">let</span> sQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"sQueue"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">sQueue.sync &#123; <span class="built_in">print</span>(<span class="string">"\(2)：\(Thread.current)"</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">sQueue.sync &#123; <span class="built_in">print</span>(<span class="string">"\(4)：\(Thread.current)"</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行队列</span></span><br><span class="line"><span class="keyword">let</span> cQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"cQueue"</span>, attributes: [.concurrent])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">cQueue.sync &#123; <span class="built_in">print</span>(<span class="string">"\(2)：\(Thread.current)"</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">cQueue.sync &#123; <span class="built_in">print</span>(<span class="string">"\(4)：\(Thread.current)"</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2：&lt;NSThread: 0x600002478980&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3</span><br><span class="line">4：&lt;NSThread: 0x600002478980&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">2：&lt;NSThread: 0x600002478980&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3</span><br><span class="line">4：&lt;NSThread: 0x600002478980&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>虽然省略主队列和全局队列的测试，但是结果是一样的。<strong>队列同步执行任务的过程，是不会开辟新的线程，所有任务在当前线程中执行，且会阻塞线程。</strong></p>
<h3 id="入口函数：dispatch-sync"><a href="#入口函数：dispatch-sync" class="headerlink" title="入口函数：dispatch_sync"></a>入口函数：dispatch_sync</h3><p><code>dispatch_sync</code>的源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_sync</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> (^work)(<span class="keyword">void</span>))</span> </span>&#123;</span><br><span class="line">	<span class="comment">// DISPATCH_COCOA_COMPAT是Mac OS下才会走的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	<span class="comment">// 是否是主队列</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dq == &amp;_dispatch_main_q)) &#123;</span><br><span class="line">		<span class="comment">// 内部也是执行dispatch_sync_f函数</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_slow(dq, work);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Block_basic</span> *<span class="title">bb</span> = (<span class="title">void</span> *)<span class="title">work</span>;</span></span><br><span class="line">	dispatch_sync_f(dq, work, (<span class="keyword">dispatch_function_t</span>)bb-&gt;Block_invoke);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>_dispatch_sync_slow</code>函数内部也是执行<code>dispatch_sync_f</code>函数，所以<code>dispatch_sync</code>的调用本质即<code>dispatch_sync_f</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_sync_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 串行队列包括主队列</span></span><br><span class="line">	<span class="keyword">if</span> (fastpath(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> dispatch_barrier_sync_f(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 全局队列，全局队列是没有do_targetq的，主队列/管理队列/自定义队列都有</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="comment">// the global root queues do not need strict ordering</span></span><br><span class="line">		(<span class="keyword">void</span>)dispatch_atomic_add2o(dq, dq_running, <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 其他队列</span></span><br><span class="line">	_dispatch_sync_f2(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步执行任务的时候分成了三种情况：</p>
<ol>
<li>如果是串行队列，执行<code>dispatch_barrier_sync_f</code>即栅栏同步函数；</li>
<li>如果是全局队列，执行<code>_dispatch_sync_f_invoke</code>；</li>
<li>如果是其他队列，执行<code>_dispatch_sync_f2</code>。</li>
</ol>
<h3 id="重点函数：dispatch-barrier-sync-f"><a href="#重点函数：dispatch-barrier-sync-f" class="headerlink" title="重点函数：dispatch_barrier_sync_f"></a>重点函数：dispatch_barrier_sync_f</h3><p>在分析<code>dispatch_barrier_sync_f</code>这个函数前，我们看一下<code>dispatch_barrier_sync</code>函数即同步栅栏函数。它的实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_barrier_sync</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> (^work)(<span class="keyword">void</span>))</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dq == &amp;_dispatch_main_q)) &#123;</span><br><span class="line">	   <span class="comment">// 内部调用dispatch_barrier_sync_f函数</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_slow(dq, work);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Block_basic</span> *<span class="title">bb</span> = (<span class="title">void</span> *)<span class="title">work</span>;</span></span><br><span class="line">	dispatch_barrier_sync_f(dq, work, (<span class="keyword">dispatch_function_t</span>)bb-&gt;Block_invoke);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的底层也是调用<code>dispatch_barrier_sync_f</code>函数。如果是串行队列压入同步任务，那么当前任务就必须等待前面的任务执行完成后才能执行，源代码就会调用<code>dispatch_barrier_sync_f</code>函数完成上面的效果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_barrier_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">	<span class="comment">// 1) ensure that this thread hasn't enqueued anything ahead of this call</span></span><br><span class="line">	<span class="comment">// 2) the queue is not suspended</span></span><br><span class="line">	<span class="comment">// 1) 确保此线程在此调用之前没有入队</span></span><br><span class="line">	<span class="comment">// 2) 队列未挂起</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 第1步：如果串行队列中存在其他任务或者队列被挂起，进入_dispatch_barrier_sync_f_slow，</span></span><br><span class="line">	<span class="comment">// 等待这个队列中的其他任务完成(用信号量的方式通知)，然后执行这个任务。</span></span><br><span class="line">	<span class="comment">// 多数情况下不会发生</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dq-&gt;dq_items_tail) || slowpath(DISPATCH_OBJECT_SUSPENDED(dq)))&#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 第2步：检查队列的dq_running状态，如果没有运行，进入_dispatch_barrier_sync_f_slow，等待激活。</span></span><br><span class="line">	<span class="comment">// bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...)</span></span><br><span class="line">	<span class="comment">// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回true</span></span><br><span class="line">	<span class="comment">// dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1)相当于dq-&gt;dq_running为0的时候将</span></span><br><span class="line">	<span class="comment">// dq-&gt;dq_running设置为1，并返回true</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(!dispatch_atomic_cmpxchg2o(dq, dq_running, <span class="number">0</span>, <span class="number">1</span>))) &#123;</span><br><span class="line">		<span class="comment">// global queues and main queue bound to main thread always falls into</span></span><br><span class="line">		<span class="comment">// the slow case</span></span><br><span class="line">		<span class="comment">// 全局队列和绑定到主线程的主队列始终属于慢速情况即会进入_dispatch_barrier_sync_f_slow函数</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 第3步：有多重队列，寻找真正的目标队列，其实还是回到了dispatch_sync_f方法</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_f_recurse(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 第4步：队列无任务执行，调用_dispatch_barrier_sync_f_invoke执行任务。</span></span><br><span class="line">	<span class="comment">// 内部调用_dispatch_function_invoke去执行任务</span></span><br><span class="line">	_dispatch_barrier_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到三个函数：</p>
<ol>
<li><code>_dispatch_barrier_sync_f_slow</code>函数内部使用了线程对应的信号量并且调用<code>wait</code> 方法</li>
<li><code>_dispatch_barrier_sync_f_recurse</code>函数内部调用了<code>dispatch_sync_f</code>函数，还是在寻找真正的目标队列</li>
<li>如果队列无任务执行，调用<code>_dispatch_barrier_sync_f_invoke</code>执行任务。执行任务的时候会调用<code>_dispatch_function_invoke</code>函数。</li>
</ol>
<h3 id="dispatch-barrier-sync-f-invoke"><a href="#dispatch-barrier-sync-f-invoke" class="headerlink" title="_dispatch_barrier_sync_f_invoke"></a>_dispatch_barrier_sync_f_invoke</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f_invoke(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="comment">// _dispatch_function_invoke的实现</span></span><br><span class="line">    <span class="comment">// 将当前线程的dispatch_queue_key设置为dq，然后执行任务，</span></span><br><span class="line">    <span class="comment">// 执行完之后再恢复到之前的old_dq</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">	_dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_workitem_inc();</span><br><span class="line">	_dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果队列中存在其他任务，用信号量的方法唤醒，然后继续执行下一个任务</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dq-&gt;dq_items_tail)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_f2(dq);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// dispatch_atomic_dec2o这个宏，会调用GCC内置的函数 __sync_sub_and_fetch，实现减法的原子性操作。因此这一行的意思是将dq_running的值减1，然后判断是否与0相等。</span></span><br><span class="line">	<span class="comment">// _dispatch_wakeup为唤醒队列函数</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dispatch_atomic_dec2o(dq, dq_running) == <span class="number">0</span>)) &#123;</span><br><span class="line">		_dispatch_wakeup(dq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GCD死锁"><a href="#GCD死锁" class="headerlink" title="GCD死锁"></a>GCD死锁</h3><p>看了上面的代码注释后，我们来想一下死锁是怎么产生的？先看下示例代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"DeadLock.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DeadLock</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line"><span class="comment">//        [self _mianQueueDeadLock];</span></span><br><span class="line">        [<span class="keyword">self</span> _serialQueueDeadLock];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Private</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_mianQueueDeadLock &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"这里死锁了"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_serialQueueDeadLock &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"1serialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"2serialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue1, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"11111"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue1, ^&#123; </span><br><span class="line">            <span class="comment">// 如果使用queue2就不会发生死锁，使用queue1就会死锁</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"22222"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>以<code>_serialQueueDeadLock</code>为例：当第一次执行串行队列任务的时候，跳到第4步，直接开始执行任务，在运行第二个<code>dispatch_sync</code>时候，在任务里面通过执行第1步（队列在运行）向这个同步队列中压入信号量，然后等待信号量，进入死锁。<br>以<code>_mianQueueDeadLock</code>为例：主队列则会跳转到第2步进入死锁。</p>
<h3 id="dispatch-sync-f-invoke"><a href="#dispatch-sync-f-invoke" class="headerlink" title="_dispatch_sync_f_invoke"></a>_dispatch_sync_f_invoke</h3><p>如果当前队列是全局队列的话，就会调用<code>_dispatch_sync_f_invoke</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_invoke(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">	<span class="comment">// 执行任务</span></span><br><span class="line">	_dispatch_function_invoke(dq, ctxt, func);</span><br><span class="line">	<span class="comment">// dq-&gt;dq_running减2后判断是否等于0，是就唤醒队列</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dispatch_atomic_sub2o(dq, dq_running, <span class="number">2</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">		_dispatch_wakeup(dq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的作用：通过<code>_dispatch_function_invoke</code>函数执行传入的任务，然后根据<code>dq_running</code>检测任务队列有没有激活，没有激活就执行激活函数。关于激活函数<code>_dispatch_wakeup(dq)</code>放在队列的异步中讲解。</p>
<h3 id="重点函数：-dispatch-sync-f2"><a href="#重点函数：-dispatch-sync-f2" class="headerlink" title="重点函数：_dispatch_sync_f2"></a>重点函数：_dispatch_sync_f2</h3><p>根据前面讲到的，如果是其他队列，执行<code>_dispatch_sync_f2</code>。这个其他队列我们可以认为就是自定义的并行队列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_dispatch_sync_f2(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">	<span class="comment">// 1) ensure that this thread hasn't enqueued anything ahead of this call</span></span><br><span class="line">	<span class="comment">// 2) the queue is not suspended</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 第1步：队列中有其他任务或者队列被挂起，压入信号量开始等待</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dq-&gt;dq_items_tail) || slowpath(DISPATCH_OBJECT_SUSPENDED(dq)))&#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第2步：队列没有激活，激活队列后执行任务，最终还是调用了_dispatch_sync_f_slow函数，只是多了一个_dispatch_wakeup函数</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dispatch_atomic_add2o(dq, dq_running, <span class="number">2</span>) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow2(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第3步：队列有多重队列，寻找真正的目标队列</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_recurse(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第4步：队列无任务执行，调用_dispatch_sync_f_invoke执行任务。</span></span><br><span class="line">	<span class="comment">// 内部调用_dispatch_function_invoke去执行任务</span></span><br><span class="line">	_dispatch_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到三个函数：</p>
<ol>
<li><code>_dispatch_sync_f_slow</code>函数内部使用了线程对应的信号量并且调用wait方法。</li>
<li><code>_dispatch_sync_f_recurse</code>函数内部调用了<code>dispatch_sync_f</code>函数，还是在寻找真正的目标队列。</li>
<li>如果队列无任务执行，调用<code>_dispatch_sync_f_invoke</code>执行任务。执行任务的时候会调用<code>_dispatch_function_invoke</code>函数。</li>
</ol>
<p>通过上面的代码，队列的同步执行是顺序执行的。这种顺序执行跟操作队列是串行还是并发是没有关系的。这些操作按着FIFO的方式进入队列中，每一个操作都会被等待执行直到前一个操作完成8，造成了这种顺序执行的现象。</p>
<p>现在我们整理一下队列同步执行的流程，如下图：</p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/gcd_queue_synchronization.png" alt="gcd_queue_synchronization"></p>
<h2 id="队列的异步：dispatch-async分析"><a href="#队列的异步：dispatch-async分析" class="headerlink" title="队列的异步：dispatch_async分析"></a>队列的异步：dispatch_async分析</h2><p>测试代码</p>
<p><strong>串行队列测试</strong><br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"sQueue"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">sQueue.async &#123; <span class="built_in">print</span>(<span class="string">"\(2)：\(Thread.current)"</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">sQueue.async &#123; <span class="built_in">print</span>(<span class="string">"\(4)：\(Thread.current)"</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">2：&lt;NSThread: 0x600000b884c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">4：&lt;NSThread: 0x600000b884c0&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>并发队列测试</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"cQueue"</span>, attributes: [.concurrent])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">cQueue.async &#123; <span class="built_in">print</span>(<span class="string">"\(2)：\(Thread.current)"</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">cQueue.async &#123; <span class="built_in">print</span>(<span class="string">"\(4)：\(Thread.current)"</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">4：&lt;NSThread: 0x600002bc69c0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2：&lt;NSThread: 0x600002bc84c0&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的测试代码我们可以知道：</p>
<ol>
<li>队列异步执行任务的过程中，具备开辟新线程的能力。</li>
<li>非主队列的串行队列，会开辟一个新的线程，不会阻塞当前线程，所有任务有序执行。</li>
<li>并发队列会开辟多个线程，具体线程的个数有体统决定。所有任务是无序执行的。</li>
</ol>
<h3 id="入口函数：dispatch-async"><a href="#入口函数：dispatch-async" class="headerlink" title="入口函数：dispatch_async"></a>入口函数：dispatch_async</h3><p><code>dispatch_async</code>的源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> (^work)(<span class="keyword">void</span>))</span> </span>&#123;</span><br><span class="line">	dispatch_async_f(dq, _dispatch_Block_copy(work), _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_async</code>主要将block从栈copy到堆上，或者增加引用计数，保证block在执行之前不会被销毁，另外<code>_dispatch_call_block_and_release</code>用于销毁block。然后调用<code>dispatch_async_f</code>。</p>
<p><code>dispatch_async_f</code>函数的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_async_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No fastpath/slowpath hint because we simply don't know</span></span><br><span class="line">	<span class="comment">// 串行队列，执行dispatch_barrier_async_f，其实最后还是执行任务入队的操作</span></span><br><span class="line">	<span class="keyword">if</span> (dq-&gt;dq_width == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> dispatch_barrier_async_f(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从线程私有数据中获取一个dispatch_continuation_t的结构体</span></span><br><span class="line">	dc = fastpath(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">	<span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_async_f_slow(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dc-&gt;do_vtable = (<span class="keyword">void</span> *)DISPATCH_OBJ_ASYNC_BIT;</span><br><span class="line">	dc-&gt;dc_func = func;</span><br><span class="line">	dc-&gt;dc_ctxt = ctxt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No fastpath/slowpath hint because we simply don't know</span></span><br><span class="line">	<span class="comment">// 有目标队列，调用_dispatch_async_f2函数进行转发。</span></span><br><span class="line">	<span class="keyword">if</span> (dq-&gt;do_targetq) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 全局队列直接进行入队操作</span></span><br><span class="line">	_dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源代码中我们可以看出<code>dispatch_async_f</code>大致分为三种情况：</p>
<ol>
<li>如果是串行队列，调用<code>dispatch_barrier_async_f</code>函数；</li>
<li>其他队列且有目标队列，调用<code>_dispatch_async_f2</code>函数；</li>
<li>如果是全局队列的话，直接调用<code>_dispatch_queue_push</code>函数进行入队操作。</li>
</ol>
<p>由于队列的异步执行任务的过程比较复杂，我们用一张图描述一下<code>dispatch_async_f</code>这个函数执行过程：</p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/dispatch_async_f%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="dispatch_async_f函数"></p>
<p>虽然上面分三种情况，它们最后执行都是<code>_dispatch_queue_push</code>或<code>_dispatch_async_f2</code>函数。另外<code>_dispatch_async_f2</code>函数其实也是在进行入队的操作。所以<code>dispatch_async_f</code>的本质就是执行<code>_dispatch_queue_push</code>函数来任务入队。</p>
<h3 id="dispatch-continuation-t结构体"><a href="#dispatch-continuation-t结构体" class="headerlink" title="dispatch_continuation_t结构体"></a>dispatch_continuation_t结构体</h3><p>在看上述过程的源码时会涉及到<code>dispatch_continuation_t</code>这样的结构体，这个结构体的作用就是封装我们传入的异步block的任务。以<code>dispatch_barrier_async_f</code>函数的实现为例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_barrier_async_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">	<span class="comment">// 从线程私有数据中获取一个dispatch_continuation_t的结构体。</span></span><br><span class="line">	dc = fastpath(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">	<span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">		<span class="comment">// _dispatch_barrier_async_f_slow内部也是在进行入队操作</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_async_f_slow(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// DISPATCH_OBJ_BARRIER_BIT，用于阻塞标识</span></span><br><span class="line">	dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">	<span class="comment">// 将_dispatch_call_block_and_release作为func方法</span></span><br><span class="line">	dc-&gt;dc_func = func;</span><br><span class="line">	<span class="comment">// 将传入的block作为上下文</span></span><br><span class="line">	dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">	<span class="comment">// 入队操作</span></span><br><span class="line">	_dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还需要注意下<code>dispatch_continuation_t</code>中<code>do_vtable</code>的赋值情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串行队列异步或者使用dispatch_barrier_async函数会有一个DISPATCH_OBJ_BARRIER_BIT的barrier标记</span></span><br><span class="line">dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// not barrier</span></span><br><span class="line">dc-&gt;do_vtable = (<span class="keyword">void</span> *)DISPATCH_OBJ_ASYNC_BIT;</span><br></pre></td></tr></table></figure>
<p>在<code>libdispatch</code>全部标识符有四种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJ_ASYNC_BIT		0x1		<span class="comment">//异步</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJ_BARRIER_BIT	0x2		<span class="comment">//阻塞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJ_GROUP_BIT		0x4		<span class="comment">//组</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJ_SYNC_SLOW_BIT	0x8		<span class="comment">//同步慢</span></span></span><br></pre></td></tr></table></figure>
<p>从上面我们可以知道串行队列异步执行任务的时候，通过<code>DISPATCH_OBJ_BARRIER_BIT</code>这个标识符实现阻塞等待的。</p>
<h3 id="任务入队：-dispatch-queue-push"><a href="#任务入队：-dispatch-queue-push" class="headerlink" title="任务入队：_dispatch_queue_push"></a>任务入队：_dispatch_queue_push</h3><p><code>_dispatch_queue_push</code>是一个宏定义，它最后会变成执行<code>_dispatch_queue_push_list</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_queue_push(x, y) _dispatch_queue_push_list((x), (y), (y))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_queue_push_list _dispatch_trace_queue_push_list</span></span><br></pre></td></tr></table></figure>
<h4 id="dispatch-trace-queue-push-list"><a href="#dispatch-trace-queue-push-list" class="headerlink" title="_dispatch_trace_queue_push_list"></a>_dispatch_trace_queue_push_list</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_trace_queue_push_list(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> _head, <span class="keyword">dispatch_object_t</span> _tail) &#123;</span><br><span class="line">	<span class="comment">// 是否可以入队</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(DISPATCH_QUEUE_PUSH_ENABLED())) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dou</span> = _<span class="title">head</span>._<span class="title">do</span>;</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="comment">// 主要是对dispatch_continuation_s结构体的处理，确保后面的使用。</span></span><br><span class="line">			_dispatch_trace_continuation(dq, dou, DISPATCH_QUEUE_PUSH);</span><br><span class="line">		&#125; <span class="keyword">while</span> (dou != _tail._do &amp;&amp; (dou = dou-&gt;do_next));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	_dispatch_queue_push_list(dq, _head, _tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dispatch-queue-push-list"><a href="#dispatch-queue-push-list" class="headerlink" title="_dispatch_queue_push_list"></a>_dispatch_queue_push_list</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_queue_push_list(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> _head, <span class="keyword">dispatch_object_t</span> _tail) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">prev</span>, *<span class="title">head</span> = _<span class="title">head</span>._<span class="title">do</span>, *<span class="title">tail</span> = _<span class="title">tail</span>._<span class="title">do</span>;</span></span><br><span class="line"></span><br><span class="line">	tail-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">	dispatch_atomic_store_barrier();</span><br><span class="line">	<span class="comment">// dispatch_atomic_xchg2o实质是调用((typeof(*(p)))__sync_swap((p), (n)))，它的定义是将p设为n并返回p操作之前的值。</span></span><br><span class="line">	<span class="comment">// dispatch_atomic_xchg2o(dq, dq_items_tail, tail)相当于dq-&gt;dq_items_tail = tail，重新设置了队列的尾指针</span></span><br><span class="line">	prev = fastpath(dispatch_atomic_xchg2o(dq, dq_items_tail, tail));</span><br><span class="line">	<span class="keyword">if</span> (prev) &#123;</span><br><span class="line">		<span class="comment">// if we crash here with a value less than 0x1000, then we are at a</span></span><br><span class="line">		<span class="comment">// known bug in client code for example, see _dispatch_queue_dispose</span></span><br><span class="line">		<span class="comment">// or _dispatch_atfork_child</span></span><br><span class="line">		<span class="comment">// prev是原先的队尾，如果队列中有其他的元素，就将压入的对象加在队列的尾部。</span></span><br><span class="line">		prev-&gt;do_next = head;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果队列为空</span></span><br><span class="line">		_dispatch_queue_push_list_slow(dq, head);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dispatch-queue-push-list-slow"><a href="#dispatch-queue-push-list-slow" class="headerlink" title="_dispatch_queue_push_list_slow"></a>_dispatch_queue_push_list_slow</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_dispatch_queue_push_list_slow(<span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		struct dispatch_object_s *obj)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//dq-&gt;dq_items_head设置为dc，然后唤醒这个队列。因为此时队列为空，没有任务在执行，处于休眠状态，所以需要唤醒</span></span><br><span class="line">	_dispatch_retain(dq);</span><br><span class="line">	dq-&gt;dq_items_head = obj;</span><br><span class="line">	_dispatch_wakeup(dq);</span><br><span class="line">	_dispatch_release(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过对异步任务入队的分析，我们可以知道，入队只是将任务一个一个以FIFO的顺序添加到队列中，那就是需要一个时间点去执行这些任务。</p>
<h3 id="唤醒队列：-dispatch-wakeup"><a href="#唤醒队列：-dispatch-wakeup" class="headerlink" title="唤醒队列：_dispatch_wakeup"></a>唤醒队列：_dispatch_wakeup</h3><p>无论是同步还是异步中都调用了<code>_dispatch_wakeup</code>这个函数，这个函数的作用就是唤醒当前队列。</p>
<p><code>_dispatch_wakeup</code>的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> _dispatch_wakeup(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> tq;</span><br><span class="line">	<span class="keyword">if</span> (slowpath(DISPATCH_OBJECT_SUSPENDED(dou._do))) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dx_probe(dou._do) &amp;&amp; !dou._dq-&gt;dq_items_tail) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果dou._do-&gt;do_suspend_cnt == 0，返回YES,否则返回NO；</span></span><br><span class="line">	<span class="comment">// 同时将DISPATCH_OBJECT_SUSPEND_LOCK赋值给dou._do-&gt;do_suspend_cnt</span></span><br><span class="line">	<span class="keyword">if</span> (!dispatch_atomic_cmpxchg2o(dou._do, do_suspend_cnt, <span class="number">0</span>, DISPATCH_OBJECT_SUSPEND_LOCK)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">		<span class="comment">// 主队列的任务调用_dispatch_queue_wakeup_main唤醒主队列</span></span><br><span class="line">		<span class="keyword">if</span> (dou._dq == &amp;_dispatch_main_q) &#123;</span><br><span class="line">			_dispatch_queue_wakeup_main();</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 放到目标队列中，重新走_dispatch_queue_push方法</span></span><br><span class="line">	_dispatch_retain(dou._do);</span><br><span class="line">	tq = dou._do-&gt;do_targetq;</span><br><span class="line">	_dispatch_queue_push(tq, dou._do);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> tq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中我们只看到了主队列和其他自定义队列的操作情况，但是没有全局队列的操作的情况，关于全局队列的唤醒的比较隐晦，针对全局队列的<code>dx_probe(dou._do)</code>的调用如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_probe(x) (x)-&gt;do_vtable-&gt;do_probe(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dx_probe(dou._do) 相当于 (dou.do)-&gt;do_vtable-&gt;do_probe(dou.do)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局队列的do_vtable：_dispatch_queue_root_vtable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _dispatch_queue_root_vtable的定义</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_vtable_s</span> _<span class="title">dispatch_queue_root_vtable</span> = &#123;</span></span><br><span class="line">	.do_type = DISPATCH_QUEUE_GLOBAL_TYPE,</span><br><span class="line">	.do_kind = <span class="string">"global-queue"</span>,</span><br><span class="line">	.do_debug = dispatch_queue_debug,</span><br><span class="line">	.do_probe = _dispatch_queue_wakeup_global,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局队列：</span></span><br><span class="line"><span class="comment">// globalQueue -&gt; _dispatch_queue_root_vtable -&gt; _dispatch_queue_wakeup_global</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出<code>_dispatch_wakeup</code>分为四种情况：</p>
<ol>
<li>主队列调用<code>_dispatch_queue_wakeup_main</code>；</li>
<li>全局队列调用<code>_dispatch_queue_wakeup_global</code>；</li>
<li>其他队列向目标队列压入这个队列，继续做入队操作；</li>
<li>管理队列调用<code>_dispatch_mgr_wakeup</code>，这里主要是为了dispatch_source而服务的。</li>
</ol>
<h4 id="dispatch-queue-wakeup-main"><a href="#dispatch-queue-wakeup-main" class="headerlink" title="_dispatch_queue_wakeup_main"></a>_dispatch_queue_wakeup_main</h4><p><code>_dispatch_main_queue_wakeup</code>函数来唤醒主线程的Runloop，之前在<a href="https://www.neroxie.com/2019/04/24/%E9%87%8D%E6%8B%BERunLoop%E5%8E%9F%E7%90%86/">《重拾RunLoop原理》</a>中提到：</p>
<blockquote>
<p>使用GCD异步操作的时候，我们在一个子线程处理完一些事情后，要返回主线程处理事情的时候，这时候需要依赖于RunLoop。</p>
</blockquote>
<p>之前是控制台打印验证，现在我们在源码中亲自验证：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_queue_wakeup_main(<span class="keyword">void</span>) &#123;</span><br><span class="line">	<span class="keyword">kern_return_t</span> kr;</span><br><span class="line">	<span class="comment">// 主要看_dispatch_main_q_port_init的实现</span></span><br><span class="line">	dispatch_once_f(&amp;_dispatch_main_q_port_pred, <span class="literal">NULL</span>,</span><br><span class="line">			_dispatch_main_q_port_init);</span><br><span class="line">	<span class="comment">// 关于主线程的唤醒主要靠mach_port和在runloop中注册相对应的source1</span></span><br><span class="line">	kr = _dispatch_send_wakeup_main_thread(main_q_port, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (kr) &#123;</span><br><span class="line">	<span class="keyword">case</span> MACH_SEND_TIMEOUT:</span><br><span class="line">	<span class="keyword">case</span> MACH_SEND_TIMED_OUT:</span><br><span class="line">	<span class="keyword">case</span> MACH_SEND_INVALID_DEST:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		(<span class="keyword">void</span>)dispatch_assume_zero(kr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_safe_fork = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _dispatch_main_q_port_init的实现，RunLoop的唤醒需要依赖于mach port</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_main_q_port_init(<span class="keyword">void</span> *ctxt DISPATCH_UNUSED) &#123;</span><br><span class="line">	<span class="keyword">kern_return_t</span> kr;</span><br><span class="line"></span><br><span class="line">	kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE,</span><br><span class="line">			&amp;main_q_port);</span><br><span class="line">	DISPATCH_VERIFY_MIG(kr);</span><br><span class="line">	(<span class="keyword">void</span>)dispatch_assume_zero(kr);</span><br><span class="line">	kr = mach_port_insert_right(mach_task_self(), main_q_port, main_q_port,</span><br><span class="line">			MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line">	DISPATCH_VERIFY_MIG(kr);</span><br><span class="line">	(<span class="keyword">void</span>)dispatch_assume_zero(kr);</span><br><span class="line"></span><br><span class="line">	_dispatch_program_is_probably_callback_driven = <span class="literal">true</span>;</span><br><span class="line">	_dispatch_safe_fork = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dispatch-queue-wakeup-global"><a href="#dispatch-queue-wakeup-global" class="headerlink" title="_dispatch_queue_wakeup_global"></a>_dispatch_queue_wakeup_global</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_queue_wakeup_global(<span class="keyword">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> pred;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_root_queue_context_s</span> *<span class="title">qc</span> = <span class="title">dq</span>-&gt;<span class="title">do_ctxt</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dq-&gt;dq_items_tail) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	_dispatch_safe_fork = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	dispatch_debug_queue(dq, __PRETTY_FUNCTION__);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 上下文以及根队列的初始化，根队列内部会初始化线程池</span></span><br><span class="line">	dispatch_once_f(&amp;pred, <span class="literal">NULL</span>, _dispatch_root_queues_init);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// _dispatch_queue_wakeup_global支持两种实现的任务唤醒pthread_workqueue和thread pool</span></span><br><span class="line">	<span class="comment">//  1.支持pthread_workqueue</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_PTHREAD_WORKQUEUES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span></span><br><span class="line">	<span class="comment">// 如果队列的dgq_kworkqueue存在，则调用pthread_workqueue_additem_np函数</span></span><br><span class="line">	<span class="comment">// dgq_kworkqueue是一个用于创建内核线程的接口，通过它创建的内核线程来执行内核其他模块排列到队列里的工作。</span></span><br><span class="line">	<span class="comment">// 不同优先级的dispatch queue对应着对应优先级的workqueue。</span></span><br><span class="line">	<span class="comment">// _dispatch_root_queues_init初始化的时候，使用pthread_workqueue_create_np创建pthread_workqueue</span></span><br><span class="line">	<span class="keyword">if</span> (qc-&gt;dgq_kworkqueue)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dispatch_atomic_cmpxchg2o(qc, dgq_pending, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">pthread_workitem_handle_t</span> wh;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> gen_cnt;</span><br><span class="line">			_dispatch_debug(<span class="string">"requesting new worker thread"</span>);</span><br><span class="line">			<span class="comment">// 该函数使用workq_kernreturn系统调用，通知workqueue增加应当执行的项目。</span></span><br><span class="line">			<span class="comment">// 根据该通知，XNU内核基于系统状态判断是否要生成线程，如果是overcommit优先级的队列，workqueue则始终生成线程。</span></span><br><span class="line">			r = pthread_workqueue_additem_np(qc-&gt;dgq_kworkqueue, _dispatch_worker_thread2, dq, &amp;wh, &amp;gen_cnt);</span><br><span class="line">			(<span class="keyword">void</span>)dispatch_assume_zero(r);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			_dispatch_debug(<span class="string">"work thread request still pending on global "</span></span><br><span class="line">					<span class="string">"queue: %p"</span>, dq);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HAVE_PTHREAD_WORKQUEUES</span></span></span><br><span class="line">	<span class="comment">// 2. 支持thread pool</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span></span><br><span class="line">	<span class="comment">// 通过发送一个信号量使线程保活</span></span><br><span class="line">	<span class="keyword">if</span> (dispatch_semaphore_signal(qc-&gt;dgq_thread_mediator)) &#123;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算线程池可用长度，如果线程池已满则跳转到out即return false，否则执行线程池-1操作</span></span><br><span class="line">	<span class="keyword">pthread_t</span> pthr;</span><br><span class="line">	<span class="keyword">int</span> t_count;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		t_count = qc-&gt;dgq_thread_pool_size;</span><br><span class="line">		<span class="keyword">if</span> (!t_count) &#123;</span><br><span class="line">			_dispatch_debug(<span class="string">"The thread pool is full: %p"</span>, dq);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (!dispatch_atomic_cmpxchg2o(qc, dgq_thread_pool_size, t_count, t_count - <span class="number">1</span>));</span><br><span class="line">	<span class="comment">// qc-&gt;dgq_thread_pool_size的值与t_counts是否相等，是就减1，并返回ture</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里说明线程池不够用了，使用pthread创建一个线程，</span></span><br><span class="line">	<span class="comment">// 并执行_dispatch_worker_thread,_dispatch_worker_thread最终会调用到_dispatch_worker_thread2</span></span><br><span class="line">	<span class="keyword">while</span> ((r = pthread_create(&amp;pthr, <span class="literal">NULL</span>, _dispatch_worker_thread, dq))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (r != EAGAIN) &#123;</span><br><span class="line">			(<span class="keyword">void</span>)dispatch_assume_zero(r);</span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 保证pthr能够被回收</span></span><br><span class="line">	r = pthread_detach(pthr);</span><br><span class="line">	(<span class="keyword">void</span>)dispatch_assume_zero(r);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_ENABLE_THREAD_POOL</span></span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的任务调度"><a href="#队列的任务调度" class="headerlink" title="队列的任务调度"></a>队列的任务调度</h3><h4 id="主队列的任务调度：-dispatch-main-queue-callback-4CF"><a href="#主队列的任务调度：-dispatch-main-queue-callback-4CF" class="headerlink" title="主队列的任务调度：_dispatch_main_queue_callback_4CF"></a>主队列的任务调度：_dispatch_main_queue_callback_4CF</h4><p>通过上面的源码分析，我们知道主队列在唤醒过程中会调用<code>_dispatch_send_wakeup_main_thread</code>函数，但是该函数的实现并没有开源这个函数的相关实现，似乎我们无法看出主队列的任务调度。通过打印函数调用栈我们可以看到主队列的任务调度是依赖<code>_dispatch_main_queue_callback_4CF</code>这个函数。</p>
<p><code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code>之后调用<code>_dispatch_main_queue_callback_4CF</code>这个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理主队列任务</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_main_queue_callback_4CF(<span class="keyword">mach_msg_header_t</span> *msg DISPATCH_UNUSED) &#123;</span><br><span class="line">	<span class="keyword">if</span> (main_q_is_draining) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 正在处理任务，设置状态为true</span></span><br><span class="line">	_dispatch_queue_set_mainq_drain_state(<span class="literal">true</span>);</span><br><span class="line">	<span class="comment">// 调度处理任务</span></span><br><span class="line">	_dispatch_main_queue_drain();</span><br><span class="line">	<span class="comment">// 处理任务完成任务，恢复状态为false</span></span><br><span class="line">	_dispatch_queue_set_mainq_drain_state(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主队列是一个串行队列，按顺序执行，因此没有并发的逻辑。主队列的任务调度就是顺序遍历，主队列唤起本次需要执行的dc，并进行任务执行，对于之后入队的任务，将放在下一轮的主队列唤醒中执行。这也是<code>_dispatch_main_queue_drain</code>函数的大致实现。</p>
<h4 id="全局队列的任务调度：-dispatch-worker-thread2"><a href="#全局队列的任务调度：-dispatch-worker-thread2" class="headerlink" title="全局队列的任务调度：_dispatch_worker_thread2"></a>全局队列的任务调度：_dispatch_worker_thread2</h4><p>全局队列通过<code>_dispatch_queue_wakeup_global</code>函数，将任务入队。然后调用 <code>_dispatch_worker_thread2</code>函数处理对应queue中的任务。</p>
<p>在<code>_dispatch_worker_thread2</code>的实现中有两个函数比较重要</p>
<ol>
<li><code>_dispatch_queue_concurrent_drain_one</code>函数；</li>
<li><code>_dispatch_continuation_pop</code>函数；</li>
</ol>
<h5 id="dispatch-queue-concurrent-drain-one"><a href="#dispatch-queue-concurrent-drain-one" class="headerlink" title="_dispatch_queue_concurrent_drain_one"></a>_dispatch_queue_concurrent_drain_one</h5><p><code>_dispatch_queue_concurrent_drain_one</code>函数主要处理了以下几件事情：</p>
<ul>
<li>多线程竞争下的边界处理；</li>
<li>获取出队dc</li>
<li>再次唤醒全局队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *</span></span><br><span class="line"><span class="class">_<span class="title">dispatch_queue_concurrent_drain_one</span>(<span class="title">dispatch_queue_t</span> <span class="title">dq</span>) &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">head</span>, *<span class="title">next</span>, *<span class="title">const</span> <span class="title">mediator</span> = (<span class="title">void</span> *)~0<span class="title">ul</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The mediator value acts both as a "lock" and a signal</span></span><br><span class="line">	head = dispatch_atomic_xchg2o(dq, dq_items_head, mediator);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 检查队列是否为空，是返回NULL</span></span><br><span class="line">	<span class="keyword">if</span> (slowpath(head == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		(<span class="keyword">void</span>)dispatch_atomic_cmpxchg2o(dq, dq_items_head, mediator, <span class="literal">NULL</span>);</span><br><span class="line">		_dispatch_debug(<span class="string">"no work on global work queue"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slowpath(head == mediator)) &#123;</span><br><span class="line">		<span class="comment">// 该线程在现线程竞争中失去了对队列的拥有权，这意味着libdispatch的效率很糟糕，</span></span><br><span class="line">		<span class="comment">// 这种情况意味着在线程池中有太多的线程，这个时候应该创建一个pengding线程，</span></span><br><span class="line">		<span class="comment">// 然后退出该线程，内核会在负载减弱的时候创建一个新的线程</span></span><br><span class="line">		_dispatch_debug(<span class="string">"Contention on queue: %p"</span>, dq);</span><br><span class="line">		_dispatch_queue_wakeup_global(dq);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_PERF_MON</span></span><br><span class="line">		dispatch_atomic_inc(&amp;_dispatch_bad_ratio);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在返回之前将head指针的do_next保存下来，如果next为NULL，这意味着item是最后一个</span></span><br><span class="line">	next = fastpath(head-&gt;do_next);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slowpath(!next)) &#123;</span><br><span class="line">		dq-&gt;dq_items_head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dispatch_atomic_cmpxchg2o(dq, dq_items_tail, head, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			<span class="comment">// head和tail头尾指针均为空</span></span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 此时一定有item，该线程不会等待太久。</span></span><br><span class="line">		<span class="keyword">while</span> (!(next = head-&gt;do_next)) &#123;</span><br><span class="line">			_dispatch_hardware_pause();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dq-&gt;dq_items_head = next;</span><br><span class="line">	<span class="comment">// 再次唤醒全局队列</span></span><br><span class="line">	_dispatch_queue_wakeup_global(dq);</span><br><span class="line">out:</span><br><span class="line">	<span class="comment">// 返回需要处理的dc</span></span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里解释下我对再次调用<code>_dispatch_queue_wakeup_global</code>唤醒全局队列的理解：<br>我们知道并发队列中的dc执行是并发的，所以每一次出队dc后检查一下全局队列，是否还有dc在队列中。如果有就再次通知需要再创建一个work queue处理队列中剩余的dc，然后重复上面的步骤，类似于一种递归的过程。当多个work queue同时处理多个dc的时候，就是我们看到异步效果。</p>
<h5 id="dispatch-continuation-pop"><a href="#dispatch-continuation-pop" class="headerlink" title="_dispatch_continuation_pop"></a>_dispatch_continuation_pop</h5><p><code>_dispatch_continuation_pop</code>函数实现了对任务的处理。这些任务可能是异步任务、group任务、栅栏任务甚至可能就是队列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_pop(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> dc = dou._dc;</span><br><span class="line">	<span class="keyword">dispatch_group_t</span> dg;</span><br><span class="line"></span><br><span class="line">	_dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);</span><br><span class="line">	<span class="comment">// 检测是不是队列，如果是，就进入_dispatch_queue_invoke处理队列</span></span><br><span class="line">	<span class="comment">// dispatch_barrier_async的任务会进入以下分支，以保证barrier任务和其他任务隔离，</span></span><br><span class="line">	<span class="comment">// 并通过dispath_semaphore_t实现通知barrier任务执行</span></span><br><span class="line">	<span class="keyword">if</span> (DISPATCH_OBJ_IS_VTABLE(dou._do)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_queue_invoke(dou._dq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add the item back to the cache before calling the function. This</span></span><br><span class="line">	<span class="comment">// allows the 'hot' continuation to be used for a quick callback.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The ccache version is per-thread.</span></span><br><span class="line">	<span class="comment">// Therefore, the object has not been reused yet.</span></span><br><span class="line">	<span class="comment">// This generates better assembly.</span></span><br><span class="line">	<span class="comment">// 是否是异步任务</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_ASYNC_BIT) &#123;</span><br><span class="line">		_dispatch_continuation_free(dc);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断是否是group任务</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;</span><br><span class="line">		dg = dc-&gt;dc_group;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dg = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 是任务封装的dispatch_continuation_t结构体（dc），直接执行任务。</span></span><br><span class="line">	<span class="comment">// 这也是异步的block被调用的时机</span></span><br><span class="line">	_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">	<span class="keyword">if</span> (dg) &#123;</span><br><span class="line">		<span class="comment">// 如果是group执行dispatch_group_leave</span></span><br><span class="line">		dispatch_group_leave(dg);</span><br><span class="line">		_dispatch_release(dg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="dispatch-queue-invoke"><a href="#dispatch-queue-invoke" class="headerlink" title="_dispatch_queue_invoke"></a>_dispatch_queue_invoke</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_queue_invoke(<span class="keyword">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!slowpath(DISPATCH_OBJECT_SUSPENDED(dq)) &amp;&amp;</span><br><span class="line">			fastpath(dispatch_atomic_cmpxchg2o(dq, dq_running, <span class="number">0</span>, <span class="number">1</span>))) &#123;</span><br><span class="line">		dispatch_atomic_acquire_barrier();</span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> otq = dq-&gt;do_targetq, tq = <span class="literal">NULL</span>;</span><br><span class="line">		_dispatch_queue_drain(dq);</span><br><span class="line">		<span class="keyword">if</span> (dq-&gt;do_vtable-&gt;do_invoke) &#123;</span><br><span class="line">			<span class="comment">// Assume that object invoke checks it is executing on correct queue</span></span><br><span class="line">			tq = dx_invoke(dq);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(otq != dq-&gt;do_targetq)) &#123;</span><br><span class="line">			<span class="comment">// An item on the queue changed the target queue</span></span><br><span class="line">			tq = dq-&gt;do_targetq;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// We do not need to check the result.</span></span><br><span class="line">		<span class="comment">// When the suspend-count lock is dropped, then the check will happen.</span></span><br><span class="line">		dispatch_atomic_release_barrier();</span><br><span class="line">		<span class="comment">//dq_running减1，因为任务要么被直接执行了，要么被压到target队列了</span></span><br><span class="line">		(<span class="keyword">void</span>)dispatch_atomic_dec2o(dq, dq_running);</span><br><span class="line">		<span class="keyword">if</span> (tq) &#123;</span><br><span class="line">			<span class="keyword">return</span> _dispatch_queue_push(tq, dq);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	<span class="keyword">if</span> (!dispatch_atomic_sub2o(dq, do_suspend_cnt,</span><br><span class="line">			DISPATCH_OBJECT_SUSPEND_LOCK)) &#123;</span><br><span class="line">		<span class="comment">// 队列处于空闲状态，需要唤醒</span></span><br><span class="line">		<span class="keyword">if</span> (dq-&gt;dq_running == <span class="number">0</span>) &#123;</span><br><span class="line">			_dispatch_wakeup(dq); <span class="comment">// verify that the queue is idle</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 释放队列</span></span><br><span class="line">	_dispatch_release(dq); <span class="comment">// added when the queue is put on the list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们整理一下队列异步执行的流程，如下图：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/dispatch_async.png" alt="dispatch_async"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>队列与线程可以是多对一关系，一个线程上可以执行不同队列的任务，在主线程上一样适用。</li>
<li>队列操作与开启线程的关系：<ul>
<li>串行队列同步执行任务，任务在当前线程中有序执行，如果前面的任务没有完成则可能会阻塞当前线程。</li>
<li>串行队列异步执行任务，开启一个线程，任务在新线程中有序执行，不会阻塞当前线程，新线程中的任务有序执行。</li>
<li>并发队列同步执行任务，不会开启新线程，任务在当前线程中有序执行，如果前面的任务没有完成则可能会阻塞当前线程。</li>
<li>并发队列异步执行任务，开启多个线程，具体数量由系统自己决定，任务在新开辟的线程中执行，不会阻塞当前线程，所有任务为无序执行。</li>
<li>主队列同步执行任务，死锁。</li>
<li>主队列异步执行任务，任务在主线程中有序执行，如果前面的任务没有完成则可能会阻塞当前线程。</li>
</ul>
</li>
<li>队列的同步/异步决定是否具备开启线程的能力，队列的串行/并发决定处理任务的个数。</li>
<li><code>dispatch_queue</code>通过结构体和链表，被实现为<code>FIFO</code>（先进先出）队列，无论串行队列和并发队列，都是符合<code>FIFO</code>的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。</li>
<li><code>dispatch_sync</code>函数一般都在当前线程执行，利用与线程绑定的信号量来实现串行。</li>
<li><code>dispatch_async</code>分发到主队列的任务由Runloop处理，而分发到其他队列的任务由线程池处理。</li>
<li><p>Block并不是直接添加到队列上，而是先构成一个<code>dispatch_continuation</code>结构体。结构体包含了这个Block还有一些上下文信息。队列会将这些<code>dispatch_continuation</code>结构体添加队列的链表中。无论这些队列是什么类型的，最终都是和全局队列相关的。在全局队列执行Block的时候,libdispatch从全局队列中取出<code>dispatch_continuation</code>，调用<code>pthread_workqueue_additem_np</code>函数，将该全局队列自身、符合其优先级的workqueue信息以及<code>dispatch_continuation</code>结构体的回调函数传递给参数。<code>pthread_workqueue_additem_np</code>函数使用<code>workq_kernreturn</code>系统调用，通知workqueue增加应当执行的项目。根据该同志，XNU内核基于系统状态判断是否要生成线程。如果是overcommit优先级的全局队列workqueue则会始终生成线程。workqueue的线程执行<code>pthread_workqueue</code>函数，该函数调用libdispatch的回调函数。在该函数中执行加入到<code>dispatch_continuation</code>的Block</p>
</li>
<li><p>GCD死锁是队列导致的而不是线程导致，原因是<code>_dispatch_barrier_sync_f_slow</code>函数中使用了线程对应的信号量并且调用wait方法，从而导致线程死锁。</p>
</li>
<li><p>关于栅栏函数</p>
<ul>
<li><code>dispatch_barrier_async</code>适用的场景队列必须是用<code>DISPATCH_QUEUE_CONCURRENT</code>属性创建的队列，而使用全局并发队列的时候，其表现就和<code>dispatch_async</code>一样。原因：<code>dispatch_barrier_async</code>如果传入的是全局队列，在唤醒队列时会执行<code>_dispatch_queue_wakeup_global</code>函数，其执行效果同<code>dispatch_async</code>一致，而如果是自定义的队列的时候，<code>_dispatch_continuation_pop</code>中会执行<code>dispatch_queue_invoke</code>。在while循环中依次取出任务并调用<code>_dispatch_continuation_redirect</code>函数，使得block并发执行。当遇到<code>DISPATCH_OBJ_BARRIER_BIT</code>标记时，会修改<code>do_suspend_cnt</code>标志以保证后续while循环时直接goto out。barrier block的任务执行完之后<code>_dispatch_queue_class_invoke</code>会将<code>do_suspend_cnt</code>重置回去，所以barrier block之后的任务会继续执行。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>GCD</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解GCD之dispatch_semaphore</title>
    <url>/2019/01/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GCD%E4%B9%8Bdispatch-semaphore/</url>
    <content><![CDATA[<p>再研究完<code>dispatch_queue</code>之后，本来是打算进入到<code>dispath_group</code>的源码，但是<code>dispath_group</code>基本是围绕着<code>dispatch_semaphore</code>即信号量实现的，所以我们先进入到<code>dispatch_semaphore</code>的源码学习。在GCD中使用<code>dispatch_semaphore</code>用来保证资源使用的安全性（队列的同步执行就是依赖信号量实现）。可想而知，<code>dispatch_semaphore</code>的性能应该是不差的。</p>
<h2 id="dispatch-semaphore-t"><a href="#dispatch-semaphore-t" class="headerlink" title="dispatch_semaphore_t"></a>dispatch_semaphore_t</h2><p><code>dispatch_semaphore_s</code>是信号量的结构体。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct dispatch_semaphore_s &#123;</span><br><span class="line">	DISPATCH_STRUCT_HEADER(dispatch_semaphore_s, dispatch_semaphore_vtable_s);</span><br><span class="line">	long dsema_value;	//当前信号量</span><br><span class="line">	long dsema_orig;	//初始化信号量</span><br><span class="line">	size_t dsema_sent_ksignals;</span><br><span class="line">#if USE_MACH_SEM &amp;&amp; USE_POSIX_SEM</span><br><span class="line">#error &quot;Too many supported semaphore types&quot;</span><br><span class="line">#elif USE_MACH_SEM</span><br><span class="line">	semaphore_t dsema_port;</span><br><span class="line">	semaphore_t dsema_waiter_port;</span><br><span class="line">#elif USE_POSIX_SEM</span><br><span class="line">	sem_t dsema_sem;</span><br><span class="line">#else</span><br><span class="line">#error &quot;No supported semaphore type&quot;</span><br><span class="line">#endif</span><br><span class="line">	size_t dsema_group_waiters;</span><br><span class="line">	struct dispatch_sema_notify_s *dsema_notify_head; //notify链表头部</span><br><span class="line">	struct dispatch_sema_notify_s *dsema_notify_tail; //notify链表尾部</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef mach_port_t		semaphore_t;</span><br><span class="line"></span><br><span class="line">struct dispatch_sema_notify_s &#123;</span><br><span class="line">	struct dispatch_sema_notify_s *volatile dsn_next; //下一个信号节点</span><br><span class="line">	dispatch_queue_t dsn_queue;	//操作的队列</span><br><span class="line">	void *dsn_ctxt;				//上下文</span><br><span class="line">	void (*dsn_func)(void *);	//执行函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虽然上面还有一些属性不知道是做什么作用的，但我们继续往下走。</p>
<h2 id="dispatch-semaphore-create"><a href="#dispatch-semaphore-create" class="headerlink" title="dispatch_semaphore_create"></a>dispatch_semaphore_create</h2><p><code>dispatch_semaphore_create</code>用于信号量的创建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_semaphore_t</span><br><span class="line">dispatch_semaphore_create(long value)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_semaphore_t dsema;</span><br><span class="line"></span><br><span class="line">	// If the internal value is negative, then the absolute of the value is</span><br><span class="line">	// equal to the number of waiting threads. Therefore it is bogus to</span><br><span class="line">	// initialize the semaphore with a negative value.</span><br><span class="line">	if (value &lt; 0) &#123;//value必须大于等于0</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//申请dispatch_semaphore_s的内存</span><br><span class="line">	dsema = calloc(1, sizeof(struct dispatch_semaphore_s));</span><br><span class="line"></span><br><span class="line">	if (fastpath(dsema)) &#123;</span><br><span class="line">		//设置dispatch_semaphore_s 的操作函数</span><br><span class="line">		dsema-&gt;do_vtable = &amp;_dispatch_semaphore_vtable;</span><br><span class="line">		//设置链表尾部</span><br><span class="line">		dsema-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">		//引用计数</span><br><span class="line">		dsema-&gt;do_ref_cnt = 1;</span><br><span class="line">		dsema-&gt;do_xref_cnt = 1;</span><br><span class="line">		//目标队列的设置</span><br><span class="line">		dsema-&gt;do_targetq = dispatch_get_global_queue(</span><br><span class="line">				DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">		//当前信号量和初始化信号的赋值</span><br><span class="line">		dsema-&gt;dsema_value = value;</span><br><span class="line">		dsema-&gt;dsema_orig = value;</span><br><span class="line">#if USE_POSIX_SEM</span><br><span class="line">		int ret = sem_init(&amp;dsema-&gt;dsema_sem, 0, 0);</span><br><span class="line">		DISPATCH_SEMAPHORE_VERIFY_RET(ret);</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return dsema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的源码中<code>dsema-&gt;do_vtable = &amp;_dispatch_semaphore_vtable;</code></p>
<p><code>_dispatch_semaphore_vtable</code>定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const struct dispatch_semaphore_vtable_s _dispatch_semaphore_vtable = &#123;</span><br><span class="line">	.do_type = DISPATCH_SEMAPHORE_TYPE,</span><br><span class="line">	.do_kind = &quot;semaphore&quot;,</span><br><span class="line">	.do_dispose = _dispatch_semaphore_dispose,</span><br><span class="line">	.do_debug = _dispatch_semaphore_debug,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个<code>_dispatch_semaphore_dispose</code>函数就是信号量的销毁函数。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">_dispatch_semaphore_dispose(dispatch_semaphore_t dsema)</span><br><span class="line">&#123;</span><br><span class="line">	//信号量的当前值小于初始化，会发生闪退。因为信号量已经被释放了</span><br><span class="line">	if (dsema-&gt;dsema_value &lt; dsema-&gt;dsema_orig) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(</span><br><span class="line">				&quot;Semaphore/group object deallocated while in use&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#if USE_MACH_SEM</span><br><span class="line">	kern_return_t kr;</span><br><span class="line">	//释放信号，这个信号是dispatch_semaphore使用的信号</span><br><span class="line">	if (dsema-&gt;dsema_port) &#123;</span><br><span class="line">		kr = semaphore_destroy(mach_task_self(), dsema-&gt;dsema_port);</span><br><span class="line">		DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">	&#125;</span><br><span class="line">	//释放信号，这个信号是dispatch_group使用的信号</span><br><span class="line">	if (dsema-&gt;dsema_waiter_port) &#123;</span><br><span class="line">		kr = semaphore_destroy(mach_task_self(), dsema-&gt;dsema_waiter_port);</span><br><span class="line">		DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">	&#125;</span><br><span class="line">#elif USE_POSIX_SEM</span><br><span class="line">	int ret = sem_destroy(&amp;dsema-&gt;dsema_sem);</span><br><span class="line">	DISPATCH_SEMAPHORE_VERIFY_RET(ret);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	_dispatch_dispose(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-semaphore-wait"><a href="#dispatch-semaphore-wait" class="headerlink" title="dispatch_semaphore_wait"></a>dispatch_semaphore_wait</h2><p>创建好一个信号量后就会开始进入等待信号发消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long</span><br><span class="line">dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	//原子性减1，这里说明dsema_value是当前信号值，并将新值赋给value</span><br><span class="line">	long value = dispatch_atomic_dec2o(dsema, dsema_value);</span><br><span class="line">	dispatch_atomic_acquire_barrier();</span><br><span class="line">	if (fastpath(value &gt;= 0)) &#123;</span><br><span class="line">		//说明有资源可用，直接返回0，表示等到信号量的信息了</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	//等待信号量唤醒或者timeout超时</span><br><span class="line">	return _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-semaphore-wait-slow"><a href="#dispatch-semaphore-wait-slow" class="headerlink" title="_dispatch_semaphore_wait_slow"></a><strong>_dispatch_semaphore_wait_slow</strong></h3><p>在<code>dispatch_semaphore_wait</code>中，如果<code>value</code>小于<code>0</code>，就会执行<code>_dispatch_semaphore_wait_slow</code>等待信号量唤醒或者timeout超时。<code>_dispatch_semaphore_wait_slow</code>的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static long</span><br><span class="line">_dispatch_semaphore_wait_slow(dispatch_semaphore_t dsema,</span><br><span class="line">		dispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	long orig;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	// Mach semaphores appear to sometimes spuriously wake up. Therefore,</span><br><span class="line">	// we keep a parallel count of the number of times a Mach semaphore is</span><br><span class="line">	// signaled (6880961).</span><br><span class="line">	//第一部分：</span><br><span class="line">	//只要dsema-&gt;dsema_sent_ksignals不为零就会进入循环</span><br><span class="line">	//dispatch_atomic_cmpxchg2o(dsema, dsema_sent_ksignals, orig,orig - 1)的意思是</span><br><span class="line">	//dsema-&gt;dsema_sent_ksignals如果等于orig，则将orig - 1赋值给dsema_sent_ksignals，</span><br><span class="line">	//并且返回true，否则返回false。</span><br><span class="line">	//如果返回true，说明又获取了资源</span><br><span class="line">	while ((orig = dsema-&gt;dsema_sent_ksignals)) &#123;</span><br><span class="line">		if (dispatch_atomic_cmpxchg2o(dsema, dsema_sent_ksignals, orig,</span><br><span class="line">				orig - 1)) &#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#if USE_MACH_SEM</span><br><span class="line">	mach_timespec_t _timeout;</span><br><span class="line">	kern_return_t kr;</span><br><span class="line"></span><br><span class="line">	//第二部分：dispatch_semaphore_s中的dsema_port赋值，以懒加载的形式</span><br><span class="line">	_dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line"></span><br><span class="line">	// From xnu/osfmk/kern/sync_sema.c:</span><br><span class="line">	// wait_semaphore-&gt;count = -1; /* we don&apos;t keep an actual count */</span><br><span class="line">	//</span><br><span class="line">	// The code above does not match the documentation, and that fact is</span><br><span class="line">	// not surprising. The documented semantics are clumsy to use in any</span><br><span class="line">	// practical way. The above hack effectively tricks the rest of the</span><br><span class="line">	// Mach semaphore logic to behave like the libdispatch algorithm.</span><br><span class="line"></span><br><span class="line">	//第三部分：</span><br><span class="line">	switch (timeout) &#123;</span><br><span class="line">	default:</span><br><span class="line">			//计算剩余时间，调用mach内核的等待函数semaphore_timedwait()进行等待。</span><br><span class="line">			//如果在指定时间内没有得到通知，则会一直阻塞住，监听dsema_port等待其通知；</span><br><span class="line">			//当超时的时候，会执行下面的case代码（这个default没有break）。</span><br><span class="line">		do &#123;</span><br><span class="line">			uint64_t nsec = _dispatch_timeout(timeout);</span><br><span class="line">			_timeout.tv_sec = (typeof(_timeout.tv_sec))(nsec / NSEC_PER_SEC);</span><br><span class="line">			_timeout.tv_nsec = (typeof(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);</span><br><span class="line">			kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br><span class="line">		&#125; while (kr == KERN_ABORTED);</span><br><span class="line"></span><br><span class="line">		if (kr != KERN_OPERATION_TIMED_OUT) &#123;</span><br><span class="line">			DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		// Fall through and try to undo what the fast path did to</span><br><span class="line">		// dsema-&gt;dsema_value</span><br><span class="line">	case DISPATCH_TIME_NOW:</span><br><span class="line">			//若当前信号量desma_value小于0，对其加一并返回超时信号KERN_OPERATION_TIMED_OUT。</span><br><span class="line">			//KERN_OPERATION_TIMED_OUT代表等待超时而返回</span><br><span class="line">			//由于一开始在第一部分代码中进行了减1操作，所以需要加1以撤销之前的操作。</span><br><span class="line">		while ((orig = dsema-&gt;dsema_value) &lt; 0) &#123;</span><br><span class="line">			if (dispatch_atomic_cmpxchg2o(dsema, dsema_value, orig, orig + 1)) &#123;</span><br><span class="line">				return KERN_OPERATION_TIMED_OUT;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// Another thread called semaphore_signal().</span><br><span class="line">		// Fall through and drain the wakeup.</span><br><span class="line">	case DISPATCH_TIME_FOREVER:</span><br><span class="line">			//一直等待直到有信号。当有信号的时候说明dsema_value大于0，会跳转到again，重新执行本函数的流程</span><br><span class="line">		do &#123;</span><br><span class="line">			kr = semaphore_wait(dsema-&gt;dsema_port);</span><br><span class="line">		&#125; while (kr == KERN_ABORTED);</span><br><span class="line">		DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">#elif USE_POSIX_SEM</span><br><span class="line">    //此处的代码省略，跟上面USE_MACH_SEM代码类似</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	goto again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的源码还有几个地方需要注意：</p>
<ol>
<li><p>第一部分的那个while循环和if条件。在<code>dsema_sent_ksignals</code>非0的情况下便会进入while循环，if的条件是<code>dsema-&gt;dsema_sent_ksignals</code>如果等于<code>orig</code>，则将<code>orig - 1</code>赋值给<code>dsema_sent_ksignals</code>，并且返回<code>true</code>，否则返回<code>false</code>。很明显，只要能进入循环，这个条件是一定成立的，函数直接返回0，表示等到信号。而在初始化信号量的时候没有对<code>dsema_sent_ksignals</code>赋值，所以就会进入之后的代码。也就是说<strong>没有信号量的实际通知或者遭受了系统异常通知，并不会解除等待</strong></p>
</li>
<li><p>在上面中出现了<code>semaphore_timedwait</code>和<code>semaphore_wait</code>。这些方法是在<code>semaphore.h</code>中的。所以说<strong>dispatch_semaphore是基于mach内核的信号量接口实现的</strong>。另外这两个方法传入的参数是<code>dsema_port</code>即<code>dsema_port</code>被mach内核semaphore监听，所以我们理解<code>dsema_port</code>是dispatch_semaphore的信号。</p>
</li>
<li><p>我们回过头再看一下<code>dispatch_semaphore_s</code>结构体中的<code>dsema_waiter_port</code>。全局搜索一下可以发现，这个属性是用在<code>dispatch_group</code>中。之前也说了<code>dispatch_group</code>的实现是基于<code>dispatch_semaphore</code>，在<code>dispatch_group</code>里<code>semaphore_wait</code>监听的并不是<code>dsema_port</code>而是<code>dsema_waiter_port</code>。</p>
</li>
</ol>
<p><code>dispatch_semaphore_wait</code>流程如下图所示：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/dispatch_semaphore_wait.png" alt="dispatch_semaphore_wait"></p>
<h2 id="dispatch-semaphore-signal"><a href="#dispatch-semaphore-signal" class="headerlink" title="dispatch_semaphore_signal"></a>dispatch_semaphore_signal</h2><p>发送信号的代码相对等待信号来说简单很多，它不需要阻塞，只发送唤醒。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long</span><br><span class="line">dispatch_semaphore_signal(dispatch_semaphore_t dsema)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_atomic_release_barrier();</span><br><span class="line">	//原子性加1，value大于0 说明有资源立即返回</span><br><span class="line">	long value = dispatch_atomic_inc2o(dsema, dsema_value);</span><br><span class="line">	if (fastpath(value &gt; 0)) &#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if (slowpath(value == LONG_MIN)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(&quot;Unbalanced call to dispatch_semaphore_signal()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-semaphore-signal-slow"><a href="#dispatch-semaphore-signal-slow" class="headerlink" title="_dispatch_semaphore_signal_slow"></a><strong>_dispatch_semaphore_signal_slow</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long</span><br><span class="line">_dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema)</span><br><span class="line">&#123;</span><br><span class="line">	// Before dsema_sent_ksignals is incremented we can rely on the reference</span><br><span class="line">	// held by the waiter. However, once this value is incremented the waiter</span><br><span class="line">	// may return between the atomic increment and the semaphore_signal(),</span><br><span class="line">	// therefore an explicit reference must be held in order to safely access</span><br><span class="line">	// dsema after the atomic increment.</span><br><span class="line">	_dispatch_retain(dsema);</span><br><span class="line"></span><br><span class="line">	(void)dispatch_atomic_inc2o(dsema, dsema_sent_ksignals);</span><br><span class="line"></span><br><span class="line">#if USE_MACH_SEM</span><br><span class="line">	_dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">	kern_return_t kr = semaphore_signal(dsema-&gt;dsema_port);</span><br><span class="line">	DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">#elif USE_POSIX_SEM</span><br><span class="line">	int ret = sem_post(&amp;dsema-&gt;dsema_sem);</span><br><span class="line">	DISPATCH_SEMAPHORE_VERIFY_RET(ret);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	_dispatch_release(dsema);</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dispatch_semaphore_signal_slow</code>的作用就是内核的<code>semaphore_signal</code>函数唤醒在<code>dispatch_semaphore_wait</code>中等待的线程量，然后返回1。</p>
<p><code>dispatch_semaphore_signal</code>流程如下图所示：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/dispatch_semaphore_signal.png" alt="dispatch_semaphore_signal"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p><code>dispatch_semaphore</code>是基于mach内核的信号量接口实现的</p>
</li>
<li><p>调用<code>dispatch_semaphore_wait</code>信号量减1，调用<code>dispatch_semaphore_signal</code>信号量加1</p>
</li>
<li><p>在<code>wait</code>中，信号量大于等于0代表有资源立即返回，否则等待信号量或者返回超时；在<code>signal</code>中，信号量大于0代表有资源立即返回，否则唤醒某个正在等待的线程</p>
</li>
<li><p><code>dispatch_semaphore</code>利用了两个变量<code>desma_value</code> 和<code>dsema_sent_ksignals</code>来处理<code>wait</code>和<code>signal</code>，在<code>singnal</code>中如果有资源，则不需要唤醒线程，那么此时只需要使用<code>desma_value</code>。当需要唤醒线程的时候，发送的信号是<code>dsema_sent_ksignals</code>的值，此时会重新执行<code>wait</code>的流程，所以在<code>wait</code>中一开始是用<code>dsema_sent_ksignals</code>做判断。</p>
</li>
<li><p>再看一下<code>dispatch_semaphore_s</code>结构体的变量。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct dispatch_semaphore_s &#123;</span><br><span class="line">	DISPATCH_STRUCT_HEADER(dispatch_semaphore_s, dispatch_semaphore_vtable_s);</span><br><span class="line">	long dsema_value;	//当前信号量</span><br><span class="line">	long dsema_orig;	//初始化信号量</span><br><span class="line">	size_t dsema_sent_ksignals; //唤醒时候的信号量</span><br><span class="line">#if USE_MACH_SEM &amp;&amp; USE_POSIX_SEM</span><br><span class="line">#error &quot;Too many supported semaphore types&quot;</span><br><span class="line">#elif USE_MACH_SEM</span><br><span class="line">	semaphore_t dsema_port; //结构体使用的semaphore信号</span><br><span class="line">	semaphore_t dsema_waiter_port;//dispatch_group使用的使用的semaphore信号</span><br><span class="line">#elif USE_POSIX_SEM</span><br><span class="line">	sem_t dsema_sem;</span><br><span class="line">#else</span><br><span class="line">#error &quot;No supported semaphore type&quot;</span><br><span class="line">#endif</span><br><span class="line">	size_t dsema_group_waiters;</span><br><span class="line">	struct dispatch_sema_notify_s *dsema_notify_head; //notify链表头部</span><br><span class="line">	struct dispatch_sema_notify_s *dsema_notify_tail; //notify链表尾部</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如何控制线程并发数</p>
<p>方法1：使用信号量进行并发控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serialQueue&quot;,DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(4);</span><br><span class="line">for (NSInteger i = 0; i &lt; 15; i++) &#123;</span><br><span class="line">    dispatch_async(serialQueue, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">            NSLog(@&quot;thread:%@开始执行任务%d&quot;,[NSThread currentThread],(int)i);</span><br><span class="line">            sleep(1);</span><br><span class="line">            NSLog(@&quot;thread:%@结束执行任务%d&quot;,[NSThread currentThread],(int)i);</span><br><span class="line">            dispatch_semaphore_signal(semaphore);&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;主线程...!&quot;);</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/1548152538652.jpg" alt="控制最大并发"></p>
<p>方法2：YYDispatchQueuePool的实现思路</p>
<p>YYKit组件中的<code>YYDispatchQueuePool</code>也能控制并发队列的并发数</p>
<p>在iOS<code>保持界面流畅的技巧</code>原文中提到：</p>
<blockquote>
<p>其思路是为不同优先级创建和 CPU 数量相同的 serial queue，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。我把 App 内所有异步操作，包括图像解码、对象释放、异步绘制等，都按优先级不同放入了全局的 serial queue 中执行，这样尽量避免了过多线程导致的性能问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>GCD</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>重拾RunLoop原理</title>
    <url>/2019/04/24/%E9%87%8D%E6%8B%BERunLoop%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>虽然自己很早前就看过RunLoop的源码，当时看得时候，有点地方还是比较生涩的。所有抽了个时间，重新整理了一下之前RunLoop的笔记。<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CoreFoundation源代码</a>关于RunLoop的源码主要集中在<code>CFRunLoop.c</code>文件中。</p>
<h2 id="RunLoop的获取"><a href="#RunLoop的获取" class="headerlink" title="RunLoop的获取"></a>RunLoop的获取</h2><p>苹果并不允许我们直接创建RunLoop，RunLoop的创建在第一次获取的时候，使用<code>[NSRunLoop mainRunLoop]</code>或<code>CFRunLoopGetMain()</code>可以获取主线程的RunLoop；通过<code>[NSRunLoop currentRunLoop]</code>或<code>CFRunLoopGetCurrent()</code>获取当前线程的RunLoop。</p>
<p>它们之间的关系是<code>Foundation</code>中的RunLoop是对<code>Core Foundation</code>中的包装。可以通过执行<code>NSLog(@&quot;%@, %p&quot;, [NSRunLoop mainRunLoop], CFRunLoopGetMain());</code>得出，这里就不贴实验结果了。</p>
<p>接着看一下RunLoop在<code>CFRunLoop.c</code>中的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 主线程的RunLoop</span><br><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK(); // 判断是否需要fork进程</span><br><span class="line">    static CFRunLoopRef __main = NULL; // no retain needed</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当前线程的RunLoop</span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    // 先从TSD中查找有没有相关的runloop信息，有则返回。</span><br><span class="line">    // 我们可以理解为runloop不光存在与全局字典中，也存在中TSD中。</span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    if (rl) return rl;</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CHECK_FOR_FORK</code>用来判断是否需要fork进程，这里我们可以暂时不管。</p>
<p>在获取主线程RunLoop的时候，它使用了<code>static CFRunLoopRef __main</code>进行保存，当第二次调用<code>CFRunLoopGetMain()</code>，<code>__main</code>是有值的，就不会再重新创建，否则就使用<code>_CFRunLoopGet0</code>进行创建，传入的是<code>pthread_main_thread_np()</code>即主线程。</p>
<p>在获取当前线程的RunLoop的时候，首页会通过<code>_CFGetTSD</code>获取RunLoop，如果没有再通过<code>_CFRunLoopGet0</code>，传入的是当前的线程。</p>
<p>这里介绍一下<code>Thread-specific data</code>。<code>Thread-specific data</code>是线程私有数据就是上面的<code>TSD</code>，顾名思义就是存一些特定的数据的，RunLoop会保存在线程的私有数据里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// __CFTSDTable</span><br><span class="line">typedef struct __CFTSDTable &#123;</span><br><span class="line">    uint32_t destructorCount;</span><br><span class="line">    uintptr_t data[CF_TSD_MAX_SLOTS];</span><br><span class="line">    tsdDestructor destructors[CF_TSD_MAX_SLOTS];</span><br><span class="line">&#125; __CFTSDTable;</span><br><span class="line"></span><br><span class="line">// _CFGetTSD</span><br><span class="line">CF_EXPORT void *_CFGetTSD(uint32_t slot) &#123;</span><br><span class="line">    __CFTSDTable *table = __CFTSDGetTable();</span><br><span class="line">    if (!table) &#123; return NULL; &#125;</span><br><span class="line">    uintptr_t *slots = (uintptr_t *)(table-&gt;data);</span><br><span class="line">    return (void *)slots[slot];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// _CFSetTSD</span><br><span class="line">CF_EXPORT void *_CFSetTSD(uint32_t slot, void *newVal, tsdDestructor destructor) &#123;</span><br><span class="line">    __CFTSDTable *table = __CFTSDGetTable();</span><br><span class="line">    if (!table) &#123; return NULL; &#125;</span><br><span class="line"></span><br><span class="line">    void *oldVal = (void *)table-&gt;data[slot];</span><br><span class="line">    table-&gt;data[slot] = (uintptr_t)newVal;</span><br><span class="line">    table-&gt;destructors[slot] = destructor;</span><br><span class="line">    </span><br><span class="line">    return oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__CFTSDTable</code>的<code>data</code>数组用来保存私有数据，<code>destructors</code>数组用来保存析构函数，<code>destructorCount</code>用来记录析构函数的个数。</p>
<p><code>_CFGetTSD</code>的作用就是获取<code>__CFTSDTable</code>的<code>data</code>数据，并返回<code>slot</code>对应的值。</p>
<p><code>_CFSetTSD</code>的作用就是给<code>__CFTSDTable</code>里设置<code>data[slot]</code>和<code>destructors[slot]</code>位置的值。</p>
<h2 id="RunLoop与线程之间的关系"><a href="#RunLoop与线程之间的关系" class="headerlink" title="RunLoop与线程之间的关系"></a>RunLoop与线程之间的关系</h2><p>要想知道RunLoop与线程之间的关系，就需要看一下<code>_CFRunLoopGet0</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    // 当前线程为0，则取主线程</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFLock(&amp;loopsLock);</span><br><span class="line">    // __CFRunLoops是一个全局的静态字典。</span><br><span class="line">    // 如果该字典为空，就进行以下操作：</span><br><span class="line">    // 1.创建一个临时字典；</span><br><span class="line">    // 2.创建主线程的RunLoop，并将它存到临时字典里</span><br><span class="line">    // 3.OSAtomicCompareAndSwapPtrBarrier用来将这个临时字典复制到全局字典里；</span><br><span class="line">    // 并且使用了锁机制确保上述操作的安全性。</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">            CFRelease(dict);</span><br><span class="line">        &#125;</span><br><span class="line">        CFRelease(mainLoop);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    // 当前线程RunLoop的获取，获取不到就使用__CFRunLoopCreate创建一个RunLoop，并保存在全局字典里</span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFUnlock(&amp;loopsLock);</span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        if (!loop) &#123;</span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop = newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">        CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        // t为当前线程的话，将loop保存在线程私有数据中</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</span><br><span class="line">        // __CFFinalizeRunLoop是RunLoop的析构函数，</span><br><span class="line">        // PTHREAD_DESTRUCTOR_ITERATIONS 表示是线程退出时销毁线程私有数据的最大次数</span><br><span class="line">        // 这也是RunLoop的释放时机--线程退出的时候</span><br><span class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            // 注册一个回调，当线程销毁时，顺便也销毁其对应的RunLoop</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源代码我们可以知道：</p>
<ol>
<li>RunLoop和线程之间是一一对应的，它们之间的关系保存在一个全局字典以及线程私有数据中；</li>
<li>全局字典以线程为Key，RunLoop对象为Value的形式保存RunLoop和线程之间的映射关系；</li>
<li>在线程创建的时候，是没有对应的RunLoop，它的创建是在第一次获取的时候，它的销毁则发生在线程销毁的时候。</li>
</ol>
<p>之前在看源码的时候有两个地方不是很理解：</p>
<p><strong>1.为什么上面的loop要再取一次</strong></p>
<p>后来在《程序员的自我修养》第29页中得到启发。里面关于单例有这样一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile T* pInst = 0;</span><br><span class="line">T* GetInstance()</span><br><span class="line">&#123;</span><br><span class="line">    if(pInst == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        lock();</span><br><span class="line">        if(pInst == NULL)</span><br><span class="line">            pInst = new T;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return pInst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书上只说明双重if在这里可以让lock的调用开销降到最低。为什么有这个效果，这里做一下说明。</p>
<p>在不考虑CPU乱序的情况下，假设有两个线程A、B同时访问<code>GetInstance()</code>，A和B同时执行第一个判断语句，结果一样，都进入了代码块。<code>lock()</code>的设定就是只允许一个线程进入，假设A先进入，B在等待。A进入后首先判断<code>pInst</code>为<code>NULL</code>，那么new一个对象，然后解锁返回对象。唤醒B，这是B进入发现第二个判断通过不了（因为<code>pInst</code>已经有值了），这样的话B就直接解锁返回对象。假设只有最外层的判断的话，那么B也会创建一个对象。</p>
<p>我想这里应该也是类似的作用吧。</p>
<p><strong>2.RunLoop销毁的时机</strong></p>
<p>上面的源代码只说明了这个会在RunLoop的析构函数是<code>__CFFinalizeRunLoop</code>，但是具体的释放时机会在后面说明。</p>
<h2 id="RunLoop的创建"><a href="#RunLoop的创建" class="headerlink" title="RunLoop的创建"></a>RunLoop的创建</h2><p>从<code>_CFRunLoopGet0</code>函数的实现中可以知道，RunLoop的创建是通过调用使用<code>__CFRunLoopCreate</code>返回一个<code>CFRunLoopRef</code>的实例，这个函数大致分为两步：</p>
<ol>
<li>使用<code>_CFRuntimeCreateInstance</code>创建一个<code>CFRunLoopRef</code>实例，其实现为<code>CFRuntime.c</code>文件；</li>
<li>对<code>CFRunLoopRef</code>进行初始化配置，包括调用<code>__CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</code>。</li>
</ol>
<p>另外在<code>__CFRunLoopFindMode</code>里讲到了RunLoop的定时器，用宏进行了判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if DEPLOYMENT_TARGET_MACOSX</span><br><span class="line">#define USE_DISPATCH_SOURCE_FOR_TIMERS 1</span><br><span class="line">#define USE_MK_TIMER_TOO 1</span><br><span class="line">#else</span><br><span class="line">#define USE_DISPATCH_SOURCE_FOR_TIMERS 0</span><br><span class="line">#define USE_MK_TIMER_TOO 1</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>在<code>MACOSX</code>下，RunLoop会使用<code>GCD Timer</code>和<code>MK_TIMER</code>来做定时器，在非<code>MACOSX</code>下，使用<code>MK_TIMER</code>作为定时器。</p>
<h2 id="RunLoop的释放"><a href="#RunLoop的释放" class="headerlink" title="RunLoop的释放"></a>RunLoop的释放</h2><p>我们知道RunLoop的释放是发生在线程销毁的时候。</p>
<p>在<code>__CFTSDGetTable()</code>函数的实现中有这样的一句代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pthread_key_init_np(CF_TSD_KEY, __CFTSDFinalize);</span><br></pre></td></tr></table></figure>
<p>通过<code>CF_TSD_KEY</code>，指定了对应的析构函数<code>__CFTSDFinalize</code>是一个析构函数。</p>
<p><code>__CFTSDFinalize</code>的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void __CFTSDFinalize(void *arg) &#123;</span><br><span class="line">    __CFTSDSetSpecific(arg);</span><br><span class="line"></span><br><span class="line">    if (!arg || arg == CF_TSD_BAD_PTR) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __CFTSDTable *table = (__CFTSDTable *)arg;</span><br><span class="line">    table-&gt;destructorCount++;</span><br><span class="line">        </span><br><span class="line">    for (int32_t i = 0; i &lt; CF_TSD_MAX_SLOTS; i++) &#123;</span><br><span class="line">        if (table-&gt;data[i] &amp;&amp; table-&gt;destructors[i]) &#123;</span><br><span class="line">            uintptr_t old = table-&gt;data[i];</span><br><span class="line">            table-&gt;data[i] = (uintptr_t)NULL;</span><br><span class="line">            table-&gt;destructors[i]((void *)(old));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (table-&gt;destructorCount == PTHREAD_DESTRUCTOR_ITERATIONS - 1) &#123;    // On PTHREAD_DESTRUCTOR_ITERATIONS-1 call, destroy our data</span><br><span class="line">        free(table);</span><br><span class="line">        </span><br><span class="line">        __CFTSDSetSpecific(CF_TSD_BAD_PTR);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>table</code>会循环遍历<code>data</code>和<code>destructors</code>的数据，并且把<code>old</code>变量作为<code>destructors</code>里函数的参数。<code>table-&gt;destructors[i]((void *)(old));</code>相当于就是在调用一个析构函数。通过前面的代码，我们知道RunLoop的析构函数是会存到<code>destructors</code>中去的。所以当线程退出的时候，会调用到RunLoop的析构函数<code>__CFFinalizeRunLoop</code>释放RunLoop。</p>
<p>接着看一下<code>__CFFinalizeRunLoop</code>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Called for each thread as it exits</span><br><span class="line">CF_PRIVATE void __CFFinalizeRunLoop(uintptr_t data) &#123;</span><br><span class="line">    CFRunLoopRef rl = NULL;</span><br><span class="line">    if (data &lt;= 1) &#123;</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">        if (__CFRunLoops) &#123;</span><br><span class="line">            rl = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(pthread_self()));</span><br><span class="line">            if (rl) CFRetain(rl);</span><br><span class="line">            // 移除全局字典中RunLoop与线程之间的映射关系</span><br><span class="line">            CFDictionaryRemoveValue(__CFRunLoops, pthreadPointer(pthread_self()));</span><br><span class="line">        &#125;</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 递归移除</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(data - 1), (void (*)(void *))__CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    if (rl &amp;&amp; CFRunLoopGetMain() != rl) &#123; // protect against cooperative threads</span><br><span class="line">        if (NULL != rl-&gt;_counterpart) &#123;</span><br><span class="line">            CFRelease(rl-&gt;_counterpart);</span><br><span class="line">            rl-&gt;_counterpart = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        // purge all sources before deallocation</span><br><span class="line">        CFArrayRef array = CFRunLoopCopyAllModes(rl);</span><br><span class="line">        for (CFIndex idx = CFArrayGetCount(array); idx--;) &#123;</span><br><span class="line">            CFStringRef modeName = (CFStringRef)CFArrayGetValueAtIndex(array, idx);</span><br><span class="line">             // 移除RunLoop中的mode</span><br><span class="line">            __CFRunLoopRemoveAllSources(rl, modeName);</span><br><span class="line">        &#125;</span><br><span class="line">        // 移除RunLoop中的common mode</span><br><span class="line">        __CFRunLoopRemoveAllSources(rl, kCFRunLoopCommonModes);</span><br><span class="line">        CFRelease(array);</span><br><span class="line">    &#125;</span><br><span class="line">    if (rl) CFRelease(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RunLoop相关的类与作用"><a href="#RunLoop相关的类与作用" class="headerlink" title="RunLoop相关的类与作用"></a>RunLoop相关的类与作用</h2><p>在<code>CFRunLoop.c</code>中关于RunLoop的类一共有五个，它们分别是<code>CFRunLoopRef</code>、<code>CFRunLoopModeRef</code>、<code>CFRunLoopSourceRef</code>、<code>CFRunLoopObserverRef</code>、<code>CFRunLoopTimerRef</code>。各个类之间的关系：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/Runloop%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="Runloop中类之间的关系"></p>
<h3 id="CFRunLoopRef"><a href="#CFRunLoopRef" class="headerlink" title="CFRunLoopRef"></a>CFRunLoopRef</h3><p><code>CFRunLoopRef</code>对应<code>__CFRunLoop</code>结构体，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    // 省略其他成员变量</span><br><span class="line">    ...</span><br><span class="line">    // common mode的集合</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    // 每个common mode都有的item(source,timer and observer)集合</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    // 当前runloop的mode</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    // 所有的mode的集合</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个RunLoop可以包含几个Mode，但是必须指定一个Mode来运行，它取决于<code>_currentMode</code>的值。关于<code>_currentMode</code>的赋值在<code>CFRunLoopRunSpecific</code>函数中。</p>
<h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h3><p>接着看<code>CFRunLoopModeRef</code>，<code>CFRunLoopModeRef</code>对应着<code>__CFRunLoopMode</code>结构体，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    // source0的集合</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    // source1的集合</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    // observer的数组</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    // timer的数组</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    // 省略其他属性</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>__CFRunLoopMode</code>中包含的就是RunLoop要处理的一些事情（source0/source1/observer/timer）。前面提到RunLoop必须在执行的Mode下运行，如果RunLoop需要切换Mode，只能退出Loop，再重新指定一个Mode进入。这样的好处是：<strong>不同组的source0/source1/observer/timer可以相互隔离，互不影响，从而提高执行效率</strong>。</p>
<h4 id="RunLoop的Mode"><a href="#RunLoop的Mode" class="headerlink" title="RunLoop的Mode"></a>RunLoop的Mode</h4><p>RunLoop有五种运行模式，其中常见的1、2和5这三种</p>
<ol>
<li><code>kCFRunLoopDefaultMode</code>：App的默认Mode，通常主线程是在这个Mode下运行；</li>
<li><code>UITrackingRunLoopMode</code>：界面跟踪Mode，用于滚动视图追踪触摸滑动，保证界面滑动时不受其他 Mode影响；</li>
<li><code>UIInitializationRunLoopMode</code>：在刚启动App时第进入的第一个Mode，启动完成后就不再使用，会切换到kCFRunLoopDefaultMode；</li>
<li><code>GSEventReceiveRunLoopMode</code>：接受系统事件的内部Mode；</li>
<li><code>kCFRunLoopCommonModes</code>：这是一个占位用的Mode，并不是一种真正的Mode；</li>
</ol>
<h4 id="CommonModes"><a href="#CommonModes" class="headerlink" title="CommonModes"></a>CommonModes</h4><p><code>kCFRunLoopCommonModes</code>是苹果提供的一种“CommonModes”。它其实是一个标识符，并不是一个具体的Mode。<code>kCFRunLoopDefaultMode</code>和<code>UITrackingRunLoopMode</code>，并且都被标记为“CommonModes”。</p>
<p>一个Mode可以将自己标记为“Common”属性（通过将其<code>ModeName</code>添加到RunLoop的<code>commonModes</code>中）。每当RunLoop的内容发生变化时，RunLoop都会自动将<code>_commonModeItems</code>里的source0/source1/observer/timer同步到具有“Common”标记的所有Mode里，即能在所有具有“Common”标记的所有Mode里运行。</p>
<p>以<code>CFRunLoopAddSource</code>函数为例，只关注“CommonModes”的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) &#123;</span><br><span class="line">    // 该Mode是CommonMode</span><br><span class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        // _commonModes存在则获取一份数据拷贝</span><br><span class="line">        CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">        if (NULL == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            // _commonModeItems不存在创建一个新的集合</span><br><span class="line">            rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        // 将source添加到_commonModeItems</span><br><span class="line">        CFSetAddValue(rl-&gt;_commonModeItems, rls);</span><br><span class="line">        if (NULL != set) &#123;</span><br><span class="line">            CFTypeRef context[2] = &#123;rl, rls&#125;;</span><br><span class="line">            // 调用__CFRunLoopAddItemToCommonModes函数向_commonModes中所有的Mode添加这个source</span><br><span class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</span><br><span class="line">            CFRelease(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的source0/source1/observer/timer被统称为<code>mode item</code>，一个<code>item</code>可以被同时加入多个Mode。如果Mode里没有任何source0/source1/observer/timer，RunLoop便会立刻退出。</p>
<p>这也解决了一个问题–<strong>为什么列表滑动的时候，NSTimer不执行回调？该如何解决？</strong></p>
<p>默认NSTimer是运行在RunLoop的<code>kCFRunLoopDefaultMode</code>下，在列表滑动的时候，RunLoop会切换<code>UITrackingRunLoopMode</code>，因为RunLoop只能运行在一种模式下，所以NSTimer不会执行回调。<br>使用现成的API将NSTimer就有添加到CommonModes就可以，<code>kCFRunLoopDefaultMode</code> 和 <code>UITrackingRunLoopMode</code>都已经被标为”Common”属性的。这样Timer就同时加入了这两个Mode中。</p>
<h3 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h3><p><code>CFRunLoopSourceRef</code>对应着<code>__CFRunLoopSource</code>结构体，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoopSource &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    uint32_t _bits;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFIndex _order;			/* immutable */</span><br><span class="line">    CFMutableBagRef _runLoops;</span><br><span class="line">    union &#123;</span><br><span class="line">        CFRunLoopSourceContext version0;	/* immutable, except invalidation */</span><br><span class="line">        CFRunLoopSourceContext1 version1;	/* immutable, except invalidation */</span><br><span class="line">    &#125; _context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中有两个字段<code>version0</code>和<code>version1</code>分别对应<code>Source0</code>和<code>Source1</code>。</p>
<h4 id="Source0"><a href="#Source0" class="headerlink" title="Source0"></a>Source0</h4><p><code>Source0</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    CFIndex	version;</span><br><span class="line">    void *	info;</span><br><span class="line">    const void *(*retain)(const void *info);</span><br><span class="line">    void	(*release)(const void *info);</span><br><span class="line">    CFStringRef	(*copyDescription)(const void *info);</span><br><span class="line">    Boolean	(*equal)(const void *info1, const void *info2);</span><br><span class="line">    CFHashCode	(*hash)(const void *info);</span><br><span class="line">    // 当source被添加到RunLoop中后，会调用这个指针</span><br><span class="line">    void	(*schedule)(void *info, CFRunLoopRef rl, CFRunLoopMode mode);</span><br><span class="line">    // 当调CFRunLoopSourceInvalidate函数移除该source的时候，会调用这个指针</span><br><span class="line">    void	(*cancel)(void *info, CFRunLoopRef rl, CFRunLoopMode mode);</span><br><span class="line">    // RunLoop处理Source0的时候，会调用这个指针</span><br><span class="line">    void	(*perform)(void *info);</span><br><span class="line">&#125; CFRunLoopSourceContext;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">大神的博客</a>中提到：<code>Source0</code>并不能主动触发事件。使用时，你需要先调用<code>CFRunLoopSourceSignal</code>，将这个Source标记为待处理，然后手动调用<code>CFRunLoopWakeUp</code>来唤醒RunLoop，让其处理这个事件。</p>
<p>优秀的博客总是会被很多人阅读和模仿，这是可以理解的。但是确实没看到有人对这几句结论进行验证一下，当然我一开始也是看过记住，但是并没有做进一步的理解。</p>
<p>下面给出我自己的推导过程：</p>
<p>RunLoop通过<code>__CFRunLoopDoSources0</code>函数处理<code>Source0</code>。在它的实现有一段很关键的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (__CFRunLoopSourceIsSignaled(rls)) &#123;</span><br><span class="line">    __CFRunLoopSourceUnsetSignaled(rls);</span><br><span class="line">    if (__CFIsValid(rls)) &#123;</span><br><span class="line">        __CFRunLoopSourceUnlock(rls);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">        sourceHandled = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        __CFRunLoopSourceUnlock(rls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其简化一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (__CFRunLoopSourceIsSignaled(rls)) &#123;</span><br><span class="line">    __CFRunLoopSourceUnsetSignaled(rls);</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__便是处理Source0的函数</span><br><span class="line">// perform指针也是Source0中定义的，</span><br><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(void (*perform)(void *), void *info) &#123;</span><br><span class="line">    if (perform) &#123;</span><br><span class="line">        perform(info);</span><br><span class="line">    &#125;</span><br><span class="line">    asm __volatile__(&quot;&quot;); // thwart tail-call optimization</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先判断该<code>Source0</code>是否被标记，如果是，取消该<code>Source0</code>的标记，并处理。既然这样肯定存在对应的一个标记函数<code>__CFRunLoopSourceSetSignaled</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// CFRunLoopSourceSignal函数是对外公开的。</span><br><span class="line">void CFRunLoopSourceSignal(CFRunLoopSourceRef rls) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    __CFRunLoopSourceLock(rls);</span><br><span class="line">    if (__CFIsValid(rls)) &#123;</span><br><span class="line">        __CFRunLoopSourceSetSignaled(rls);</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopSourceUnlock(rls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于<code>CFRunLoopSourceSignal</code>函数的使用，<code>CFRunLoop.c</code>并没有相关使用代码。但是在<code>CFSocket.c</code>文件中能找到些许痕迹。</p>
<p>相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// </span><br><span class="line">if (shared-&gt;_source) &#123;</span><br><span class="line">    CFRunLoopSourceSignal(shared-&gt;_source);</span><br><span class="line">    _CFRunLoopSourceWakeUpRunLoops(shared-&gt;_source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CFRunLoopSourceContext代表Source0</span><br><span class="line">sock-&gt;_shared-&gt;_source = </span><br><span class="line">CFRunLoopSourceCreate(allocator, order, (CFRunLoopSourceContext *)&amp;context);</span><br><span class="line"></span><br><span class="line">if (sock-&gt;_shared-&gt;_source) &#123;</span><br><span class="line">    CFRunLoopSourceSignal(sock-&gt;_shared-&gt;_source);</span><br><span class="line">    _CFRunLoopSourceWakeUpRunLoops(sock-&gt;_shared-&gt;_source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// _CFRunLoopSourceWakeUpRunLoops是CFRunLoop.c中的内部方法</span><br><span class="line">// 其核心就是调用CFRunLoopWakeUp函数</span><br><span class="line">CF_PRIVATE void _CFRunLoopSourceWakeUpRunLoops(CFRunLoopSourceRef rls) &#123;</span><br><span class="line">    CFBagRef loops = NULL;</span><br><span class="line">    __CFRunLoopSourceLock(rls);</span><br><span class="line">    if (__CFIsValid(rls) &amp;&amp; NULL != rls-&gt;_runLoops) &#123;</span><br><span class="line">        loops = CFBagCreateCopy(kCFAllocatorSystemDefault, rls-&gt;_runLoops);</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopSourceUnlock(rls);</span><br><span class="line">    if (loops) &#123;</span><br><span class="line">	CFBagApplyFunction(loops, __CFRunLoopSourceWakeUpLoop, NULL);</span><br><span class="line">        CFRelease(loops);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __CFRunLoopSourceWakeUpLoop(const void *value, void *context) &#123;</span><br><span class="line">    // 主动唤醒RunLoop</span><br><span class="line">    CFRunLoopWakeUp((CFRunLoopRef)value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面给出的相关代码，我想可以解释<code>Source0</code>是如何被触发的了。</p>
<p>使用<code>Source0</code>的情况：</p>
<ul>
<li><p>触摸事件处理；<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/RunLoop%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.jpg" alt="RunLoop处理触摸事件"></p>
</li>
<li><p>调用<code>performSelector:onThread:withObject:waitUntilDone:</code>方法；</p>
</li>
</ul>
<h4 id="Source1"><a href="#Source1" class="headerlink" title="Source1"></a>Source1</h4><p><code>Source1</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    CFIndex	version;</span><br><span class="line">    void *	info;</span><br><span class="line">    const void *(*retain)(const void *info);</span><br><span class="line">    void	(*release)(const void *info);</span><br><span class="line">    CFStringRef	(*copyDescription)(const void *info);</span><br><span class="line">    Boolean	(*equal)(const void *info1, const void *info2);</span><br><span class="line">    CFHashCode	(*hash)(const void *info);</span><br><span class="line">#if (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)</span><br><span class="line">    mach_port_t	(*getPort)(void *info);</span><br><span class="line">    void *	(*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info);</span><br><span class="line">#else</span><br><span class="line">    void *	(*getPort)(void *info);</span><br><span class="line">    void	(*perform)(void *info);</span><br><span class="line">#endif</span><br><span class="line">&#125; CFRunLoopSourceContext1;</span><br></pre></td></tr></table></figure>
<p><code>Source1</code>中有一个<code>mach_port_t</code>，mach_port是用于内核向线程发送消息的。 注意：<strong>Source1在处理的时候会分发一些操作给Source0去处理</strong>。</p>
<p>使用<code>Source1</code>的情况：</p>
<ul>
<li>基于端口的线程间通信（A线程通过端口发送消息到B线程，这个消息是<code>Source1</code>的；</li>
<li>系统事件的捕捉，以点击屏幕触发事件为例，我们点击屏幕到系统捕捉到这个点击事件是<code>Source1</code>，接着分发到<code>Source0</code>去处理这个点击事件。</li>
</ul>
<h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><p><code>CFRunLoopObserverRef</code>对应着<code>__CFRunLoopObserver</code>结构体，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoopObserver &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFIndex _rlCount;</span><br><span class="line">    CFOptionFlags _activities;		/* immutable */</span><br><span class="line">    CFIndex _order;			/* immutable */</span><br><span class="line">    CFRunLoopObserverCallBack _callout;	/* immutable */</span><br><span class="line">    CFRunLoopObserverContext _context;	/* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个<code>Observer</code>都包含了一个回调（函数指针<code>CFRunLoopObserverCallBack _callout</code>），当RunLoop的状态发生变化时，观察者就能通过回调接受到这个变化。</p>
<p>RunLoop有以下几种状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入loop</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 结束休眠或被唤醒</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7), // 退出loop</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用<code>Observer</code>的情况：</p>
<ul>
<li>用于监听RunLoop的状态；</li>
<li>UI刷新（Before Waiting）；</li>
<li>AutoreleasePool释放；</li>
</ul>
<h4 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h4><p><code>CFRunLoopTimerRef</code>对应着<code>__CFRunLoopTimer</code>结构体，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoopTimer &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    uint16_t _bits;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFMutableSetRef _rlModes;</span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    CFTimeInterval _interval;		/* immutable */</span><br><span class="line">    CFTimeInterval _tolerance;          /* mutable */</span><br><span class="line">    uint64_t _fireTSR;			/* TSR units */</span><br><span class="line">    CFIndex _order;			/* immutable */</span><br><span class="line">    CFRunLoopTimerCallBack _callout;	/* immutable */</span><br><span class="line">    CFRunLoopTimerContext _context;	/* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用<code>Timer</code>的情况：</p>
<ul>
<li>NSTimer，NSTimer基于RunLoop，其内部使用的就是<code>CFRunLoopTimerRef</code>；</li>
<li><code>performSelector:withObject:afterDelay:</code>或类似带有<code>afterDelay</code>的方法。</li>
</ul>
<h2 id="RunLoop运行"><a href="#RunLoop运行" class="headerlink" title="RunLoop运行"></a>RunLoop运行</h2><p>RunLoop通过<code>CFRunLoopRun</code>和<code>CFRunLoopRunInMode</code>这两个函数运行。</p>
<h3 id="CFRunLoopRun"><a href="#CFRunLoopRun" class="headerlink" title="CFRunLoopRun"></a>CFRunLoopRun</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数默认在<code>kCFRunLoopDefaultMode</code>下运行RunLoop，并且一直运行在一个do-while的循环里。<br>另外函数不会主动调用<code>CFRunLoopStop</code>函数（<code>kCFRunLoopRunStopped</code>）或者将所有事件源移除（<code>kCFRunLoopRunFinished</code>）。</p>
<h3 id="CFRunLoopRunInMode"><a href="#CFRunLoopRunInMode" class="headerlink" title="CFRunLoopRunInMode"></a>CFRunLoopRunInMode</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是<code>CFRunLoopRun</code>还是<code>CFRunLoopRunInMode</code>都是调用了<code>CFRunLoopRunSpecific</code>。</p>
<h3 id="CFRunLoopRunSpecific"><a href="#CFRunLoopRunSpecific" class="headerlink" title="CFRunLoopRunSpecific"></a>CFRunLoopRunSpecific</h3><p>这里对<code>CFRunLoopRunSpecific</code>函数的实现做了精简处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;</span><br><span class="line">    // 第1步：通知Observers，进入loop</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    // 具体要做的事情</span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    // 第10步：通知Observers，退出loop</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CFRunLoopRun-1"><a href="#CFRunLoopRun-1" class="headerlink" title="__CFRunLoopRun"></a>__CFRunLoopRun</h3><p><code>__CFRunLoopRun</code>可以说是RunLoop运行的核心方法。由于代码过长，这里对代码进行了精简：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 第2步：通知Observers，即将处理Timers</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        // 第3步：通知Observers，即将处理Source</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        // 处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        // 第4步：处理Source0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            // 处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</span><br><span class="line">        </span><br><span class="line">        // 第5步：判断有无Source1，有Source1，跳转到handle_msg</span><br><span class="line">        if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">            // </span><br><span class="line">            goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        didDispatchPortLastTime = false;</span><br><span class="line">        </span><br><span class="line">        // 第6步：通知Observers，即将进入休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        </span><br><span class="line">        // RunLoop休眠</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        CFAbsoluteTime sleepStart = poll ? 0.0 : CFAbsoluteTimeGetCurrent();</span><br><span class="line">        </span><br><span class="line">        // 第7步：等待别的消息来唤醒，如果没有被唤醒那就不会执行下面的代码</span><br><span class="line">        // 这些消息可能是：</span><br><span class="line">        // 一个基于port的Source的事件。</span><br><span class="line">        // 一个Timer到时间了</span><br><span class="line">        // RunLoop自身的超时时间到了</span><br><span class="line">        // 被其他什么调用者手动唤醒</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet,</span><br><span class="line">                                   &amp;msg,</span><br><span class="line">                                   sizeof(msg_buffer),</span><br><span class="line">                                   &amp;livePort, poll ? 0 : TIMEOUT_INFINITY,</span><br><span class="line">                                   &amp;voucherState,</span><br><span class="line">                                   &amp;voucherCopy);</span><br><span class="line">        </span><br><span class="line">        rl-&gt;_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));</span><br><span class="line">        </span><br><span class="line">        // 取消RunLoop的休眠</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        // 第8步：通知Observers，结束休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">    </span><br><span class="line">    // 判断RunLoop被唤醒的方式，并处理对应的事件</span><br><span class="line">    handle_msg:;</span><br><span class="line">        // 判断RunLoop被唤醒的方式</span><br><span class="line">        // MACH_PORT_NULL == livePort和livePort == rl-&gt;_wakeUpPort两种情况什么都不做，省略</span><br><span class="line">        // 被timer唤醒</span><br><span class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            // 处理timer</span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time());</span><br><span class="line">        &#125;</span><br><span class="line">        // 被GCD唤醒</span><br><span class="line">        else if (livePort == dispatchPort) &#123;</span><br><span class="line">            // 处理GCD</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        // 被Source1唤醒</span><br><span class="line">        else &#123;</span><br><span class="line">            // 处理Source1</span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        // 第9步：决定RunLoop的返回值</span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            // 处理完事件就返回</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            // 超时</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            // RunLoop终止</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">            // mode终止</span><br><span class="line">            rlm-&gt;_stopped = false;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; while (0 == retVal);</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunLoop运行流程图：<img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/RunLoop_run.png" alt="RunLoop_run"></p>
<p>上述过程中有两个地方要注意：</p>
<p><strong>1.RunLoop处理GCD事件</strong></p>
<p>在大多数情况，RunLoop和GCD各自有这自己的执行流程，不会出现依赖，但是有一种情况比较特殊。先看以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;1111111&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>打印函数调用栈：<br><img src="https://neroblog.oss-cn-hangzhou.aliyuncs.com/RunLoop%E5%A4%84%E7%90%86GCD.jpg" alt="RunLoop处理GCD事件"></p>
<p>使用GCD异步操作的时候，我们在一个子线程处理完一些事情后，要返回主线程处理事情的时候，这时候需要依赖于RunLoop。内部会调用<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code>函数。</p>
<p><strong>2.RunLoop休眠</strong></p>
<p>当RunLoop一旦休眠意味着CPU不会分配任何资源，那线程也就没有事情干了，也进入休眠。RunLoop休眠内部是调用了<code>mach_msg()</code>函数。操作系统中有内核层面的API和应用层面的API。内核层面的API是不会轻易暴露出来，<code>mach_msg()</code>可以理解为是应用层面的API，告诉内核休眠该线程休眠。一旦接受到系统事件，也会转化成内核API，告诉内核需要唤醒该线程，那么又可以执行应用层API了。所以RunLoop的休眠可以看成是用户状态到内核状态的切换，而唤醒RunLoop就是内核状态到用户状态的切换。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于总结的东西相对来说比较多，会以面试题的形式单独写一篇<a href="https://www.neroxie.com/2019/07/26/RunLoop%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/">RunLoop面试题分析</a>来总结</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《程序员的自我修养》<br><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CoreFoundation源代码</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a><br><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">苹果文档–RunLoop</a></p>
]]></content>
      <categories>
        <category>RunLoop</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
</search>
